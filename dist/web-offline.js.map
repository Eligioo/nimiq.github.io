{"version":3,"sources":["src/main/platform/browser/index.prefix.js","src/main/platform/browser/Class.js","src/main/platform/browser/utils/LogNative.js","src/main/generic/utils/Log.js","src/main/generic/utils/Observable.js","src/main/platform/browser/crypto/CryptoLib.js","src/main/generic/utils/array/ArrayUtils.js","src/main/generic/utils/assert/Assert.js","src/main/generic/utils/buffer/BufferUtils.js","src/main/generic/utils/buffer/SerialBuffer.js","src/main/generic/utils/number/NumberUtils.js","src/main/generic/utils/merkle/MerklePath.js","src/main/generic/utils/platform/PlatformUtils.js","src/main/generic/utils/string/StringUtils.js","src/main/generic/consensus/Policy.js","src/main/generic/consensus/base/primitive/Serializable.js","src/main/generic/consensus/base/primitive/Hash.js","src/main/generic/consensus/base/primitive/PrivateKey.js","src/main/generic/consensus/base/primitive/PublicKey.js","src/main/generic/consensus/base/primitive/KeyPair.js","src/main/generic/consensus/base/primitive/RandomSecret.js","src/main/generic/consensus/base/primitive/Signature.js","src/main/generic/consensus/base/primitive/Commitment.js","src/main/generic/consensus/base/primitive/CommitmentPair.js","src/main/generic/consensus/base/primitive/PartialSignature.js","src/main/generic/consensus/base/account/Address.js","src/main/generic/consensus/base/account/Account.js","src/main/generic/consensus/base/transaction/Transaction.js","src/main/generic/consensus/base/transaction/SignatureProof.js","src/main/generic/consensus/base/transaction/BasicTransaction.js","src/main/generic/consensus/base/transaction/ExtendedTransaction.js","src/main/generic/utils/IWorker.js","src/main/generic/utils/WasmHelper.js","src/main/generic/utils/crypto/CryptoWorker.js","src/main/generic/consensus/GenesisConfigOffline.js","src/main/platform/browser/index.suffix.js"],"names":["Nimiq","window","Proxy","exports","_currentScript","document","currentScript","scripts","getElementsByTagName","length","_path","src","indexOf","substring","lastIndexOf","Class","scope","[object Object]","cls","name","register","LogNative","this","_global_level","Log","INFO","_tag_levels","localStorage","c","getItem","JSON","parse","e","console","warn","tag","level","setItem","stringify","args","isLoggable","unshift","Level","toStringTag","Date","toTimeString","substr","error","ERROR","apply","WARNING","info","debug","DEBUG","trace","TRACE","log","instance","_instance","native","_native","setLoggable","get","l","i","toString","constructor","msg","message","arguments","Array","prototype","slice","call","undefined","VERBOSE","ASSERT","v","isNaN","parseInt","toLowerCase","d","bind","w","t","Observable","WILDCARD","_listeners","Map","clear","type","callback","has","push","set","id","promises","listeners","key","res","Promise","all","observable","types","fire","on","CryptoLib","getRandomValues","crypto","msCrypto","ArrayUtils","arr","Math","floor","random","uintarr","begin","end","clamp","min","max","byteLength","len","Uint8Array","buffer","byteOffset","list","k","n","indices","from","x","map","reverseRange","found","j","Assert","condition","Error","BufferUtils","String","fromCharCode","string","buf","charCodeAt","u8","TextDecoder","_ISO_8859_15_DECODER","decode","replace","num","_BASE64_LOOKUP","start","tmp","output","_tripletToBase64","join","extraBytes","parts","len2","_base64encodeChunk","PlatformUtils","isNodeJs","Buffer","btoa","_codePointTextDecoder","_base64fromByteArray","base64","SerialBuffer","atob","toBase64","alphabet","BASE32_ALPHABET","NIMIQ","byte","symbol","shift","carry","base32","charmap","toUpperCase","split","forEach","char","hex","code","HEX_ALPHABET","trim","StringUtils","isHexBytes","match","a","b","viewA","viewB","BASE64_ALPHABET","RFC4648","RFC4648_HEX","bufferOrArrayOrLength","super","_view","DataView","_readPos","_writePos","subarray","readPos","value","writePos","array","getUint8","setUint8","getUint16","setUint16","getUint32","setUint32","pow","NumberUtils","isUint64","readUint8","readUint16","readUint32","readUint64","writeUint8","writeUint16","writeUint32","writeUint64","getFloat64","setFloat64","bytes","read","toAscii","isMultibyte","fromAscii","write","view","padding","isUint8","val","Number","isInteger","UINT8_MAX","UINT16_MAX","UINT32_MAX","UINT64_MAX","MAX_SAFE_INTEGER","MerklePath","nodes","isArray","some","it","MerklePathNode","_nodes","values","leafValue","fnHash","MerkleTree","_hash","leafHash","path","_compute","hash","containsLeaf","inner","Hash","light","equals","mid","round","left","right","leftLeaf","leftHash","rightLeaf","rightHash","concatTypedArrays","serialize","root","node","concat","serializedSize","count","leftBitsSize","ceil","leftBits","unserialize","_compress","reduce","sum","o","every","_left","isBrowser","process","require","RTCPeerConnection","webkitRTCPeerConnection","navigator","onLine","str","test","isHex","str1","str2","Policy","coins","SATOSHIS_PER_COIN","satoshis","blockHeight","startHeight","_supplyCacheInterval","startI","_supplyCacheMax","endI","supply","INITIAL_SUPPLY","_supplyCache","endHeight","_supplyAfter","initialSupply","_blockRewardAt","currentSupply","supplyAfter","remaining","TOTAL_SUPPLY","EMISSION_TAIL_START","EMISSION_TAIL_REWARD","EMISSION_SPEED","BLOCK_TIME","BLOCK_SIZE_MAX","BLOCK_TARGET_MAX","DIFFICULTY_BLOCK_WINDOW","DIFFICULTY_MAX_ADJUSTMENT_FACTOR","TRANSACTION_VALIDITY_WINDOW","M","K","DELTA","NUM_BLOCKS_VERIFICATION","NUM_SNAPSHOTS_MAX","Serializable","compare","toHex","arg","algorithm","Algorithm","BLAKE2B","getSize","_obj","_algorithm","blake2b","computeBlake2b","argon2d","CryptoWorker","getInstanceAsync","computeArgon2d","ARGON2D","computeSha256","SHA256","sha256","SIZE","fromBase64","fromHex","size","input","out","NodeNative","node_blake2","stackPtr","Module","stackSave","hashSize","wasmOut","stackAlloc","wasmIn","HEAPU8","_nimiq_blake2","stackRestore","node_sha256","_nimiq_sha256","SHA512","NULL","PrivateKey","privateKey","lib","publicKey","publicKeysHash","PublicKey","node_ed25519_derive_delinearized_private_key","wasmInPrivateKey","wasmInPublicKey","wasmInPublicKeysHash","_ed25519_derive_delinearized_private_key","delinearizedPrivateKey","CryptoWorkerImpl","_publicKeyDerive","publicKeys","sort","_delinearizeAndAggregatePublicKeys","Address","fromHash","PeerId","publicKeysObj","_publicKeysHash","raw","_publicKeysDelinearizeAndAggregate","node_ed25519_public_key_derive","pubKeyBuffer","HEAP8","privKeyBuffer","_ed25519_public_key_derive","fill","concatenatedPublicKeys","node_ed25519_hash_public_keys","wasmInPublicKeys","_ed25519_hash_public_keys","hashedPublicKey","node_ed25519_delinearize_public_key","_ed25519_delinearize_public_key","delinearizedPublicKey","node_ed25519_aggregate_delinearized_public_keys","_ed25519_aggregate_delinearized_public_keys","aggregatePublicKey","KeyPair","locked","lockSalt","Object","_locked","_lockedInternally","_lockSalt","_publicKey","_internalPrivateKey","generate","derive","hexBuf","roundsLog","rounds","encryptedKey","salt","EXPORT_SALT_LENGTH","check","EXPORT_CHECKSUM_LENGTH","_otpKdf","keyPair","pubHash","_privateKey","isLocked","_unlockedPrivateKey","unlockKey","wasLocked","unlock","encryptedSize","log2","EXPORT_KDF_ROUNDS","relock","overwrite","_otpPrivateKey","_clearUnlockedPrivateKey","LOCK_KDF_ROUNDS","iterations","xor","kdf","RandomSecret","Signature","obj","data","_signatureCreate","commitment","signatures","_combinePartialSignatures","s","_signatureVerify","combinedCommitment","partialSignatures","combinedSignature","_aggregatePartialSignatures","sigA","sigB","_scalarsAdd","PartialSignature","node_ed25519_add_scalars","wasmOutSum","wasmInA","wasmInB","_ed25519_add_scalars","node_ed25519_sign","wasmOutSignature","signatureBuffer","wasmInMessage","wasmInPubKey","wasmInPrivKey","_ed25519_sign","signature","node_ed25519_verify","wasmInSignature","_ed25519_verify","Commitment","commitments","_commitmentsAggregate","concatenatedCommitments","node_ed25519_aggregate_commitments","wasmInCommitments","_ed25519_aggregate_commitments","aggCommitments","CommitmentPair","secret","_secret","_commitment","randomness","RANDOMNESS_SIZE","_commitmentCreate","node_ed25519_create_commitment","wasmOutCommitment","wasmOutSecret","_ed25519_create_commitment","SERIALIZED_SIZE","aggregateCommitment","_delinearizedPartialSignatureCreate","node_ed25519_delinearized_partial_sign","wasmInSecret","wasmInCommitment","_ed25519_delinearized_partial_sign","partialSignature","fromUserFriendlyAddress","CCODE","_ibanCheck","fromBase32","withSpaces","toBase32","HEX_SIZE","CONTRACT_CREATION","Account","balance","_type","_balance","TYPE_MAP","transaction","transactionsCache","revert","validityStartHeight","withBalance","fee","newBalance","containsTransaction","INITIAL","isInitial","Type","BASIC","VESTING","HTLC","Transaction","format","sender","senderType","recipient","recipientType","flags","proof","networkId","GenesisConfig","NETWORK_ID","isUint32","Flag","isUint16","_format","_sender","_senderType","_recipient","_recipientType","_value","_fee","_networkId","_validityStartHeight","_flags","_data","_proof","getContractCreationAddress","FORMAT_MAP","serializedContentSize","_valid","_verify","verifyOutgoingTransaction","verifyIncomingTransaction","serializeContent","compareBlockOrder","recCompare","senderCompare","tx","feePerByte","flag","Format","EXTENDED","NONE","ALL","SignatureProof","verify","signerKey","merklePath","compute","_merklePath","_signature","isSignedBy","merkleRoot","computeRoot","BasicTransaction","senderPubKey","singleSig","toAddress","_signatureProof","that","ExtendedTransaction","dataSize","proofSize","IWorker","clazz","worker","workerScript","_workersSupported","createProxy","Worker","URL","createObjectURL","Blob","_workerImplementation","init","Pool","startWorkerForProxy","command","self","postMessage","status","result","areWorkersAsync","_insideWebWorker","WorkerGlobalScope","_global","global","baseClazz","impl","onmessage","stubBaseOnMessage","url","resolve","head","script","createElement","ret","setTimeout","onreadystatechange","onload","appendChild","proxyClass","_name","_messageId","_worker","_receive","_waiting","_invoke","then","cb","delete","WorkerProxy","funcName","getOwnPropertyNames","Stub","finalRes","_result","_onmessage","close","poolClass","proxyInitializer","_proxyInitializer","_poolSize","_workers","_freeWorkers","_waitingCalls","_updateToSize","poolSize","_size","catch","_step","destroy","workerPromises","createdWorkers","pop","idx","splice","_moduleLoadedCallbacks","WasmHelper","_importStarted","importWasmBrowser","importScriptBrowser","_importFinished","importWasmNodeJs","importScriptNodeJs","wasm","module","_adjustWasmPath","WebAssembly","xhr","XMLHttpRequest","open","responseType","wasmBinary","response","onerror","send","fs","readFileSync","u","toUint8Array","asm","_adjustScriptPath","moduleSettings","async","reject","onRuntimeInitialized","importScripts","_loadBrowserScript","__dirname","_workerAsync","startWorkerPoolForProxy","inputs","block","transactionValid","timeNow","genesisHash","CONFIGS","config","_config","NETWORK_NAME","dev","bounty","_loaded","_onload"],"mappings":"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","file":"web-offline.js","sourcesContent":["if (typeof Nimiq === 'undefined') {\n    var Nimiq = typeof window !== 'undefined' ? window : {};\n}\nvar Proxy; // ensure Proxy exists\n(function (exports) {\n    exports = typeof exports !== 'undefined' ? exports : {};\n    Nimiq = exports;\n    if (!Nimiq._currentScript) {\n        Nimiq._currentScript = document.currentScript;\n    }\n    if (!Nimiq._currentScript) {\n        // Heuristic\n        const scripts = document.getElementsByTagName('script');\n        Nimiq._currentScript = scripts[scripts.length - 1];\n    }\n    if (!Nimiq._path) {\n        if (Nimiq._currentScript && Nimiq._currentScript.src.indexOf('/') !== -1) {\n            Nimiq._path = Nimiq._currentScript.src.substring(0, Nimiq._currentScript.src.lastIndexOf('/') + 1);\n        } else {\n            // Fallback\n            Nimiq._path = './';\n        }\n    }\n","class Class {\n    static get scope() {\n        if (typeof exports !== 'undefined') return exports;\n        return window;\n    }\n\n    static register(cls) {\n        if (typeof exports !== 'undefined') exports[cls.name] = cls;\n    }\n}\nClass.register(Class);\n","class LogNative {\n    constructor() {\n        this._global_level = Log.INFO;\n        this._tag_levels = {};\n        try {\n            if (window.localStorage) {\n                try {\n                    let c = window.localStorage.getItem('log_tag_levels');\n                    if (c && typeof c === 'string') c = JSON.parse(c);\n                    if (c && typeof c === 'object') this._tag_levels = c;\n                } catch (e) {\n                    console.warn('Failed to load log configuration from local storage.');\n                }\n            }\n        } catch (e) {\n            // ignore\n        }\n    }\n\n    isLoggable(tag, level) {\n        if (tag && this._tag_levels[tag]) {\n            return this._tag_levels[tag] <= level;\n        }\n        if (this._tag_levels['*']) {\n            return this._tag_levels['*'] <= level;\n        }\n        return this._global_level <= level;\n    }\n\n    setLoggable(tag, level) {\n        if (tag && tag.name) tag = tag.name;\n        this._tag_levels[tag] = level;\n        if (window.localStorage) {\n            window.localStorage.setItem('log_tag_levels', JSON.stringify(this._tag_levels));\n        }\n    }\n\n    msg(level, tag, args) {\n        if (tag && tag.name) tag = tag.name;\n        if (!this.isLoggable(tag, level)) return;\n        if (tag) args.unshift(tag + ':');\n        args.unshift(`[${Log.Level.toStringTag(level)} ${new Date().toTimeString().substr(0, 8)}]`);\n        if (console.error && level >= Log.ERROR) {\n            console.error.apply(console, args);\n        } else if (console.warn && level >= Log.WARNING) {\n            console.warn.apply(console, args);\n        } else if (console.info && level >= Log.INFO) {\n            console.info.apply(console, args);\n        } else if (console.debug && level >= Log.DEBUG) {\n            console.debug.apply(console, args);\n        } else if (console.trace && level <= Log.TRACE) {\n            console.trace.apply(console, args);\n        } else {\n            console.log.apply(console, args);\n        }\n    }\n}\nClass.register(LogNative);\n","class Log {\n    /**\n     * @returns {Log}\n     */\n    static get instance() {\n        if (!Log._instance) {\n            Log._instance = new Log(new LogNative());\n        }\n        return Log._instance;\n    }\n\n    /**\n     * @param {LogNative} native\n     */\n    constructor(native) {\n        /** @type {LogNative} */\n        this._native = native;\n    }\n\n    /**\n     * @param {string} tag\n     * @param {Log.Level} level\n     */\n    setLoggable(tag, level) {\n        this._native.setLoggable(tag, Log.Level.get(level));\n    }\n\n    /** @type {Log.Level} */\n    get level() {\n        return this._native._global_level;\n    }\n\n    /** @type {Log.Level} */\n    set level(l) {\n        this._native._global_level = Log.Level.get(l);\n    }\n\n    /**\n     * @param {Log.Level} level\n     * @param {string|{name:string}} tag\n     * @param {Array} args\n     */\n    msg(level, tag, args) {\n        if (this._native.isLoggable(tag, level)) {\n            for (let i = 0; i < args.length; ++i) {\n                if (typeof args[i] === 'function') {\n                    args[i] = args[i]();\n                }\n                if (typeof args[i] === 'object') {\n                    if (typeof args[i].toString === 'function') {\n                        args[i] = args[i].toString();\n                    } else if (args[i].constructor && args[i].constructor.name) {\n                        args[i] = `{Object: ${args[i].constructor.name}}`;\n                    } else {\n                        args[i] = '{Object}';\n                    }\n                }\n            }\n            this._native.msg(level, tag, args);\n        }\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static d(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.DEBUG, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static e(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.ERROR, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static i(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.INFO, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static v(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.VERBOSE, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static w(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.WARNING, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static t(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.TRACE, tag, args);\n    }\n}\n\n/**\n * @enum {number|string}\n */\nLog.Level = {\n    TRACE: 1,\n    VERBOSE: 2,\n    DEBUG: 3,\n    INFO: 4,\n    WARNING: 5,\n    ERROR: 6,\n    ASSERT: 7,\n\n    /**\n     * @param {Log.Level} level\n     * @returns {string}\n     */\n    toStringTag: function (level) {\n        switch (level) {\n            case Log.Level.TRACE:\n                return 'T';\n            case Log.Level.VERBOSE:\n                return 'V';\n            case Log.Level.DEBUG:\n                return 'D';\n            case Log.Level.INFO:\n                return 'I';\n            case Log.Level.WARNING:\n                return 'W';\n            case Log.Level.ERROR:\n                return 'E';\n            case Log.Level.ASSERT:\n                return 'A';\n            default:\n                return '*';\n        }\n    },\n\n    toString: function (level) {\n        switch (level) {\n            case Log.Level.TRACE:\n                return 'trace';\n            case Log.Level.VERBOSE:\n                return 'verbose';\n            case Log.Level.DEBUG:\n                return 'debug';\n            case Log.Level.INFO:\n                return 'info';\n            case Log.Level.WARNING:\n                return 'warn';\n            case Log.Level.ERROR:\n                return 'error';\n            case Log.Level.ASSERT:\n                return 'assert';\n            default:\n                return 'unknown';\n        }\n    },\n\n    /**\n     * @param {string|number|Log.Level} v\n     * @returns {Log.Level}\n     */\n    get: function (v) {\n        if (typeof v === 'number') return /** @type {Log.Level} */ v;\n        if (!isNaN(parseInt(v))) return /** @type {Log.Level} */ parseInt(v);\n        switch (v.toLowerCase()) {\n            case 't':\n            case 'trace':\n                return Log.Level.TRACE;\n            case 'v':\n            case 'verbose':\n                return Log.Level.VERBOSE;\n            case 'd':\n            case 'debug':\n                return Log.Level.DEBUG;\n            case 'i':\n            case 'info':\n                return Log.Level.INFO;\n            case 'w':\n            case 'warn':\n            case 'warning':\n                return Log.Level.WARNING;\n            case 'e':\n            case 'error':\n            case 'exception':\n                return Log.Level.ERROR;\n            case 'a':\n            case 'assert':\n            case 'assertion':\n                return Log.Level.ASSERT;\n        }\n        return /** @type {Log.Level} */ 0;\n    }\n};\nLog.TRACE = Log.Level.TRACE;\nLog.VERBOSE = Log.Level.VERBOSE;\nLog.DEBUG = Log.Level.DEBUG;\nLog.INFO = Log.Level.INFO;\nLog.WARNING = Log.Level.WARNING;\nLog.ERROR = Log.Level.ERROR;\nLog.ASSERT = Log.Level.ASSERT;\nLog._instance = null;\n\nLog.d.tag = (tag) => Log.d.bind(null, tag);\nLog.e.tag = (tag) => Log.e.bind(null, tag);\nLog.i.tag = (tag) => Log.i.bind(null, tag);\nLog.v.tag = (tag) => Log.v.bind(null, tag);\nLog.w.tag = (tag) => Log.w.bind(null, tag);\nLog.t.tag = (tag) => Log.t.bind(null, tag);\n\nClass.register(Log);\n","class Observable {\n    /**\n     * @returns {string}\n     * @constant\n     */\n    static get WILDCARD() {\n        return '*';\n    }\n\n    constructor() {\n        /** @type {Map.<string, Array.<Function>>} */\n        this._listeners = new Map();\n    }\n\n    _offAll() {\n        this._listeners.clear();\n    }\n\n    /**\n     * @param {string} type\n     * @param {Function} callback\n     * @return {number}\n     */\n    on(type, callback) {\n        if (!this._listeners.has(type)) {\n            this._listeners.set(type, [callback]);\n            return 0;\n        } else {\n            return this._listeners.get(type).push(callback) - 1;\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @param {number} id\n     */\n    off(type, id) {\n        if (!this._listeners.has(type) || !this._listeners.get(type)[id]) return;\n        delete this._listeners.get(type)[id];\n    }\n\n    /**\n     * @param {string} type\n     * @param {...*} args\n     * @returns {Promise|null}\n     */\n    fire(type, ...args) {\n        const promises = [];\n        // Notify listeners for this event type.\n        if (this._listeners.has(type)) {\n            const listeners = this._listeners.get(type);\n            for (const key in listeners) {\n                // Skip non-numeric properties.\n                if (isNaN(key)) continue;\n\n                const listener = listeners[key];\n                const res = listener.apply(null, args);\n                if (res instanceof Promise) promises.push(res);\n            }\n        }\n\n        // Notify wildcard listeners. Pass event type as first argument\n        if (this._listeners.has(Observable.WILDCARD)) {\n            const listeners = this._listeners.get(Observable.WILDCARD);\n            for (const key in listeners) {\n                // Skip non-numeric properties.\n                if (isNaN(key)) continue;\n\n                const listener = listeners[key];\n                const res = listener.apply(null, arguments);\n                if (res instanceof Promise) promises.push(res);\n            }\n        }\n\n        if (promises.length > 0) return Promise.all(promises);\n        return null;\n    }\n\n    /**\n     * @param {Observable} observable\n     * @param {...string} types\n     */\n    bubble(observable, ...types) {\n        for (const type of types) {\n            let callback;\n            if (type === Observable.WILDCARD) {\n                callback = function() {\n                    this.fire.apply(this, arguments);\n                };\n            } else {\n                callback = function() {\n                    this.fire.apply(this, [type, ...arguments]);\n                };\n            }\n            observable.on(type, callback.bind(this));\n        }\n    }\n}\nClass.register(Observable);\n","class CryptoLib {\n    /**\n     * @return {SubtleCrypto|*}\n     */\n    static get instance() {\n        if (!CryptoLib._instance) {\n            const instance = {};\n            instance.getRandomValues = (window.crypto || window.msCrypto).getRandomValues.bind(window.crypto);\n\n            CryptoLib._instance = instance;\n        }\n        return CryptoLib._instance;\n    }\n}\nCryptoLib._instance = null;\nClass.register(CryptoLib);\n","class ArrayUtils {\n    /**\n     * @template T\n     * @param {Array.<T>} arr\n     * @return {T}\n     */\n    static randomElement(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n\n    /**\n     * @param {Uint8Array} uintarr\n     * @param {number} begin\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    static subarray(uintarr, begin, end) {\n        function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n        if (begin === undefined) { begin = 0; }\n        if (end === undefined) { end = uintarr.byteLength; }\n\n        begin = clamp(begin, 0, uintarr.byteLength);\n        end = clamp(end, 0, uintarr.byteLength);\n\n        let len = end - begin;\n        if (len < 0) {\n            len = 0;\n        }\n\n        return new Uint8Array(uintarr.buffer, uintarr.byteOffset + begin, len);\n    }\n\n    /**\n     * @param {Array} list\n     * @param {number} k\n     * @return {Generator}\n     */\n    static *k_combinations(list, k) {\n        const n = list.length;\n        // Shortcut:\n        if (k > n) {\n            return;\n        }\n        const indices = Array.from(new Array(k), (x,i) => i);\n        yield indices.map(i => list[i]);\n        const reverseRange = Array.from(new Array(k), (x,i) => k-i-1);\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n            let i = k-1, found = false;\n            for (i of reverseRange) {\n                if (indices[i] !== i + n - k) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return;\n            }\n            indices[i] += 1;\n            for (const j of Array.from(new Array(k-i-1), (x,k) => i+k+1)) {\n                indices[j] = indices[j-1] + 1;\n            }\n            yield indices.map(i => list[i]);\n        }\n    }\n}\nClass.register(ArrayUtils);\n","class Assert {\n    /**\n     * @param {boolean} condition\n     * @param {string} [message]\n     * @returns {void}\n     */\n    static that(condition, message = 'Assertion failed') {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nClass.register(Assert);\n","class BufferUtils {\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toAscii(buffer) {\n        return String.fromCharCode.apply(null, new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} string\n     * @return {Uint8Array}\n     */\n    static fromAscii(string) {\n        const buf = new Uint8Array(string.length);\n        for (let i = 0; i < string.length; ++i) {\n            buf[i] = string.charCodeAt(i);\n        }\n        return buf;\n    }\n\n    static _codePointTextDecoder(u8) {\n        if (typeof TextDecoder === 'undefined') throw new Error('TextDecoder not supported');\n        if (BufferUtils._ISO_8859_15_DECODER === null) throw new Error('TextDecoder does not supprot iso-8859-15');\n        if (BufferUtils._ISO_8859_15_DECODER === undefined) {\n            try {\n                BufferUtils._ISO_8859_15_DECODER = new TextDecoder('iso-8859-15');\n            } finally {\n                BufferUtils._ISO_8859_15_DECODER = null;\n            }\n        }\n        return BufferUtils._ISO_8859_15_DECODER.decode(u8)\n            .replace('€', '¤').replace('Š', '¦').replace('š', '¨').replace('Ž', '´')\n            .replace('ž', '¸').replace('Œ', '¼').replace('œ', '½').replace('Ÿ', '¾');\n    }\n\n    static _tripletToBase64(num) {\n        return BufferUtils._BASE64_LOOKUP[num >> 18 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 12 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 6 & 0x3F] + BufferUtils._BASE64_LOOKUP[num & 0x3F];\n    }\n\n    static _base64encodeChunk(u8, start, end) {\n        let tmp;\n        const output = [];\n        for (let i = start; i < end; i += 3) {\n            tmp = ((u8[i] << 16) & 0xFF0000) + ((u8[i + 1] << 8) & 0xFF00) + (u8[i + 2] & 0xFF);\n            output.push(BufferUtils._tripletToBase64(tmp));\n        }\n        return output.join('');\n    }\n\n    static _base64fromByteArray(u8) {\n        let tmp;\n        const len = u8.length;\n        const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        let output = '';\n        const parts = [];\n        const maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n            parts.push(BufferUtils._base64encodeChunk(u8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n            tmp = u8[len - 1];\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 2];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 4) & 0x3F];\n            output += '==';\n        } else if (extraBytes === 2) {\n            tmp = (u8[len - 2] << 8) + (u8[len - 1]);\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 10];\n            output += BufferUtils._BASE64_LOOKUP[(tmp >> 4) & 0x3F];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 2) & 0x3F];\n            output += '=';\n        }\n\n        parts.push(output);\n\n        return parts.join('');\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64(buffer) {\n        if (PlatformUtils.isNodeJs()) {\n            return new Buffer(buffer).toString('base64');\n        } else if (typeof TextDecoder !== 'undefined' && BufferUtils._ISO_8859_15_DECODER !== null) {\n            try {\n                return btoa(BufferUtils._codePointTextDecoder(new Uint8Array(buffer)));\n            } catch (e) {\n                // Disabled itself\n            }\n        }\n\n        return BufferUtils._base64fromByteArray(new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64Url(buffer) {\n        return BufferUtils.toBase64(buffer).replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '.');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64Url(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64.replace(/_/g, '/').replace(/-/g, '+').replace(/\\./g, '=')), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {Uint8Array} buf\n     * @param {string} [alphabet] Alphabet to use\n     * @return {string}\n     */\n    static toBase32(buf, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        let shift = 3, carry = 0, byte, symbol, i, res = '';\n\n        for (i = 0; i < buf.length; i++) {\n            byte = buf[i];\n            symbol = carry | (byte >> shift);\n            res += alphabet[symbol & 0x1f];\n\n            if (shift > 5) {\n                shift -= 5;\n                symbol = byte >> shift;\n                res += alphabet[symbol & 0x1f];\n            }\n\n            shift = 5 - shift;\n            carry = byte << shift;\n            shift = 8 - shift;\n        }\n\n        if (shift !== 3) {\n            res += alphabet[carry & 0x1f];\n        }\n\n        while (res.length % 8 !== 0 && alphabet.length === 33) {\n            res += alphabet[32];\n        }\n\n        return res;\n    }\n\n    /**\n     * @param {string} base32\n     * @param {string} [alphabet] Alphabet to use\n     * @return {Uint8Array}\n     */\n    static fromBase32(base32, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        const charmap = [];\n        alphabet.toUpperCase().split('').forEach((c, i) => {\n            if (!(c in charmap)) charmap[c] = i;\n        });\n\n        let symbol, shift = 8, carry = 0, buf = [];\n        base32.toUpperCase().split('').forEach((char) => {\n            // ignore padding\n            if (alphabet.length === 33 && char === alphabet[32]) return;\n\n            symbol = charmap[char] & 0xff;\n\n            shift -= 5;\n            if (shift > 0) {\n                carry |= symbol << shift;\n            } else if (shift < 0) {\n                buf.push(carry | (symbol >> -shift));\n                shift += 8;\n                carry = (symbol << shift) & 0xff;\n            } else {\n                buf.push(carry | symbol);\n                shift = 8;\n                carry = 0;\n            }\n        });\n\n        if (shift !== 8 && carry !== 0) {\n            buf.push(carry);\n        }\n\n        return new Uint8Array(buf);\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toHex(buffer) {\n        let hex = '';\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            hex += BufferUtils.HEX_ALPHABET[code >>> 4];\n            hex += BufferUtils.HEX_ALPHABET[code & 0x0F];\n        }\n        return hex;\n    }\n\n    /**\n     * @param {string} hex\n     * @return {SerialBuffer}\n     */\n    static fromHex(hex) {\n        hex = hex.trim();\n        if (!StringUtils.isHexBytes(hex)) return null;\n        return new SerialBuffer(Uint8Array.from(hex.match(/.{2}/g) || [], byte => parseInt(byte, 16)));\n    }\n\n    /**\n     * @template T\n     * @param {T} a\n     * @param {*} b\n     * @return {T}\n     */\n    static concatTypedArrays(a, b) {\n        const c = new (a.constructor)(a.length + b.length);\n        c.set(a, 0);\n        c.set(b, a.length);\n        return c;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        if (a.length !== b.length) return false;\n        const viewA = new Uint8Array(a);\n        const viewB = new Uint8Array(b);\n        for (let i = 0; i < a.length; i++) {\n            if (viewA[i] !== viewB[i]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {number} -1 if a is smaller than b, 1 if a is larger than b, 0 if a equals b.\n     */\n    static compare(a, b) {\n        if (a.length < b.length) return -1;\n        if (a.length > b.length) return 1;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] < b[i]) return -1;\n            if (a[i] > b[i]) return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @return {Uint8Array}\n     */\n    static xor(a, b) {\n        const res = new Uint8Array(a.byteLength);\n        for (let i = 0; i < a.byteLength; ++i) {\n            res[i] = a[i] ^ b[i];\n        }\n        return res;\n    }\n}\nBufferUtils.BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nBufferUtils.BASE32_ALPHABET = {\n    RFC4648: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    RFC4648_HEX: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    NIMIQ: '0123456789ABCDEFGHJKLMNPQRSTUVXY'\n};\nBufferUtils.HEX_ALPHABET = '0123456789abcdef';\nBufferUtils._BASE64_LOOKUP = [];\nfor (let i = 0, len = BufferUtils.BASE64_ALPHABET.length; i < len; ++i) {\n    BufferUtils._BASE64_LOOKUP[i] = BufferUtils.BASE64_ALPHABET[i];\n}\n\nClass.register(BufferUtils);\n","class SerialBuffer extends Uint8Array {\n    /**\n     * @param {*} bufferOrArrayOrLength\n     */\n    constructor(bufferOrArrayOrLength) {\n        super(bufferOrArrayOrLength);\n        this._view = new DataView(this.buffer);\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} start\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    subarray(start, end) {\n        return ArrayUtils.subarray(this, start, end);\n    }\n\n    /** @type {number} */\n    get readPos() {\n        return this._readPos;\n    }\n\n    /** @type {number} */\n    set readPos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid readPos ${value}`;\n        this._readPos = value;\n    }\n\n    /** @type {number} */\n    get writePos() {\n        return this._writePos;\n    }\n\n    /** @type {number} */\n    set writePos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid writePos ${value}`;\n        this._writePos = value;\n    }\n\n    /**\n     * Resets the read and write position of the buffer to zero.\n     * @returns {void}\n     */\n    reset() {\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} length\n     * @return {Uint8Array}\n     */\n    read(length) {\n        const value = this.subarray(this._readPos, this._readPos + length);\n        this._readPos += length;\n        return value;\n    }\n\n    /**\n     * @param {*} array\n     */\n    write(array) {\n        this.set(array, this._writePos);\n        this._writePos += array.byteLength;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint8() {\n        return this._view.getUint8(this._readPos++);\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint8(value) {\n        this._view.setUint8(this._writePos++, value);\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint16() {\n        const value = this._view.getUint16(this._readPos);\n        this._readPos += 2;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint16(value) {\n        this._view.setUint16(this._writePos, value);\n        this._writePos += 2;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint32() {\n        const value = this._view.getUint32(this._readPos);\n        this._readPos += 4;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint32(value) {\n        this._view.setUint32(this._writePos, value);\n        this._writePos += 4;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint64() {\n        const value = this._view.getUint32(this._readPos) * Math.pow(2, 32) + this._view.getUint32(this._readPos + 4);\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint64(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._view.setUint32(this._writePos, Math.floor(value / Math.pow(2, 32)));\n        this._view.setUint32(this._writePos + 4, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @return {number}\n     */\n    readVarUint() {\n        const value = this.readUint8();\n        if (value < 0xFD) {\n            return value;\n        } else if (value === 0xFD) {\n            return this.readUint16();\n        } else if (value === 0xFE) {\n            return this.readUint32();\n        } else /*if (value === 0xFF)*/ {\n            return this.readUint64();\n        }\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeVarUint(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            this.writeUint8(value);\n        } else if (value <= 0xFFFF) {\n            this.writeUint8(0xFD);\n            this.writeUint16(value);\n        } else if (value <= 0xFFFFFFFF) {\n            this.writeUint8(0xFE);\n            this.writeUint32(value);\n        } else {\n            this.writeUint8(0xFF);\n            this.writeUint64(value);\n        }\n    }\n\n    /**\n     * @param {number} value\n     * @returns {number}\n     */\n    static varUintSize(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            return 1;\n        } else if (value <= 0xFFFF) {\n            return 3;\n        } else if (value <= 0xFFFFFFFF) {\n            return 5;\n        } else {\n            return 9;\n        }\n    }\n\n    /**\n     * @return {number}\n     */\n    readFloat64() {\n        const value = this._view.getFloat64(this._readPos);\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeFloat64(value) {\n        this._view.setFloat64(this._writePos, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readString(length) {\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writeString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length !== length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readPaddedString(length) {\n        const bytes = this.read(length);\n        let i = 0;\n        while (i < length && bytes[i] !== 0x0) i++;\n        const view = new Uint8Array(bytes.buffer, bytes.byteOffset, i);\n        return BufferUtils.toAscii(view);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writePaddedString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length > length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n        const padding = length - bytes.byteLength;\n        this.write(new Uint8Array(padding));\n    }\n\n    /**\n     * @return {string}\n     */\n    readVarLengthString() {\n        const length = this.readUint8();\n        if (this._readPos + length > this.length) throw 'Malformed length';\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     */\n    writeVarLengthString(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        const bytes = BufferUtils.fromAscii(value);\n        this.writeUint8(bytes.byteLength);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @returns {number}\n     */\n    static varLengthStringSize(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        return /*length*/ 1 + value.length;\n    }\n}\nClass.register(SerialBuffer);\n","class NumberUtils {\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint8(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT8_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint16(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT16_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint32(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT32_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint64(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT64_MAX;\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint32() {\n        return Math.floor(Math.random() * (NumberUtils.UINT32_MAX + 1));\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint64() {\n        return Math.floor(Math.random() * (NumberUtils.UINT64_MAX + 1));\n    }\n}\n\nNumberUtils.UINT8_MAX = 255;\nNumberUtils.UINT16_MAX = 65535;\nNumberUtils.UINT32_MAX = 4294967295;\nNumberUtils.UINT64_MAX = Number.MAX_SAFE_INTEGER;\n//Object.freeze(NumberUtils);\nClass.register(NumberUtils);\n","class MerklePath {\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     */\n    constructor(nodes) {\n        if (!Array.isArray(nodes) || !NumberUtils.isUint8(nodes.length)\n            || nodes.some(it => !(it instanceof MerklePathNode))) throw new Error('Malformed nodes');\n        /**\n         * @type {Array.<MerklePathNode>}\n         * @private\n         */\n        this._nodes = nodes;\n    }\n\n    /**\n     * @param {Array} values\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerklePath}\n     */\n    static compute(values, leafValue, fnHash = MerkleTree._hash) {\n        const leafHash = fnHash(leafValue);\n        const path = [];\n        MerklePath._compute(values, leafHash, path, fnHash);\n        return new MerklePath(path);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Hash} leafHash\n     * @param {Array.<MerklePathNode>} path\n     * @param {function(o: *):Hash} fnHash\n     * @returns {{containsLeaf:boolean, inner:Hash}}\n     * @private\n     */\n    static _compute(values, leafHash, path, fnHash) {\n        const len = values.length;\n        let hash;\n        if (len === 0) {\n            hash = Hash.light(new Uint8Array(0));\n            return {containsLeaf: false, inner: hash};\n        }\n        if (len === 1) {\n            hash = fnHash(values[0]);\n            return {containsLeaf: hash.equals(leafHash), inner: hash};\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const {containsLeaf: leftLeaf, inner: leftHash} = MerklePath._compute(left, leafHash, path, fnHash);\n        const {containsLeaf: rightLeaf, inner: rightHash} = MerklePath._compute(right, leafHash, path, fnHash);\n        hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n\n        if (leftLeaf) {\n            path.push(new MerklePathNode(rightHash, false));\n            return {containsLeaf: true, inner: hash};\n        } else if (rightLeaf) {\n            path.push(new MerklePathNode(leftHash, true));\n            return {containsLeaf: true, inner: hash};\n        }\n\n        return {containsLeaf: false, inner: hash};\n    }\n\n    /**\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    computeRoot(leafValue, fnHash = MerkleTree._hash) {\n        /** @type {Hash} */\n        let root = fnHash(leafValue);\n        for (const node of this._nodes) {\n            const left = node.left;\n            const hash = node.hash;\n            const concat = new SerialBuffer(hash.serializedSize * 2);\n            if (left) hash.serialize(concat);\n            root.serialize(concat);\n            if (!left) hash.serialize(concat);\n            root = Hash.light(concat);\n        }\n        return root;\n    }\n\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _compress(nodes) {\n        const count = nodes.length;\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = new Uint8Array(leftBitsSize);\n\n        for (let i = 0; i < count; i++) {\n            if (nodes[i].left) {\n                leftBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return leftBits;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MerklePath}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint8();\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = buf.read(leftBitsSize);\n\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            const left = (leftBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            const hash = Hash.unserialize(buf);\n            nodes.push(new MerklePathNode(hash, left));\n        }\n        return new MerklePath(nodes);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._nodes.length);\n        buf.write(MerklePath._compress(this._nodes));\n\n        for (const node of this._nodes) {\n            node.hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        const leftBitsSize = Math.ceil(this._nodes.length / 8);\n        return /*count*/ 1\n            + leftBitsSize\n            + this._nodes.reduce((sum, node) => sum + node.hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {MerklePath} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePath\n            && this._nodes.length === o._nodes.length\n            && this._nodes.every((node, i) => node.equals(o._nodes[i]));\n    }\n\n    /** @type {Array.<MerklePathNode>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\nClass.register(MerklePath);\n\nclass MerklePathNode {\n    /**\n     * @param {Hash} hash\n     * @param {boolean} left\n     */\n    constructor(hash, left) {\n        this._hash = hash;\n        this._left = left;\n    }\n\n    /** @type {Hash} */\n    get hash() {\n        return this._hash;\n    }\n\n    /** @type {boolean} */\n    get left() {\n        return this._left;\n    }\n\n    /**\n     * @param {MerklePathNode} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePathNode\n            && this._hash.equals(o.hash)\n            && this._left === o.left;\n    }\n}\nClass.register(MerklePathNode);\n","class PlatformUtils {\n    /**\n     * @returns {boolean}\n     */\n    static isBrowser() {\n        return typeof window !== 'undefined';\n    }\n\n    /**\n     * @return {boolean}\n     */\n    static isNodeJs() {\n        return !PlatformUtils.isBrowser() && typeof process === 'object' && typeof require === 'function';\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static supportsWebRTC() {\n        let RTCPeerConnection = PlatformUtils.isBrowser() ? (window.RTCPeerConnection || window.webkitRTCPeerConnection) : null;\n        return !!RTCPeerConnection;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static isOnline() {\n        return (!PlatformUtils.isBrowser() || !('onLine' in window.navigator)) || window.navigator.onLine;\n    }\n}\nClass.register(PlatformUtils);\n","class StringUtils {\n    /**\n     * @param {string} str\n     * @returns {boolean}\n     */\n    static isMultibyte(str) {\n        return /[\\uD800-\\uDFFF]/.test(str);\n    }\n\n    /**\n     * @param {string} str\n     * @returns {boolean}\n     */\n    static isHex(str) {\n        return /^[0-9A-Fa-f]*$/.test(str);\n    }\n\n    /**\n     * @param {string} str\n     * @param {number} [length]\n     * @returns {boolean}\n     */\n    static isHexBytes(str, length) {\n        if (!StringUtils.isHex(str)) return false;\n        if (str.length % 2 !== 0) return false;\n        if (typeof length === 'number' && str.length / 2 !== length) return false;\n        return true;\n    }\n\n    /**\n     * @param {string} str1\n     * @param {string} str2\n     * @returns {string}\n     */\n    static commonPrefix(str1, str2) {\n        let i = 0;\n        for (; i < str1.length; ++i) {\n            if (str1[i] !== str2[i]) break;\n        }\n        return str1.substr(0, i);\n    }\n\n}\nClass.register(StringUtils);\n","class Policy {\n    /**\n     * Convert Nimiq decimal to Number of Satoshis.\n     * @param {number} coins Nimiq count in decimal\n     * @return {number} Number of Satoshis\n     */\n    static coinsToSatoshis(coins) {\n        return Math.round(coins * Policy.SATOSHIS_PER_COIN);\n    }\n\n    /**\n     * Convert Number of Satoshis to Nimiq decimal.\n     * @param {number} satoshis Number of Satoshis.\n     * @return {number} Nimiq count in decimal.\n     */\n    static satoshisToCoins(satoshis) {\n        return satoshis / Policy.SATOSHIS_PER_COIN;\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static supplyAfter(blockHeight) {\n        // Calculate last entry in supply cache that is below blockHeight.\n        let startHeight = Math.floor(blockHeight / Policy._supplyCacheInterval) * Policy._supplyCacheInterval;\n        startHeight = Math.max(0, Math.min(startHeight, Policy._supplyCacheMax));\n\n        // Calculate respective block for the last entry of the cache and the targeted height.\n        const startI = startHeight / Policy._supplyCacheInterval;\n        const endI = Math.floor(blockHeight / Policy._supplyCacheInterval);\n\n        // The starting supply is the initial supply at the beginning and a cached value afterwards.\n        let supply = startHeight === 0 ? Policy.INITIAL_SUPPLY : Policy._supplyCache.get(startHeight);\n        // Use and update cache.\n        for (let i = startI; i < endI; ++i) {\n            startHeight = i * Policy._supplyCacheInterval;\n            // Since the cache stores the supply *before* a certain block, subtract one.\n            const endHeight = (i + 1) * Policy._supplyCacheInterval - 1;\n            supply = Policy._supplyAfter(supply, endHeight, startHeight);\n            // Don't forget to add one again.\n            Policy._supplyCache.set(endHeight + 1, supply);\n            Policy._supplyCacheMax = endHeight + 1;\n        }\n\n        // Calculate remaining supply (this also adds the block reward for endI*interval).\n        return Policy._supplyAfter(supply, blockHeight, endI * Policy._supplyCacheInterval);\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} initialSupply\n     * @param {number} blockHeight\n     * @param {number} [startHeight]\n     * @return {number}\n     */\n    static _supplyAfter(initialSupply, blockHeight, startHeight=0) {\n        let supply = initialSupply;\n        for (let i = startHeight; i <= blockHeight; ++i) {\n            supply += Policy._blockRewardAt(supply, i);\n        }\n        return supply;\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static blockRewardAt(blockHeight) {\n        const currentSupply = Policy.supplyAfter(blockHeight - 1);\n        return Policy._blockRewardAt(currentSupply, blockHeight);\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} currentSupply\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static _blockRewardAt(currentSupply, blockHeight) {\n        if (blockHeight <= 0) return 0;\n        const remaining = Policy.TOTAL_SUPPLY - currentSupply;\n        if (blockHeight >= Policy.EMISSION_TAIL_START && remaining >= Policy.EMISSION_TAIL_REWARD) {\n            return Policy.EMISSION_TAIL_REWARD;\n        }\n        const remainder = remaining % Policy.EMISSION_SPEED;\n        return (remaining - remainder) / Policy.EMISSION_SPEED;\n    }\n}\n\n/**\n * Targeted block time in seconds.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TIME = 60;\n\n/**\n * Maximum block size in bytes.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_SIZE_MAX = 1e5; // 100 kb\n\n/**\n * The highest (easiest) block PoW target.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TARGET_MAX = Math.pow(2, 240);\n\n/**\n * Number of blocks we take into account to calculate next difficulty.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_BLOCK_WINDOW = 120;\n\n/**\n * Limits the rate at which the difficulty is adjusted min/max.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR = 2;\n\n/**\n * Number of blocks a transaction is valid.\n * @type {number}\n * @constant\n */\nPolicy.TRANSACTION_VALIDITY_WINDOW = 120;\n\n\n/* Supply & Emission Parameters */\n\n/**\n * Number of Satoshis per Nimiq.\n * @type {number}\n * @constant\n */\nPolicy.SATOSHIS_PER_COIN = 1e5;\n\n/**\n * Targeted total supply in satoshis.\n * @type {number}\n * @constant\n */\nPolicy.TOTAL_SUPPLY = 21e14;\n\n/**\n * Initial supply before genesis block in satoshis.\n * FIXME: Change for main net.\n * @type {number}\n * @constant\n */\nPolicy.INITIAL_SUPPLY = 252000000000000;\n\n/**\n * Emission speed.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_SPEED = Math.pow(2, 22);\n\n/**\n * First block using constant tail emission until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_START = 48692960;\n\n/**\n * Constant tail emission in satoshis until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_REWARD = 4000;\n\n/* Security parameters */\n\n/**\n * NIPoPoW Security parameter M\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.M = 240;\n\n/**\n * NIPoPoW Security parameter K\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.K = 120;\n\n/**\n * NIPoPoW Security parameter DELTA\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.DELTA = 0.1;\n\n/**\n * Number of blocks the light client downloads to verify the AccountsTree construction.\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.NUM_BLOCKS_VERIFICATION = 250;\n\n\n/* Snapshot Parameters */\n\n/**\n * Maximum number of snapshots.\n * @type {number}\n * @constant\n */\nPolicy.NUM_SNAPSHOTS_MAX = 20;\n\n\n/**\n * Stores the circulating supply before the given block.\n * @type {Map.<number, number>}\n * @private\n */\nPolicy._supplyCache = new Map();\nPolicy._supplyCacheMax = 0; // blocks\nPolicy._supplyCacheInterval = 5000; // blocks\nClass.register(Policy);\n","/**\n * @abstract\n */\nclass Serializable {\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Serializable && BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return BufferUtils.compare(this.serialize(), o.serialize());\n    }\n\n    hashCode() {\n        return this.toBase64();\n    }\n\n    /**\n     * @abstract\n     * @param {SerialBuffer} [buf]\n     */\n    serialize(buf) {}\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return this.toBase64();\n    }\n\n    /**\n     * @return {string}\n     */\n    toBase64() {\n        return BufferUtils.toBase64(this.serialize());\n    }\n\n    /**\n     * @return {string}\n     */\n    toHex() {\n        return BufferUtils.toHex(this.serialize());\n    }\n}\n\nClass.register(Serializable);\n","class Hash extends Serializable {\n    /**\n     * @param {?Uint8Array} arg\n     * @param {Hash.Algorithm} [algorithm]\n     * @private\n     */\n    constructor(arg, algorithm = Hash.Algorithm.BLAKE2B) {\n        if (arg === null) {\n            arg = new Uint8Array(Hash.getSize(algorithm));\n        } else {\n            if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n            if (arg.length !== Hash.getSize(algorithm)) throw new Error('Primitive: Invalid length');\n        }\n        super();\n        this._obj = arg;\n        /** @type {Hash.Algorithm} */\n        this._algorithm = algorithm;\n    }\n\n    /**\n     * @deprecated\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static light(arr) {\n        return Hash.blake2b(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static blake2b(arr) {\n        return new Hash(Hash.computeBlake2b(arr), Hash.Algorithm.BLAKE2B);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @deprecated\n     * @returns {Promise.<Hash>}\n     */\n    static hard(arr) {\n        return Hash.argon2d(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static async argon2d(arr) {\n        return new Hash(await (await CryptoWorker.getInstanceAsync()).computeArgon2d(arr), Hash.Algorithm.ARGON2D);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static sha256(arr) {\n        return new Hash(Hash.computeSha256(arr), Hash.Algorithm.SHA256);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @param {Hash.Algorithm} algorithm\n     * @returns {Hash}\n     */\n    static compute(arr, algorithm) {\n        // !! The algorithms supported by this function are the allowed hash algorithms for HTLCs !!\n        switch (algorithm) {\n            case Hash.Algorithm.BLAKE2B: return Hash.blake2b(arr);\n            case Hash.Algorithm.SHA256: return Hash.sha256(arr);\n            // Hash.Algorithm.ARGON2 intentionally omitted\n            default: throw new Error('Invalid hash algorithm');\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash.Algorithm} [algorithm]\n     * @returns {Hash}\n     */\n    static unserialize(buf, algorithm = Hash.Algorithm.BLAKE2B) {\n        return new Hash(buf.read(Hash.getSize(algorithm)), algorithm);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /**\n     * @param {number} begin\n     * @param {number} end\n     * @returns {Uint8Array}\n     */\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Hash.SIZE.get(this._algorithm);\n    }\n\n    /** @type {Uint8Array} */\n    get array() {\n        return this._obj;\n    }\n\n    /** @type {Hash.Algorithm} */\n    get algorithm() {\n        return this._algorithm;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Hash && o._algorithm === this._algorithm && super.equals(o);\n    }\n\n    /**\n     * @param {string} base64\n     * @returns {Hash}\n     */\n    static fromBase64(base64) {\n        return new Hash(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @returns {Hash}\n     */\n    static fromHex(hex) {\n        return new Hash(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @returns {Hash}\n     */\n    static fromString(str) {\n        try {\n            return Hash.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Hash.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid hash format');\n    }\n\n    /**\n     * @param {Hash} o\n     * @returns {boolean}\n     */\n    static isHash(o) {\n        return o instanceof Hash;\n    }\n\n    /**\n     * @param {Hash.Algorithm} algorithm\n     * @returns {number}\n     */\n    static getSize(algorithm) {\n        const size = Hash.SIZE.get(algorithm);\n        if (typeof size !== 'number') throw new Error('Invalid hash algorithm');\n        return size;\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeBlake2b(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.BLAKE2B));\n            NodeNative.node_blake2(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.BLAKE2B);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_blake2(wasmOut, wasmIn, input.length);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeSha256(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA256));\n            NodeNative.node_sha256(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA256);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                Module._nimiq_sha256(wasmOut, wasmIn, input.length);\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\n/**\n * @enum {number}\n */\nHash.Algorithm = {\n    BLAKE2B: 1,\n    ARGON2D: 2,\n    SHA256: 3,\n    SHA512: 4\n};\n/**\n * @type {Map<Hash.Algorithm, number>}\n */\nHash.SIZE = new Map();\nHash.SIZE.set(Hash.Algorithm.BLAKE2B, 32);\nHash.SIZE.set(Hash.Algorithm.ARGON2D, 32);\nHash.SIZE.set(Hash.Algorithm.SHA256, 32);\nHash.SIZE.set(Hash.Algorithm.SHA512, 64);\n\nHash.NULL = new Hash(new Uint8Array(32));\nClass.register(Hash);\n","class PrivateKey extends Serializable {\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PrivateKey.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @return {PrivateKey}\n     */\n    static generate() {\n        const privateKey = new Uint8Array(PrivateKey.SIZE);\n        CryptoWorker.lib.getRandomValues(privateKey);\n        return new PrivateKey(privateKey);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PrivateKey}\n     */\n    static unserialize(buf) {\n        return new PrivateKey(buf.read(PrivateKey.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PrivateKey.SIZE;\n    }\n\n    /**\n     * Overwrite this private key with a replacement in-memory\n     * @param {PrivateKey} privateKey\n     */\n    overwrite(privateKey) {\n        this._obj.set(privateKey._obj);\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PrivateKey && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _privateKeyDelinearize(privateKey, publicKey, publicKeysHash) {\n        if (privateKey.byteLength !== PrivateKey.SIZE\n            || publicKey.byteLength !== PublicKey.SIZE\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_derive_delinearized_private_key(out, new Uint8Array(publicKeysHash), new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPrivateKey = Module.stackAlloc(privateKey.length);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_derive_delinearized_private_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey, wasmInPrivateKey);\n                const delinearizedPrivateKey = new Uint8Array(PrivateKey.SIZE);\n                delinearizedPrivateKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PrivateKey.SIZE));\n                return delinearizedPrivateKey;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPrivateKey.SIZE = 32;\n\nClass.register(PrivateKey);\n","class PublicKey extends Serializable {\n    /**\n     * @param {PublicKey} o\n     * @returns {PublicKey}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new PublicKey(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PublicKey.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {PublicKey}\n     */\n    static derive(privateKey) {\n        return new PublicKey(PublicKey._publicKeyDerive(privateKey._obj));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @return {PublicKey}\n     */\n    static sum(publicKeys) {\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n        return PublicKey._delinearizeAndAggregatePublicKeys(publicKeys);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PublicKey}\n     */\n    static unserialize(buf) {\n        return new PublicKey(buf.read(PublicKey.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PublicKey.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PublicKey && super.equals(o);\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        return Hash.light(this.serialize());\n    }\n\n    /**\n     * @param {PublicKey} o\n     * @return {number}\n     */\n    compare(o) {\n        return BufferUtils.compare(this._obj, o._obj);\n    }\n\n    /**\n     * @return {Address}\n     */\n    toAddress() {\n        return Address.fromHash(this.hash());\n    }\n\n    /**\n     * @return {PeerId}\n     */\n    toPeerId() {\n        return new PeerId(this.hash().subarray(0, 16));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @returns {PublicKey}\n     */\n    static _delinearizeAndAggregatePublicKeys(publicKeys) {\n        const publicKeysObj = publicKeys.map(k => k.serialize());\n        const publicKeysHash = PublicKey._publicKeysHash(publicKeysObj);\n        const raw = PublicKey._publicKeysDelinearizeAndAggregate(publicKeysObj, publicKeysHash);\n        return new PublicKey(raw);\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    static _publicKeyDerive(privateKey) {\n        if (privateKey.byteLength !== PrivateKey.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_public_key_derive(out, new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const pubKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOut, PrivateKey.SIZE);\n                pubKeyBuffer.set(privateKey);\n                const wasmIn = Module.stackAlloc(privateKey.length);\n                const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmIn, PrivateKey.SIZE);\n                privKeyBuffer.set(privateKey);\n\n                Module._ed25519_public_key_derive(wasmOut, wasmIn);\n                privKeyBuffer.fill(0);\n                const publicKey = new Uint8Array(PublicKey.SIZE);\n                publicKey.set(pubKeyBuffer);\n                return publicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    static _publicKeysHash(publicKeys) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA512));\n            NodeNative.node_ed25519_hash_public_keys(out, concatenatedPublicKeys, publicKeys.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA512);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                Module._ed25519_hash_public_keys(wasmOut, wasmInPublicKeys, publicKeys.length);\n                const hashedPublicKey = new Uint8Array(hashSize);\n                hashedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hashedPublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _publicKeyDelinearize(publicKey, publicKeysHash) {\n        if (publicKey.byteLength !== PublicKey.SIZE\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_delinearize_public_key(out, new Uint8Array(publicKeysHash), new Uint8Array(publicKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_delinearize_public_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey);\n                const delinearizedPublicKey = new Uint8Array(PublicKey.SIZE);\n                delinearizedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return delinearizedPublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_aggregate_delinearized_public_keys(out, new Uint8Array(publicKeysHash), concatenatedPublicKeys, publicKeys.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_aggregate_delinearized_public_keys(wasmOut, wasmInPublicKeysHash, wasmInPublicKeys, publicKeys.length);\n                const aggregatePublicKey = new Uint8Array(PublicKey.SIZE);\n                aggregatePublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return aggregatePublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPublicKey.SIZE = 32;\n\nClass.register(PublicKey);\n","class KeyPair extends Serializable {\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {boolean} locked\n     * @param {Uint8Array} lockSalt\n     * @private\n     */\n    constructor(privateKey, publicKey, locked = false, lockSalt = null) {\n        if (!(privateKey instanceof Object)) throw new Error('Primitive: Invalid type');\n        if (!(publicKey instanceof Object)) throw new Error('Primitive: Invalid type');\n        super();\n\n        /** @type {boolean} */\n        this._locked = locked;\n        /** @type {boolean} */\n        this._lockedInternally = locked;\n        /** @type {Uint8Array} */\n        this._lockSalt = lockSalt;\n        /** @type {PublicKey} */\n        this._publicKey = publicKey;\n        /** @type {PrivateKey} */\n        this._internalPrivateKey = new PrivateKey(privateKey.serialize());\n    }\n\n    /**\n     * @return {KeyPair}\n     */\n    static generate() {\n        const privateKey = PrivateKey.generate();\n        return new KeyPair(privateKey, PublicKey.derive(privateKey));\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {KeyPair}\n     */\n    static derive(privateKey) {\n        return new KeyPair(privateKey, PublicKey.derive(privateKey));\n    }\n\n    /**\n     * @param {string} hexBuf\n     * @return {KeyPair}\n     */\n    static fromHex(hexBuf) {\n        return KeyPair.unserialize(BufferUtils.fromHex(hexBuf));\n    }\n\n    /**\n     *\n     * @param {SerialBuffer} buf\n     * @param {Uint8Array} key\n     * @return {Promise<KeyPair>}\n     */\n    static async fromEncrypted(buf, key) {\n        const type = buf.readUint8();\n        if (type !== 1) throw new Error('Unsupported type');\n        const roundsLog = buf.readUint8();\n        if (roundsLog > 32) throw new Error('Rounds out-of-bounds');\n        const rounds = Math.pow(2, roundsLog);\n        const encryptedKey = PrivateKey.unserialize(buf);\n        const salt = buf.read(KeyPair.EXPORT_SALT_LENGTH);\n        const check = buf.read(KeyPair.EXPORT_CHECKSUM_LENGTH);\n\n        const privateKey = new PrivateKey(await KeyPair._otpKdf(encryptedKey.serialize(), key, salt, rounds));\n        const keyPair = KeyPair.derive(privateKey);\n        const pubHash = keyPair.publicKey.hash();\n        if (!BufferUtils.equals(pubHash.subarray(0, 4), check)) {\n            throw new Error('Invalid key');\n        }\n        return keyPair;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {KeyPair}\n     */\n    static unserialize(buf) {\n        const privateKey = PrivateKey.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        let locked = false;\n        let lockSalt = null;\n        if (buf.readPos < buf.byteLength) {\n            const extra = buf.readUint8();\n            if (extra === 1) {\n                locked = true;\n                lockSalt = buf.read(32);\n            }\n        }\n        return new KeyPair(privateKey, publicKey, locked, lockSalt);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._privateKey.serialize(buf);\n        this.publicKey.serialize(buf);\n        if (this._locked) {\n            buf.writeUint8(1);\n            buf.write(this._lockSalt);\n        } else {\n            buf.writeUint8(0);\n        }\n        return buf;\n    }\n\n    /**\n     * The unlocked private key.\n     * @type {PrivateKey}\n     */\n    get privateKey() {\n        if (this.isLocked) throw new Error('Wallet is locked');\n        return this._privateKey;\n    }\n\n    /**\n     * The private key in its current state, i.e., depending on this._locked.\n     * If this._locked, it is the internally locked private key.\n     * If !this._locked, it is either the internally unlocked private key (if !this._lockedInternally)\n     * or this._unlockedPrivateKey.\n     * @type {PrivateKey}\n     */\n    get _privateKey() {\n        return this._unlockedPrivateKey || this._internalPrivateKey;\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey || (this._publicKey = new PublicKey(this._obj.publicKey));\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._privateKey.serializedSize + this.publicKey.serializedSize + (this._locked ? this._lockSalt.byteLength + 1 : 1);\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} [unlockKey]\n     * @return {Promise.<Uint8Array>}\n     */\n    async exportEncrypted(key, unlockKey) {\n        const wasLocked = this._locked;\n        if (this._locked) {\n            try {\n                await this.unlock(unlockKey || key);\n            } catch (e) {\n                throw new Error('KeyPair is locked and lock key mismatches');\n            }\n        }\n\n        const salt = new Uint8Array(KeyPair.EXPORT_SALT_LENGTH);\n        CryptoWorker.lib.getRandomValues(salt);\n\n        const buf = new SerialBuffer(this.encryptedSize);\n        buf.writeUint8(1); // Argon2 KDF\n        buf.writeUint8(Math.log2(KeyPair.EXPORT_KDF_ROUNDS));\n        buf.write(await KeyPair._otpKdf(this.privateKey.serialize(), key, salt, KeyPair.EXPORT_KDF_ROUNDS));\n        buf.write(salt);\n        buf.write(this.publicKey.hash().subarray(0, KeyPair.EXPORT_CHECKSUM_LENGTH));\n\n        if (wasLocked) this.relock();\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get encryptedSize() {\n        return 2 + this.privateKey.serializedSize + KeyPair.EXPORT_SALT_LENGTH + KeyPair.EXPORT_CHECKSUM_LENGTH;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} [lockSalt]\n     */\n    async lock(key, lockSalt) {\n        if (this._locked) throw new Error('KeyPair already locked');\n\n        if (lockSalt) this._lockSalt = lockSalt;\n        if (!this._lockSalt || this._lockSalt.length === 0) {\n            this._lockSalt = new Uint8Array(32);\n            CryptoWorker.lib.getRandomValues(this._lockSalt);\n        }\n\n        this._internalPrivateKey.overwrite(await this._otpPrivateKey(key));\n        this._clearUnlockedPrivateKey();\n        this._locked = true;\n        this._lockedInternally = true;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     */\n    async unlock(key) {\n        if (!this._locked) throw new Error('KeyPair not locked');\n\n        const privateKey = await this._otpPrivateKey(key);\n        const verifyPub = PublicKey.derive(privateKey);\n        if (verifyPub.equals(this.publicKey)) {\n            // Only set this._internalPrivateKey, but keep this._obj locked.\n            this._unlockedPrivateKey = privateKey;\n            this._locked = false;\n        } else {\n            throw new Error('Invalid key');\n        }\n    }\n\n    /**\n     * Destroy cached unlocked private key if the internal key is in locked state.\n     */\n    relock() {\n        if (this._locked) throw new Error('KeyPair already locked');\n        if (!this._lockedInternally) throw new Error('KeyPair was never locked');\n        this._clearUnlockedPrivateKey();\n        this._locked = true;\n    }\n\n    _clearUnlockedPrivateKey() {\n        // If this wallet is not locked internally and unlocked, this method does not have any effect.\n        if (!this._lockedInternally || this._locked) return;\n\n        // Overwrite cached key in this._unlockedPrivateKey with 0s.\n        this._unlockedPrivateKey.overwrite(PrivateKey.unserialize(new SerialBuffer(this._unlockedPrivateKey.serializedSize)));\n        // Then, reset it.\n        this._unlockedPrivateKey = null;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @return {Promise<PrivateKey>}\n     * @private\n     */\n    async _otpPrivateKey(key) {\n        return new PrivateKey(await KeyPair._otpKdf(this._privateKey.serialize(), key, this._lockSalt, KeyPair.LOCK_KDF_ROUNDS));\n    }\n\n    /**\n     * @param {Uint8Array} message\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @return {Promise<Uint8Array>}\n     * @private\n     */\n    static async _otpKdf(message, key, salt, iterations) {\n        return BufferUtils.xor(message, await (await CryptoWorker.getInstanceAsync()).kdf(key, salt, iterations));\n    }\n\n    get isLocked() {\n        return this._locked;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof KeyPair && super.equals(o);\n    }\n}\nKeyPair.LOCK_KDF_ROUNDS = 256;\nKeyPair.EXPORT_KDF_ROUNDS = 256;\nKeyPair.EXPORT_CHECKSUM_LENGTH = 4;\nKeyPair.EXPORT_SALT_LENGTH = 16;\n\nClass.register(KeyPair);\n","class RandomSecret extends Serializable {\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== RandomSecret.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {RandomSecret}\n     */\n    static unserialize(buf) {\n        return new RandomSecret(buf.read(RandomSecret.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return RandomSecret.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof RandomSecret && super.equals(o);\n    }\n}\n\nRandomSecret.SIZE = 32;\n\nClass.register(RandomSecret);\n","class Signature extends Serializable {\n    /**\n     * @param {Signature} o\n     * @returns {Signature}\n     */\n    static copy(o) {\n        if (!o) return o;\n        // FIXME Move this to Crypto class.\n        const obj = new Uint8Array(o._obj);\n        return new Signature(obj);\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Signature.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {Signature}\n     */\n    static create(privateKey, publicKey, data) {\n        return new Signature(Signature._signatureCreate(privateKey._obj, publicKey._obj, data));\n    }\n\n    /**\n     * @param {Commitment} commitment\n     * @param {Array.<PartialSignature>} signatures\n     * @return {Signature}\n     */\n    static fromPartialSignatures(commitment, signatures) {\n        const raw = Signature._combinePartialSignatures(commitment.serialize(), signatures.map(s => s.serialize()));\n        return new Signature(raw);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Signature}\n     */\n    static unserialize(buf) {\n        return new Signature(buf.read(Signature.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Signature.SIZE;\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {boolean}\n     */\n    verify(publicKey, data) {\n        return Signature._signatureVerify(publicKey._obj, data, this._obj);\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Signature && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} combinedCommitment\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static _combinePartialSignatures(combinedCommitment, partialSignatures) {\n        const combinedSignature = Signature._aggregatePartialSignatures(partialSignatures);\n        return BufferUtils.concatTypedArrays(combinedCommitment, combinedSignature);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static _aggregatePartialSignatures(partialSignatures) {\n        return partialSignatures.reduce((sigA, sigB) => Signature._scalarsAdd(sigA, sigB));\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @returns {Uint8Array}\n     */\n    static _scalarsAdd(a, b) {\n        if (a.byteLength !== PartialSignature.SIZE || b.byteLength !== PartialSignature.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PartialSignature.SIZE);\n            NodeNative.node_ed25519_add_scalars(out, new Uint8Array(a), new Uint8Array(b));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutSum = Module.stackAlloc(PartialSignature.SIZE);\n                const wasmInA = Module.stackAlloc(a.length);\n                const wasmInB = Module.stackAlloc(b.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInA, a.length).set(a);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInB, b.length).set(b);\n                Module._ed25519_add_scalars(wasmOutSum, wasmInA, wasmInB);\n                const sum = new Uint8Array(PartialSignature.SIZE);\n                sum.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSum, PartialSignature.SIZE));\n                return sum;\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    static _signatureCreate(privateKey, publicKey, message) {\n        if (publicKey.byteLength !== PublicKey.SIZE\n            || privateKey.byteLength !== PrivateKey.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Signature.SIZE);\n            NodeNative.node_ed25519_sign(out, new Uint8Array(message), new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutSignature = Module.stackAlloc(Signature.SIZE);\n                const signatureBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOutSignature, Signature.SIZE);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);\n                const wasmInPubKey = Module.stackAlloc(publicKey.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);\n                const wasmInPrivKey = Module.stackAlloc(privateKey.length);\n                const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmInPrivKey, privateKey.length);\n                privKeyBuffer.set(privateKey);\n\n                Module._ed25519_sign(wasmOutSignature, wasmInMessage, message.byteLength, wasmInPubKey, wasmInPrivKey);\n                privKeyBuffer.fill(0);\n\n                const signature = new Uint8Array(Signature.SIZE);\n                signature.set(signatureBuffer);\n                return signature;\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    static _signatureVerify(publicKey, message, signature) {\n        if (PlatformUtils.isNodeJs()) {\n            return !!NodeNative.node_ed25519_verify(new Uint8Array(signature), new Uint8Array(message), new Uint8Array(publicKey));\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmInPubKey = Module.stackAlloc(publicKey.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);\n                const wasmInSignature = Module.stackAlloc(signature.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInSignature, signature.length).set(signature);\n\n                return !!Module._ed25519_verify(wasmInSignature, wasmInMessage, message.byteLength, wasmInPubKey);\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nSignature.SIZE = 64;\n\nClass.register(Signature);\n","class Commitment extends Serializable {\n    /**\n     * @param {Commitment} o\n     * @returns {Commitment}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new Commitment(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param {Array.<Commitment>} commitments\n     * @return {Commitment}\n     */\n    static sum(commitments) {\n        return new Commitment(Commitment._commitmentsAggregate(commitments.map(c => c._obj)));\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Commitment.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Commitment}\n     */\n    static unserialize(buf) {\n        return new Commitment(buf.read(Commitment.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Commitment.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Commitment && super.equals(o);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} commitments\n     * @returns {Uint8Array}\n     */\n    static _commitmentsAggregate(commitments) {\n        if (commitments.some(commitment => commitment.byteLength !== PublicKey.SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedCommitments = new Uint8Array(commitments.length * PublicKey.SIZE);\n        for (let i = 0; i < commitments.length; ++i) {\n            concatenatedCommitments.set(commitments[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_aggregate_commitments(out, concatenatedCommitments, commitments.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInCommitments = Module.stackAlloc(concatenatedCommitments.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInCommitments, concatenatedCommitments.length).set(concatenatedCommitments);\n                Module._ed25519_aggregate_commitments(wasmOut, wasmInCommitments, commitments.length);\n                const aggCommitments = new Uint8Array(PublicKey.SIZE);\n                aggCommitments.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return aggCommitments;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nCommitment.SIZE = 32;\n\nClass.register(Commitment);\n","class CommitmentPair extends Serializable {\n    /**\n     * @param {RandomSecret} arg\n     * @param {Commitment} arg\n     * @private\n     */\n    constructor(secret, commitment) {\n        super();\n        if (!(secret instanceof RandomSecret)) throw new Error('Primitive: Invalid type');\n        if (!(commitment instanceof Commitment)) throw new Error('Primitive: Invalid type');\n        this._secret = secret;\n        this._commitment = commitment;\n    }\n\n    /**\n     * @return {CommitmentPair}\n     */\n    static generate() {\n        const randomness = new Uint8Array(CommitmentPair.RANDOMNESS_SIZE);\n        CryptoWorker.lib.getRandomValues(randomness);\n        const raw = CommitmentPair._commitmentCreate(randomness);\n        return new CommitmentPair(new RandomSecret(raw.secret), new Commitment(raw.commitment));\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {CommitmentPair}\n     */\n    static unserialize(buf) {\n        const secret = RandomSecret.unserialize(buf);\n        const commitment = Commitment.unserialize(buf);\n        return new CommitmentPair(secret, commitment);\n    }\n\n    /**\n     * @param {string} hexBuf\n     * @return {CommitmentPair}\n     */\n    static fromHex(hexBuf) {\n        return this.unserialize(BufferUtils.fromHex(hexBuf));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this.secret.serialize(buf);\n        this.commitment.serialize(buf);\n        return buf;\n    }\n\n    /** @type {RandomSecret} */\n    get secret() {\n        return this._secret;\n    }\n\n    /** @type {Commitment} */\n    get commitment() {\n        return this._commitment;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this.secret.serializedSize + this.commitment.serializedSize;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof CommitmentPair && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} randomness\n     * @returns {{commitment:Uint8Array, secret:Uint8Array}}\n     */\n    static _commitmentCreate(randomness) {\n        if (PlatformUtils.isNodeJs()) {\n            const commitment = new Uint8Array(PublicKey.SIZE);\n            const secret = new Uint8Array(PrivateKey.SIZE);\n            NodeNative.node_ed25519_create_commitment(secret, commitment, randomness);\n            return {commitment, secret};\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutCommitment = Module.stackAlloc(PublicKey.SIZE);\n                const wasmOutSecret = Module.stackAlloc(PrivateKey.SIZE);\n                const wasmIn = Module.stackAlloc(randomness.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, randomness.length).set(randomness);\n                const res = Module._ed25519_create_commitment(wasmOutSecret, wasmOutCommitment, wasmIn);\n                if (res !== 1) {\n                    throw new Error(`Secret must not be 0 or 1: ${res}`);\n                }\n                const commitment = new Uint8Array(PublicKey.SIZE);\n                const secret = new Uint8Array(PrivateKey.SIZE);\n                commitment.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutCommitment, PublicKey.SIZE));\n                secret.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSecret, PrivateKey.SIZE));\n                return {commitment, secret};\n            } catch (e) {\n                Log.w(CommitmentPair, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nCommitmentPair.SERIALIZED_SIZE = RandomSecret.SIZE + Signature.SIZE;\nCommitmentPair.RANDOMNESS_SIZE = 32;\n\nClass.register(CommitmentPair);\n","class PartialSignature extends Serializable {\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PartialSignature.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {RandomSecret} secret\n     * @param {Commitment} aggregateCommitment\n     * @param {Uint8Array} data\n     * @return {PartialSignature}\n     */\n    static create(privateKey, publicKey, publicKeys, secret, aggregateCommitment, data) {\n        const raw = PartialSignature._delinearizedPartialSignatureCreate(publicKeys.map(o => o._obj), privateKey._obj,\n            publicKey._obj, secret._obj, aggregateCommitment._obj, data);\n        return new PartialSignature(raw);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PartialSignature}\n     */\n    static unserialize(buf) {\n        return new PartialSignature(buf.read(PartialSignature.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PartialSignature.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PartialSignature && super.equals(o);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} secret\n     * @param {Uint8Array} aggregateCommitment\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    static _delinearizedPartialSignatureCreate(publicKeys, privateKey, publicKey, secret, aggregateCommitment, message) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)\n            || privateKey.byteLength !== PrivateKey.SIZE\n            || publicKey.byteLength !== PublicKey.SIZE\n            || secret.byteLength !== RandomSecret.SIZE\n            || aggregateCommitment.byteLength !== Commitment.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PartialSignature.SIZE);\n            NodeNative.node_ed25519_delinearized_partial_sign(out, new Uint8Array(message), new Uint8Array(aggregateCommitment), new Uint8Array(secret), new Uint8Array(concatenatedPublicKeys), publicKeys.length, new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PartialSignature.SIZE);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                const wasmInPrivateKey = Module.stackAlloc(privateKey.length);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInSecret = Module.stackAlloc(secret.length);\n                const wasmInCommitment = Module.stackAlloc(aggregateCommitment.length);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInSecret, secret.length).set(secret);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInCommitment, aggregateCommitment.length).set(aggregateCommitment);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInMessage, message.length).set(message);\n                Module._ed25519_delinearized_partial_sign(wasmOut, wasmInMessage, message.length, wasmInCommitment, wasmInSecret, wasmInPublicKeys, publicKeys.length, wasmInPublicKey, wasmInPrivateKey);\n                const partialSignature = new Uint8Array(PartialSignature.SIZE);\n                partialSignature.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PartialSignature.SIZE));\n                return partialSignature;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPartialSignature.SIZE = 32;\nClass.register(PartialSignature);\n","class Address extends Serializable {\n    /**\n     * @param {Address} o\n     * @returns {Address}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new Address(obj);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Address}\n     */\n    static fromHash(hash) {\n        return new Address(hash.subarray(0, Address.SERIALIZED_SIZE));\n    }\n\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Address.SERIALIZED_SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * Create Address object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Address} Newly created Account object.\n     */\n    static unserialize(buf) {\n        return new Address(buf.read(Address.SERIALIZED_SIZE));\n    }\n\n    /**\n     * Serialize this Address object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return Address.SERIALIZED_SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Address\n            && super.equals(o);\n    }\n\n    static fromString(str) {\n        try {\n            return Address.fromUserFriendlyAddress(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid address format');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {Address}\n     */\n    static fromBase64(base64) {\n        return new Address(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @return {Address}\n     */\n    static fromHex(hex) {\n        return new Address(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @return {Address}\n     */\n    static fromUserFriendlyAddress(str) {\n        str = str.replace(/ /g, '');\n        if (str.substr(0, 2).toUpperCase() !== Address.CCODE) {\n            throw new Error('Invalid Address: Wrong country code');\n        }\n        if (str.length !== 36) {\n            throw new Error('Invalid Address: Should be 36 chars (ignoring spaces)');\n        }\n        if (Address._ibanCheck(str.substr(4) + str.substr(0, 4)) !== 1) {\n            throw new Error('Invalid Address: Checksum invalid');\n        }\n        return new Address(BufferUtils.fromBase32(str.substr(4)));\n    }\n\n    static _ibanCheck(str) {\n        const num = str.split('').map((c) => {\n            const code = c.toUpperCase().charCodeAt(0);\n            return code >= 48 && code <= 57 ? c : (code - 55).toString();\n        }).join('');\n        let tmp = '';\n\n        for (let i = 0; i < Math.ceil(num.length / 6); i++) {\n            tmp = (parseInt(tmp + num.substr(i * 6, 6)) % 97).toString();\n        }\n\n        return parseInt(tmp);\n    }\n\n    /**\n     * @param {boolean} [withSpaces]\n     * @return {string}\n     */\n    toUserFriendlyAddress(withSpaces = true) {\n        const base32 = BufferUtils.toBase32(this.serialize());\n        // eslint-disable-next-line prefer-template\n        const check = ('00' + (98 - Address._ibanCheck(base32 + Address.CCODE + '00'))).slice(-2);\n        let res = Address.CCODE + check + base32;\n        if (withSpaces) res = res.replace(/.{4}/g, '$& ').trim();\n        return res;\n    }\n}\nAddress.CCODE = 'NQ';\nAddress.SERIALIZED_SIZE = 20;\nAddress.HEX_SIZE = 40;\nAddress.NULL = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nAddress.CONTRACT_CREATION = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nClass.register(Address);\n","/**\n * @abstract\n */\nclass Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        if (!NumberUtils.isUint8(type)) throw new Error('Malformed type');\n        if (!NumberUtils.isUint64(balance)) throw new Error('Malformed balance');\n\n        /** @type {Account.Type} */\n        this._type = type;\n        /** @type {number} */\n        this._balance = balance;\n    }\n\n    /**\n     * Create Account object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Account} Newly created Account object.\n     */\n    static unserialize(buf) {\n        const type = /** @type {Account.Type} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Account.TYPE_MAP.has(type)) {\n            throw new Error('Unknown account type');\n        }\n\n        return Account.TYPE_MAP.get(type).unserialize(buf);\n    }\n\n    /**\n     * Serialize this Account object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        buf.writeUint64(this._balance);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return /*type*/ 1\n            + /*balance*/ 8;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    toString() {\n        return `Account{type=${this._type}, balance=${this._balance.toString()}`;\n    }\n\n    /**\n     * @type {number} Account balance\n     */\n    get balance() {\n        return this._balance;\n    }\n\n    /** @type {Account.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) { throw new Error('Not yet implemented.'); }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            if (transactionsCache.containsTransaction(transaction)) {\n                throw new Error('Double Transaction Error!');\n            }\n            return this.withBalance(newBalance);\n        } else {\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            return this.withBalance(this._balance + transaction.value + transaction.fee);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            return this.withBalance(this._balance + transaction.value);\n        } else {\n            const newBalance = this._balance - transaction.value;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            return this.withBalance(newBalance);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this === Account.INITIAL;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isToBePruned() {\n        return this._balance === 0 && !this.isInitial();\n    }\n}\n\n/**\n * Enum for Account types.\n * Non-zero values are contracts.\n * @enum\n */\nAccount.Type = {\n    /**\n     * Basic account type.\n     * @see {BasicAccount}\n     */\n    BASIC: 0,\n    /**\n     * Account with vesting functionality.\n     * @see {VestingContract}\n     */\n    VESTING: 1,\n    /**\n     * Hashed Time-Locked Contract\n     * @see {HashedTimeLockedContract}\n     */\n    HTLC: 2\n};\n/**\n * @type {Map.<Account.Type, {copy: function(o: *):Account, unserialize: function(buf: SerialBuffer):Account, create: function(balance: number, blockHeight: number, transaction: Transaction):Account, verifyOutgoingTransaction: function(transaction: Transaction):Promise.<boolean>, verifyIncomingTransaction: function(transaction: Transaction):Promise.<boolean>}>}\n */\nAccount.TYPE_MAP = new Map();\n\nClass.register(Account);\n","/**\n * @abstract\n */\nclass Transaction {\n    /**\n     * @param {Transaction.Format} format\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     * @param {number} [networkId]\n     */\n    constructor(format, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId = GenesisConfig.NETWORK_ID) {\n        if (!(sender instanceof Address)) throw new Error('Malformed sender');\n        if (!NumberUtils.isUint8(senderType)) throw new Error('Malformed sender type');\n        if (!(recipient instanceof Address)) throw new Error('Malformed recipient');\n        if (!NumberUtils.isUint8(recipientType)) throw new Error('Malformed recipient type');\n        if (!NumberUtils.isUint64(value) || value === 0) throw new Error('Malformed value');\n        if (!NumberUtils.isUint64(fee)) throw new Error('Malformed fee');\n        if (!NumberUtils.isUint32(validityStartHeight)) throw new Error('Malformed validityStartHeight');\n        if (!NumberUtils.isUint8(flags) && (flags & ~(Transaction.Flag.ALL)) > 0) throw new Error('Malformed flags');\n        if (!(data instanceof Uint8Array) || !(NumberUtils.isUint16(data.byteLength))) throw new Error('Malformed data');\n        if (proof && (!(proof instanceof Uint8Array) || !(NumberUtils.isUint16(proof.byteLength)))) throw new Error('Malformed proof');\n        if (!NumberUtils.isUint8(networkId)) throw new Error('Malformed networkId');\n\n        /** @type {Transaction.Format} */\n        this._format = format;\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Account.Type} */\n        this._senderType = senderType;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Account.Type} */\n        this._recipientType = recipientType;\n        /** @type {number} */\n        this._value = value;\n        /** @type {number} */\n        this._fee = fee;\n        /** @type {number} */\n        this._networkId = networkId;\n        /** @type {number} */\n        this._validityStartHeight = validityStartHeight;\n        /** @type {Transaction.Flag | *} */\n        this._flags = flags;\n        /** @type {Uint8Array} */\n        this._data = data;\n        /** @type {Uint8Array} */\n        this._proof = proof;\n\n        if (this._recipient === Address.CONTRACT_CREATION) this._recipient = this.getContractCreationAddress();\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const format = /** @type {Transaction.Format} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Transaction.FORMAT_MAP.has(format)) throw new Error('Invalid transaction type');\n        return Transaction.FORMAT_MAP.get(format).unserialize(buf);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n        buf.writeUint16(this._data.byteLength);\n        buf.write(this._data);\n        this._sender.serialize(buf);\n        buf.writeUint8(this._senderType);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._recipientType);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._networkId);\n        buf.writeUint8(this._flags);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return /*dataSize*/ 2\n            + this._data.byteLength\n            + this._sender.serializedSize\n            + /*senderType*/ 1\n            + this._recipient.serializedSize\n            + /*recipientType*/ 1\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*networkId*/ 1\n            + /*flags*/ 1;\n    }\n\n    /**\n     * @param {number} [networkId]\n     * @returns {boolean}\n     */\n    verify(networkId) {\n        if (this._valid === undefined) {\n            this._valid = this._verify(networkId);\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} [networkId]\n     * @returns {boolean}\n     * @private\n     */\n    _verify(networkId = GenesisConfig.NETWORK_ID) {\n        if (this._networkId !== networkId) {\n            Log.w(Transaction, 'Transaction is not valid in this network', this);\n            return false;\n        }\n        // Check that sender != recipient.\n        if (this._recipient.equals(this._sender)) {\n            Log.w(Transaction, 'Sender and recipient must not match', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.has(this._senderType) || !Account.TYPE_MAP.has(this._recipientType)) {\n            Log.w(Transaction, 'Invalid account type', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for sender', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for recipient', this);\n            return false;\n        }\n        return true;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        throw new Error('Getter needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        throw new Error('Method needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        // Exclude the signature, we don't want transactions to be malleable.\n        this._hash = this._hash || Hash.light(this.serializeContent());\n        return this._hash;\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compare(o) {\n        if (this.fee / this.serializedSize > o.fee / o.serializedSize) return -1;\n        if (this.fee / this.serializedSize < o.fee / o.serializedSize) return 1;\n        if (this.serializedSize > o.serializedSize) return -1;\n        if (this.serializedSize < o.serializedSize) return 1;\n        if (this.fee > o.fee) return -1;\n        if (this.fee < o.fee) return 1;\n        if (this.value > o.value) return -1;\n        if (this.value < o.value) return 1;\n        return this.compareBlockOrder(o);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compareBlockOrder(o) {\n        // This function must return 0 iff this.equals(o).\n        const recCompare = this._recipient.compare(o._recipient);\n        if (recCompare !== 0) return recCompare;\n        if (this._validityStartHeight < o._validityStartHeight) return -1;\n        if (this._validityStartHeight > o._validityStartHeight) return 1;\n        if (this._fee > o._fee) return -1;\n        if (this._fee < o._fee) return 1;\n        if (this._value > o._value) return -1;\n        if (this._value < o._value) return 1;\n        const senderCompare = this._sender.compare(o._sender);\n        if (senderCompare !== 0) return senderCompare;\n        if (this._recipientType < o._recipientType) return -1;\n        if (this._recipientType > o._recipientType) return 1;\n        if (this._senderType < o._senderType) return -1;\n        if (this._senderType > o._senderType) return 1;\n        if (this._flags < o._flags) return -1;\n        if (this._flags > o._flags) return 1;\n        return BufferUtils.compare(this._data, o._data);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {boolean}\n     */\n    equals(o) {\n        // This ignores format and proof to be consistent with hash():\n        //   tx1.hash() == tx2.hash() iff tx1.equals(t2)\n        return o instanceof Transaction\n            && this._sender.equals(o._sender)\n            && this._senderType === o._senderType\n            && this._recipient.equals(o._recipient)\n            && this._recipientType === o._recipientType\n            && this._value === o._value\n            && this._fee === o._fee\n            && this._validityStartHeight === o._validityStartHeight\n            && this._networkId === o._networkId\n            && this._flags === o._flags\n            && BufferUtils.equals(this._data, o._data);\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `Transaction{`\n            + `sender=${this._sender.toBase64()}, `\n            + `recipient=${this._recipient.toBase64()}, `\n            + `value=${this._value}, `\n            + `fee=${this._fee}, `\n            + `validityStartHeight=${this._validityStartHeight}, `\n            + `networkId=${this._networkId}`\n            + `}`;\n    }\n\n    /**\n     * @return {Address}\n     */\n    getContractCreationAddress() {\n        const tx = Transaction.unserialize(this.serialize());\n        tx._recipient = Address.NULL;\n        tx._hash = null;\n        return Address.fromHash(tx.hash());\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Account.Type} */\n    get senderType() {\n        return this._senderType;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Account.Type} */\n    get recipientType() {\n        return this._recipientType;\n    }\n\n    /** @type {number} */\n    get value() {\n        return this._value;\n    }\n\n    /** @type {number} */\n    get fee() {\n        return this._fee;\n    }\n\n    /** @type {number} */\n    get feePerByte() {\n        return this._fee / this.serializedSize;\n    }\n\n    /** @type {number} */\n    get networkId() {\n        return this._networkId;\n    }\n\n    /** @type {number} */\n    get validityStartHeight() {\n        return this._validityStartHeight;\n    }\n\n    /** @type {number} */\n    get flags() {\n        return this._flags;\n    }\n\n    /**\n     * @param {Transaction.Flag} flag\n     * @returns {boolean}\n     */\n    hasFlag(flag) {\n        return (this._flags & flag) > 0;\n    }\n\n    /** @type {Uint8Array} */\n    get data() {\n        return this._data;\n    }\n\n    /** @type {Uint8Array} */\n    get proof() {\n        return this._proof;\n    }\n\n    // Sender proof is set by the Wallet after signing a transaction.\n    /** @type {Uint8Array} */\n    set proof(proof) {\n        this._proof = proof;\n    }\n}\n\n/**\n * Enum for Transaction formats.\n * @enum\n */\nTransaction.Format = {\n    BASIC: 0,\n    EXTENDED: 1\n};\n/**\n * @enum\n */\nTransaction.Flag = {\n    NONE: 0,\n    CONTRACT_CREATION: 0b1,\n    ALL: 0b1\n};\n/** @type {Map.<Transaction.Format, {unserialize: function(buf: SerialBuffer):Transaction}>} */\nTransaction.FORMAT_MAP = new Map();\n\nClass.register(Transaction);\n","class SignatureProof {\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    static verifyTransaction(transaction) {\n        try {\n            const buffer = new SerialBuffer(transaction.proof);\n            const proof = SignatureProof.unserialize(buffer);\n\n            // Reject proof if it is longer than needed.\n            if (buffer.readPos !== buffer.byteLength) {\n                Log.w(SignatureProof, 'Invalid SignatureProof - overlong');\n                return false;\n            }\n\n            return proof.verify(transaction.sender, transaction.serializeContent());\n        } catch (e) {\n            Log.w(SignatureProof, `Failed to verify transaction: ${e.message || e}`, e);\n            return false;\n        }\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static singleSig(publicKey, signature) {\n        return new SignatureProof(publicKey, new MerklePath([]), signature);\n    }\n\n    /**\n     * @param {PublicKey} signerKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static multiSig(signerKey, publicKeys, signature) {\n        const merklePath = MerklePath.compute(publicKeys, signerKey);\n        return new SignatureProof(signerKey, merklePath, signature);\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {MerklePath} merklePath\n     * @param {Signature} signature\n     */\n    constructor(publicKey, merklePath, signature) {\n        if (!(publicKey instanceof PublicKey)) throw new Error('Malformed publickKey');\n        if (!(merklePath instanceof MerklePath)) throw new Error('Malformed merklePath');\n        if (signature && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        /**\n         * @type {PublicKey}\n         * @private\n         */\n        this._publicKey = publicKey;\n        /**\n         * @type {MerklePath}\n         * @private\n         */\n        this._merklePath = merklePath;\n        /**\n         * @type {Signature}\n         * @private\n         */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {SignatureProof}\n     */\n    static unserialize(buf) {\n        const publicKey = PublicKey.unserialize(buf);\n        const merklePath = MerklePath.unserialize(buf);\n        const signature = Signature.unserialize(buf);\n        return new SignatureProof(publicKey, merklePath, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._publicKey.serialize(buf);\n        this._merklePath.serialize(buf);\n\n        // The SignatureProof is sometimes serialized before the signature is set (e.g. when creating transactions).\n        // Simply don't serialize the signature if it's missing as this should never go over the wire.\n        // We always expect the signature to be present when unserializing.\n        if (this._signature) {\n            this._signature.serialize(buf);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._publicKey.serializedSize\n            + this._merklePath.serializedSize\n            + (this._signature ? this._signature.serializedSize : 0);\n    }\n\n    /**\n     * @param {SignatureProof} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof SignatureProof\n            && this._publicKey.equals(o._publicKey)\n            && this._merklePath.equals(o._merklePath)\n            && (this._signature ? this._signature.equals(o._signature) : this._signature === o._signature);\n    }\n\n    /**\n     * @param {?Address} sender\n     * @param {Uint8Array} data\n     * @returns {boolean}\n     */\n    verify(sender, data) {\n        if (sender !== null && !this.isSignedBy(sender)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signer does not match sender address');\n            return false;\n        }\n\n        if (!this._signature) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is missing');\n            return false;\n        }\n\n        if (!this._signature.verify(this._publicKey, data)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is invalid');\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Address} sender\n     * @returns {boolean}\n     */\n    isSignedBy(sender) {\n        const merkleRoot = this._merklePath.computeRoot(this._publicKey);\n        const signerAddr = Address.fromHash(merkleRoot);\n        return signerAddr.equals(sender);\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {MerklePath} */\n    get merklePath() {\n        return this._merklePath;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {Signature} */\n    set signature(signature) {\n        this._signature = signature;\n    }\n}\n\nClass.register(SignatureProof);\n","class BasicTransaction extends Transaction {\n    /**\n     * @param {PublicKey} senderPubKey\n     * @param {Address} recipient\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Signature} [signature]\n     * @param {number} [networkId]\n     */\n    constructor(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId) {\n        if (!(senderPubKey instanceof PublicKey)) throw new Error('Malformed senderPubKey');\n        // Signature may be initially empty and can be set later.\n        if (signature !== undefined && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        const proof = SignatureProof.singleSig(senderPubKey, signature);\n        super(Transaction.Format.BASIC, senderPubKey.toAddress(), Account.Type.BASIC, recipient, Account.Type.BASIC, value, fee, validityStartHeight, Transaction.Flag.NONE, new Uint8Array(0), proof.serialize(), networkId);\n\n        /**\n         * @type {SignatureProof}\n         * @private\n         */\n        this._signatureProof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        Assert.that(type === Transaction.Format.BASIC);\n\n        const senderPubKey = PublicKey.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const networkId = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new BasicTransaction(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.BASIC);\n        this.senderPubKey.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._networkId);\n        this.signature.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.senderPubKey.serializedSize\n            + this._recipient.serializedSize\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*networkId*/ 1\n            + this.signature.serializedSize;\n    }\n\n    /**\n     * @type {PublicKey}\n     */\n    get senderPubKey() {\n        return this._signatureProof.publicKey;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    get signature() {\n        return this._signatureProof.signature;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    set signature(signature) {\n        this._signatureProof.signature = signature;\n        this._proof = this._signatureProof.serialize();\n    }\n}\nTransaction.FORMAT_MAP.set(Transaction.Format.BASIC, BasicTransaction);\nClass.register(BasicTransaction);\n","class ExtendedTransaction extends Transaction {\n\n    /**\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     * @param {number} [networkId]\n     */\n    constructor(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof = new Uint8Array(0), networkId) {\n        super(Transaction.Format.EXTENDED, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = /** @type {Transaction.Format} */ buf.readUint8();\n        Assert.that(type === Transaction.Format.EXTENDED);\n\n        const dataSize = buf.readUint16();\n        const data = buf.read(dataSize);\n        const sender = Address.unserialize(buf);\n        const senderType = /** @type {Account.Type} */ buf.readUint8();\n        const recipient = Address.unserialize(buf);\n        const recipientType = /** @type {Account.Type} */ buf.readUint8();\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const networkId = buf.readUint8();\n        const flags = buf.readUint8();\n        const proofSize = buf.readUint16();\n        const proof = buf.read(proofSize);\n        return new ExtendedTransaction(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.EXTENDED);\n        this.serializeContent(buf);\n        buf.writeUint16(this._proof.byteLength);\n        buf.write(this._proof);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.serializedContentSize\n            + /*proofSize*/ 2\n            + this._proof.byteLength;\n    }\n}\n\nTransaction.FORMAT_MAP.set(Transaction.Format.EXTENDED, ExtendedTransaction);\nClass.register(ExtendedTransaction);\n","/**\n * @interface\n */\nclass IWorker {\n    static async createProxy(clazz, name, worker) {\n        return new (IWorker.Proxy(clazz))(worker, name);\n    }\n\n    static async startWorkerForProxy(clazz, name, workerScript) {\n        if (!IWorker._workersSupported) {\n            await IWorker._workerImplementation[clazz.name].init(name);\n            return IWorker._workerImplementation[clazz.name];\n        } else {\n            if (!workerScript) {\n                workerScript = `${Nimiq._path}worker.js`;\n            }\n            return IWorker.createProxy(clazz, name, new Worker(window.URL.createObjectURL(new Blob([`Nimiq = {_path: '${Nimiq._path}'}; importScripts('${workerScript.replace(/'/g, '')}');`]))));\n        }\n    }\n\n    static async startWorkerPoolForProxy(clazz, name, size, workerScript) {\n        return (new (IWorker.Pool(clazz))((name) => IWorker.startWorkerForProxy(clazz, name, workerScript), name, size)).start();\n    }\n\n    static async stubBaseOnMessage(msg) {\n        try {\n            if (msg.data.command === 'init') {\n                if (IWorker._workerImplementation[msg.data.args[0]]) {\n                    const res = await IWorker._workerImplementation[msg.data.args[0]].init(msg.data.args[1]);\n                    self.postMessage({status: 'OK', result: res, id: msg.data.id});\n                } else {\n                    self.postMessage({status: 'error', result: 'Unknown worker!', id: msg.data.id});\n                }\n            } else {\n                self.postMessage({status: 'error', result: 'Worker not yet initialized!', id: msg.data.id});\n            }\n        } catch (e) {\n            self.postMessage({status: 'error', result: e, id: msg.data.id});\n        }\n    }\n\n    static get _workersSupported() {\n        return typeof Worker !== 'undefined';\n    }\n\n    static get areWorkersAsync() {\n        return IWorker._workersSupported;\n    }\n\n    static get _insideWebWorker() {\n        return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n\n    static prepareForWorkerUse(baseClazz, impl) {\n        if (IWorker._insideWebWorker) {\n            // Only inside WebWorker\n            self.onmessage = IWorker.stubBaseOnMessage;\n        }\n        IWorker._workerImplementation = IWorker._workerImplementation || {};\n        IWorker._workerImplementation[baseClazz.name] = impl;\n    }\n\n    static _loadBrowserScript(url, resolve) {\n        // Adding the script tag to the head as suggested before\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n\n        // Then bind the event to the callback function.\n        // There are several events for cross browser compatibility.\n        // These events might occur before processing, so delay them a bit.\n        const ret = () => window.setTimeout(resolve, 100);\n        script.onreadystatechange = ret;\n        script.onload = ret;\n\n        // Fire the loading\n        head.appendChild(script);\n    }\n\n    static Proxy(clazz) {\n        const proxyClass = class extends clazz {\n            /**\n             * @param {Worker} worker\n             * @param {string} [name]\n             */\n            constructor(worker, name) {\n                super();\n                this._name = name;\n                this._messageId = 0;\n                this._worker = worker;\n                this._worker.onmessage = this._receive.bind(this);\n                /** @type {Map.<number,{resolve:Function,error:Function}>} */\n                this._waiting = new Map();\n                return this._invoke('init', [clazz.name, name]).then(() => { return this; });\n            }\n\n            _receive(msg) {\n                const cb = this._waiting.get(msg.data.id);\n                if (!cb) {\n                    Log.w(WorkerProxy, 'Unknown reply', msg);\n                } else {\n                    this._waiting.delete(msg.data.id);\n                    if (msg.data.status === 'OK') {\n                        cb.resolve(msg.data.result);\n                    } else if (msg.data.status === 'error') {\n                        cb.error(msg.data.result);\n                    }\n                }\n            }\n\n            /**\n             * @param {string} command\n             * @param {object[]} [args]\n             * @returns {Promise}\n             * @private\n             */\n            _invoke(command, args = []) {\n                return new Promise((resolve, error) => {\n                    const obj = {command: command, args: args, id: this._messageId++};\n                    this._waiting.set(obj.id, {resolve, error});\n                    this._worker.postMessage(obj);\n                });\n            }\n\n            destroy() {\n                return this._invoke('destroy');\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                proxyClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return proxyClass;\n    }\n\n    /**\n     * @param {object} clazz\n     * @return {Stub}\n     * @constructor\n     */\n    static Stub(clazz) {\n        const Stub = class extends clazz {\n            constructor() {\n                super();\n            }\n\n            _result(msg, status, result) {\n                self.postMessage({status, result, id: msg.data.id});\n            }\n\n            _onmessage(msg) {\n                try {\n                    const res = this._invoke(msg.data.command, msg.data.args);\n                    if (res instanceof Promise) {\n                        res.then((finalRes) => { this._result(msg, 'OK', finalRes); });\n                    } else {\n                        this._result(msg, 'OK', res);\n                    }\n                } catch (e) {\n                    this._result(msg, 'error', e.message || e);\n                }\n            }\n\n            init(name) {\n                this._name = name;\n                if (IWorker._insideWebWorker) {\n                    self.name = name;\n                    self.onmessage = (msg) => this._onmessage(msg);\n                }\n            }\n\n            _invoke(command, args) {\n                return this[command].apply(this, args);\n            }\n\n            destroy() {\n                if (IWorker._insideWebWorker) {\n                    self.close();\n                }\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                Stub.prototype[funcName] = function () {\n                    throw `Not implemented in IWorker Stub: ${funcName}`;\n                };\n            }\n        }\n        return Stub;\n    }\n\n    static Pool(clazz) {\n        const poolClass = class extends clazz {\n            /**\n             *\n             * @param {function(string):Promise} proxyInitializer\n             * @param {string} [name]\n             * @param {number} [size] Number of workers in this pool.\n             */\n            constructor(proxyInitializer, name = 'pool', size = 1) {\n                super();\n                /** @type {function(string):Promise} */\n                this._proxyInitializer = proxyInitializer;\n                /** @type {string} */\n                this._name = name;\n                /** @type {number} */\n                this._poolSize = size;\n                /** @type {Array} */\n                this._workers = [];\n                /** @type {Array} */\n                this._freeWorkers = [];\n                /** @type {Array.<{name:string, args:Array, resolve:function, error:function}>} */\n                this._waitingCalls = [];\n            }\n\n            async start() {\n                await this._updateToSize();\n\n                return this;\n            }\n\n            get poolSize() {\n                return this._poolSize;\n            }\n\n            set poolSize(_size) {\n                this._poolSize = _size;\n                this._updateToSize().catch(Log.w.tag(IWorker));\n            }\n\n            destroy() {\n                this._poolSize = 0;\n                return this._updateToSize();\n            }\n\n            /**\n             * @param {string} name Name of the function to call on a worker\n             * @param {Array} args Arguments to pass to the function\n             * @returns {Promise}\n             */\n            _invoke(name, args) {\n                if (IWorker._workersSupported) {\n                    return new Promise((resolve, error) => {\n                        this._waitingCalls.push({name, args, resolve, error});\n                        const worker = this._freeWorkers.shift();\n                        if (worker) {\n                            this._step(worker).catch(Log.w.tag(IWorker));\n                        }\n                    });\n                } else {\n                    return this._workers[0][name].apply(this._workers[0], args);\n                }\n            }\n\n            /**\n             * @param worker\n             * @returns {Promise.<void>}\n             * @private\n             */\n            async _step(worker) {\n                let call = this._waitingCalls.shift();\n                while (call) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        call.resolve(await worker[call.name].apply(worker, call.args));\n                    } catch (e) {\n                        call.error(e);\n                    }\n                    if (this._workers.indexOf(worker) === -1) {\n                        worker.destroy();\n                        return;\n                    }\n                    call = this._waitingCalls.shift();\n                }\n                this._freeWorkers.push(worker);\n            }\n\n            async _updateToSize() {\n                if (typeof Worker === 'undefined' && this._poolSize > 1) {\n                    Log.d(IWorker, 'Pool of size larger than 1 requires WebWorker support.');\n                    this._poolSize = 1;\n                }\n\n                const workerPromises = [];\n                while (this._workers.length + workerPromises.length < this._poolSize) {\n                    workerPromises.push(this._proxyInitializer(`${this._name}#${this._workers.length + workerPromises.length}`));\n                }\n                const createdWorkers = await Promise.all(workerPromises);\n                for (const worker of createdWorkers) {\n                    this._workers.push(worker);\n                    this._step(worker).catch(Log.w.tag(IWorker));\n                }\n\n                while (this._workers.length > this._poolSize) {\n                    const worker = this._freeWorkers.shift() || this._workers.pop();\n                    const idx = this._workers.indexOf(worker);\n                    if (idx >= 0) {\n                        // This was a free worker, also remove it from the worker list and destroy it now.\n                        this._workers.splice(idx, 1);\n                        worker.destroy();\n                    }\n                }\n                return this;\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                poolClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return poolClass;\n    }\n}\n\nIWorker._moduleLoadedCallbacks = {};\nIWorker._workerImplementation = {};\nClass.register(IWorker);\n","class WasmHelper {\n\n    static async doImportBrowser() {\n        if (PlatformUtils.isNodeJs()) return;\n        if (WasmHelper._importStarted) {\n            Log.e(WasmHelper, 'doImportBrowser invoked twice');\n            return;\n        }\n        WasmHelper._importStarted = true;\n        if (await WasmHelper.importWasmBrowser('worker-wasm.wasm')) {\n            await WasmHelper.importScriptBrowser('worker-wasm.js');\n        } else {\n            await WasmHelper.importScriptBrowser('worker-js.js');\n        }\n        WasmHelper._importFinished = true;\n    }\n\n    static doImportNodeJs() {\n        if (!PlatformUtils.isNodeJs()) return;\n        if (WasmHelper.importWasmNodeJs('worker-wasm.wasm')) {\n            WasmHelper.importScriptNodeJs('worker-wasm.js');\n        } else {\n            WasmHelper.importScriptNodeJs('worker-js.js');\n        }\n    }\n\n    /**\n     * @param {string} wasm\n     * @param {string} module\n     * @returns {Promise.<boolean>}\n     */\n    static importWasmBrowser(wasm, module = 'Module') {\n        wasm = WasmHelper._adjustWasmPath(wasm);\n        if (!WasmHelper._global.WebAssembly) {\n            Log.w(WasmHelper, 'No support for WebAssembly available.');\n            return Promise.resolve(false);\n        }\n\n        return new Promise((resolve) => {\n            try {\n                const xhr = new XMLHttpRequest();\n                xhr.open('GET', wasm, true);\n                xhr.responseType = 'arraybuffer';\n                xhr.onload = function () {\n                    WasmHelper._global[module] = WasmHelper._global[module] || {};\n                    WasmHelper._global[module].wasmBinary = xhr.response;\n                    resolve(true);\n                };\n                xhr.onerror = function () {\n                    Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}`);\n                    resolve(false);\n                };\n                xhr.send(null);\n            } catch (e) {\n                Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}`);\n                resolve(false);\n            }\n        });\n    }\n\n    static importWasmNodeJs(wasm, module = 'Module') {\n        wasm = WasmHelper._adjustWasmPath(wasm);\n        if (!WasmHelper._global.WebAssembly) {\n            Log.w(WasmHelper, 'No support for WebAssembly available.');\n            return false;\n        }\n\n        const toUint8Array = function (buf) {\n            const u = new Uint8Array(buf.length);\n            for (let i = 0; i < buf.length; ++i) {\n                u[i] = buf[i];\n            }\n            return u;\n        };\n        const fs = require('fs');\n        try {\n            const data = fs.readFileSync(wasm);\n            WasmHelper._global[module] = WasmHelper._global[module] || {};\n            WasmHelper._global[module].wasmBinary = toUint8Array(data);\n            return true;\n        } catch (e) {\n            Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}: ${e}`);\n            return false;\n        }\n    }\n\n    static importScriptBrowser(script, module = 'Module') {\n        if (module && WasmHelper._global[module] && WasmHelper._global[module].asm) return false;\n        script = WasmHelper._adjustScriptPath(script);\n\n        const moduleSettings = WasmHelper._global[module] || {};\n        return new Promise(async (resolve, reject) => {\n            if (module) {\n                moduleSettings.onRuntimeInitialized = () => resolve(true);\n            }\n            if (typeof importScripts === 'function') {\n                await new Promise((resolve) => {\n                    WasmHelper._moduleLoadedCallbacks[module] = resolve;\n                    importScripts(script);\n                });\n                WasmHelper._global[module] = WasmHelper._global[module](moduleSettings);\n                if (!module) resolve(true);\n            } else if (typeof window === 'object') {\n                await new Promise((resolve) => {\n                    WasmHelper._moduleLoadedCallbacks[module] = resolve;\n                    WasmHelper._loadBrowserScript(script);\n                });\n                WasmHelper._global[module] = WasmHelper._global[module](moduleSettings);\n                if (!module) resolve(true);\n            } else if (typeof require === 'function') {\n                WasmHelper._global[module] = require(script)(moduleSettings);\n                if (!module) resolve(true);\n            } else {\n                reject('No way to load scripts.');\n            }\n        });\n    }\n\n    static importScriptNodeJs(script, module = 'Module') {\n        if (module && WasmHelper._global[module] && WasmHelper._global[module].asm) return false;\n        script = WasmHelper._adjustScriptPath(script);\n\n        const moduleSettings = WasmHelper._global[module] || {};\n\n        if (typeof require === 'function') {\n            WasmHelper._global[module] = require(script)(moduleSettings);\n            if (!module) return true;\n        }\n        return false;\n    }\n\n    static fireModuleLoaded(module = 'Module') {\n        if (typeof WasmHelper._moduleLoadedCallbacks[module] === 'function') {\n            WasmHelper._moduleLoadedCallbacks[module]();\n            WasmHelper._moduleLoadedCallbacks[module] = null;\n        }\n    }\n\n    static _loadBrowserScript(url) {\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        head.appendChild(script);\n    }\n\n    static _adjustWasmPath(wasm) {\n        if (typeof Nimiq !== 'undefined' && Nimiq._path) wasm = `${Nimiq._path}${wasm}`;\n        if (typeof __dirname === 'string' && wasm.indexOf('/') === -1) wasm = `${__dirname}/${wasm}`;\n        return wasm;\n    }\n\n    static _adjustScriptPath(script) {\n        if (typeof Nimiq !== 'undefined' && Nimiq._path) script = `${Nimiq._path}${script}`;\n        if (typeof __dirname === 'string' && script.indexOf('/') === -1) script = `${__dirname}/${script}`;\n        return script;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n}\nWasmHelper._moduleLoadedCallbacks = {};\n\nClass.register(WasmHelper);\n\n","/**\n * @interface\n */\nclass CryptoWorker {\n    static get lib() { return CryptoLib.instance; }\n\n    /**\n     * @returns {Promise.<CryptoWorker>}\n     */\n    static async getInstanceAsync() {\n        if (!CryptoWorker._workerAsync) {\n            CryptoWorker._workerAsync = await IWorker.startWorkerPoolForProxy(CryptoWorker, 'crypto', 4);\n        }\n        return CryptoWorker._workerAsync;\n    }\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeArgon2d(input) {}\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Promise.<Array.<Uint8Array>>}\n     */\n    async computeArgon2dBatch(inputs) {}\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Promise.<Uint8Array>}\n     */\n    async kdf(key, salt, iterations) {}\n\n    /**\n     * @param {Uint8Array} block\n     * @param {Array.<bool>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @param {number} networkId\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(block, transactionValid, timeNow, genesisHash, networkId) {}\n}\n/** @type {CryptoWorker} */\nCryptoWorker._workerAsync = null;\n\nClass.register(CryptoWorker);\n","class GenesisConfig {\n    static main() {\n        GenesisConfig.init(GenesisConfig.CONFIGS['main']);\n    }\n\n    static test() {\n        GenesisConfig.init(GenesisConfig.CONFIGS['test']);\n    }\n\n    static dev() {\n        GenesisConfig.init(GenesisConfig.CONFIGS['dev']);\n    }\n\n    static bounty() {\n        GenesisConfig.init(GenesisConfig.CONFIGS['bounty']);\n    }\n\n    /**\n     * @param {{NETWORK_ID:number}} config\n     */\n    static init(config) {\n        if (GenesisConfig._config) throw new Error('GenesisConfig already initialized');\n        if (!config.NETWORK_ID) throw new Error('Config is missing network id');\n        if (!config.NETWORK_NAME) throw new Error('Config is missing database prefix');\n\n        GenesisConfig._config = config;\n    }\n\n    /**\n     * @type {number}\n     */\n    static get NETWORK_ID() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.NETWORK_ID;\n    }\n\n    /**\n     * @type {string}\n     */\n    static get NETWORK_NAME() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.NETWORK_NAME;\n    }\n}\nClass.register(GenesisConfig);\n\nGenesisConfig.CONFIGS = {\n    // TODO 'main': { }\n    'test': {\n        NETWORK_ID: 1,\n        NETWORK_NAME: 'test'\n    },\n\n    'dev': {\n        NETWORK_ID: 2,\n        NETWORK_NAME: 'dev'\n    },\n\n    'bounty': {\n        NETWORK_ID: 3,\n        NETWORK_NAME: 'bounty'\n    }\n};\n// TODO\nGenesisConfig.CONFIGS['main'] = GenesisConfig.CONFIGS['test'];\n","    exports._loaded = true;\n    if (typeof exports._onload === 'function') exports._onload();\n    return exports;\n})(Nimiq);\n"]}