{"version":3,"sources":["Class.js","PlatformUtils.js","LogNative.js","Log.js","IWorker.js","WasmHelper.js","CryptoWorker.js","CryptoWorkerImpl.js","NumberUtils.js","BufferUtils.js","SerialBuffer.js","MinerWorker.js","MinerWorkerImpl.js","MinerWorkerPool.js","GenesisConfig.js","ArrayUtils.js","Assert.js","MerkleTree.js","MerklePath.js","Policy.js","Serializable.js","Hash.js","PublicKey.js","Signature.js","Address.js","Account.js","PrunedAccount.js","BasicAccount.js","Contract.js","HashedTimeLockedContract.js","VestingContract.js","BlockHeader.js","BlockInterlink.js","BlockBody.js","BlockUtils.js","Block.js","Transaction.js","SignatureProof.js","BasicTransaction.js","ExtendedTransaction.js"],"names":["Class","scope","exports","window","[object Object]","cls","name","register","PlatformUtils","isBrowser","process","require","RTCPeerConnection","webkitRTCPeerConnection","navigator","onLine","LogNative","this","_global_level","Log","INFO","_tag_levels","localStorage","c","getItem","JSON","parse","e","console","warn","tag","level","setItem","stringify","args","isLoggable","unshift","Level","toStringTag","Date","toTimeString","substr","error","ERROR","apply","WARNING","info","debug","DEBUG","trace","TRACE","log","instance","_instance","native","_native","setLoggable","get","l","i","length","toString","constructor","msg","message","arguments","Array","prototype","slice","call","undefined","VERBOSE","ASSERT","v","isNaN","parseInt","toLowerCase","d","bind","w","t","IWorker","clazz","worker","Proxy","workerScript","_workersSupported","Nimiq","_path","createProxy","Worker","URL","createObjectURL","Blob","replace","_workerImplementation","init","size","Pool","startWorkerForProxy","start","data","command","res","self","postMessage","status","result","id","areWorkersAsync","_insideWebWorker","WorkerGlobalScope","_global","global","baseClazz","impl","onmessage","stubBaseOnMessage","url","resolve","head","document","getElementsByTagName","script","createElement","type","src","ret","setTimeout","onreadystatechange","onload","appendChild","proxyClass","super","_name","_messageId","_worker","_receive","_waiting","Map","_invoke","then","cb","delete","WorkerProxy","Promise","obj","set","funcName","Object","getOwnPropertyNames","Stub","finalRes","_result","_onmessage","close","poolClass","proxyInitializer","_proxyInitializer","_poolSize","_workers","_freeWorkers","_waitingCalls","_updateToSize","poolSize","_size","catch","push","shift","_step","indexOf","destroy","workerPromises","createdWorkers","all","pop","idx","splice","_moduleLoadedCallbacks","WasmHelper","isNodeJs","_importStarted","importWasmBrowser","importScriptBrowser","_importFinished","importWasmNodeJs","importScriptNodeJs","wasm","module","_adjustWasmPath","WebAssembly","xhr","XMLHttpRequest","open","responseType","wasmBinary","response","onerror","send","fs","readFileSync","buf","u","Uint8Array","toUint8Array","asm","_adjustScriptPath","moduleSettings","async","reject","onRuntimeInitialized","importScripts","_loadBrowserScript","__dirname","CryptoWorker","lib","CryptoLib","_workerAsync","startWorkerPoolForProxy","input","inputs","key","salt","iterations","block","transactionValid","timeNow","genesisHash","networkId","CryptoWorkerImpl","_superInit","doImportBrowser","out","Hash","getSize","Algorithm","ARGON2D","NodeNative","node_argon2","stackPtr","Module","stackSave","hashSize","wasmOut","stackAlloc","wasmIn","HEAPU8","buffer","_nimiq_argon2","hash","stackRestore","hashes","stackTmp","node_kdf","wasmSalt","_nimiq_kdf","blockSerialized","GenesisConfig","GENESIS_HASH","unserialize","SerialBuffer","NETWORK_ID","Block","body","transactions","_valid","valid","_verify","pow","header","interlinkHash","interlink","bodyHash","serialize","prepareForWorkerUse","NumberUtils","val","Number","isInteger","UINT8_MAX","UINT16_MAX","UINT32_MAX","UINT64_MAX","Math","floor","random","MAX_SAFE_INTEGER","BufferUtils","String","fromCharCode","string","charCodeAt","u8","TextDecoder","Error","_ISO_8859_15_DECODER","decode","num","_BASE64_LOOKUP","end","tmp","output","_tripletToBase64","join","len","extraBytes","parts","len2","_base64encodeChunk","Buffer","btoa","_codePointTextDecoder","_base64fromByteArray","base64","from","atob","toBase64","alphabet","BASE32_ALPHABET","NIMIQ","byte","symbol","carry","base32","charmap","toUpperCase","split","forEach","char","hex","code","HEX_ALPHABET","trim","StringUtils","isHexBytes","match","a","b","viewA","viewB","byteLength","BASE64_ALPHABET","RFC4648","RFC4648_HEX","bufferOrArrayOrLength","_view","DataView","_readPos","_writePos","ArrayUtils","subarray","readPos","value","writePos","array","getUint8","setUint8","getUint16","setUint16","getUint32","setUint32","isUint64","readUint8","readUint16","readUint32","readUint64","writeUint8","writeUint16","writeUint32","writeUint64","getFloat64","setFloat64","bytes","read","toAscii","isMultibyte","fromAscii","write","view","byteOffset","padding","isUint8","MinerWorker","blockHeader","compact","minNonce","maxNonce","MinerWorkerImpl","_malloc","nonce","_nimiq_argon2_target","_free","MinerWorkerPool","_miningEnabled","_activeNonces","_block","_noncesPerRun","_observable","Observable","_shareCompact","Policy","BLOCK_TARGET_MAX","_runsPerCycle","Infinity","_cycleWait","_superUpdateToSize","multiMine","fail","node_argon2_target_async","getInstanceAsync","computeArgon2d","noncesPerRun","nonces","runsPerCycle","cycleWait","callback","on","off","shareCompact","nBits","_startMiner","max","map","nonceRange","_singleMiner","fire","newMin","newRange","arr","uintarr","begin","clamp","min","list","k","n","indices","x","reverseRange","found","j","Assert","condition","MerkleTree","values","fnHash","_hash","_computeRoot","light","mid","round","left","right","leftHash","rightHash","concatTypedArrays","o","MerklePath","nodes","isArray","some","it","MerklePathNode","_nodes","leafValue","leafHash","path","_compute","containsLeaf","inner","equals","leftLeaf","rightLeaf","root","node","concat","serializedSize","count","leftBitsSize","ceil","leftBits","_compress","reduce","sum","every","_left","coins","SATOSHIS_PER_COIN","satoshis","blockHeight","startHeight","_supplyCacheInterval","startI","_supplyCacheMax","endI","supply","INITIAL_SUPPLY","_supplyCache","endHeight","_supplyAfter","initialSupply","_blockRewardAt","currentSupply","supplyAfter","remaining","TOTAL_SUPPLY","EMISSION_TAIL_START","EMISSION_TAIL_REWARD","EMISSION_SPEED","BLOCK_TIME","BLOCK_SIZE_MAX","DIFFICULTY_BLOCK_WINDOW","DIFFICULTY_MAX_ADJUSTMENT_FACTOR","TRANSACTION_VALIDITY_WINDOW","M","K","DELTA","NUM_BLOCKS_VERIFICATION","NUM_SNAPSHOTS_MAX","Serializable","compare","toHex","_obj","arg","algorithm","BLAKE2B","_algorithm","blake2b","computeBlake2b","argon2d","computeSha256","SHA256","sha256","SIZE","fromBase64","fromHex","str","node_blake2","_nimiq_blake2","node_sha256","_nimiq_sha256","SHA512","NULL","PublicKey","privateKey","_publicKeyDerive","publicKeys","sort","_delinearizeAndAggregatePublicKeys","Address","fromHash","PeerId","publicKeysObj","publicKeysHash","_publicKeysHash","raw","_publicKeysDelinearizeAndAggregate","PrivateKey","node_ed25519_public_key_derive","pubKeyBuffer","HEAP8","privKeyBuffer","_ed25519_public_key_derive","fill","publicKey","concatenatedPublicKeys","node_ed25519_hash_public_keys","wasmInPublicKeys","_ed25519_hash_public_keys","hashedPublicKey","node_ed25519_delinearize_public_key","wasmInPublicKey","wasmInPublicKeysHash","_ed25519_delinearize_public_key","delinearizedPublicKey","node_ed25519_aggregate_delinearized_public_keys","_ed25519_aggregate_delinearized_public_keys","aggregatePublicKey","Signature","_signatureCreate","commitment","signatures","_combinePartialSignatures","s","_signatureVerify","combinedCommitment","partialSignatures","combinedSignature","_aggregatePartialSignatures","sigA","sigB","_scalarsAdd","PartialSignature","node_ed25519_add_scalars","wasmOutSum","wasmInA","wasmInB","_ed25519_add_scalars","node_ed25519_sign","wasmOutSignature","signatureBuffer","wasmInMessage","wasmInPubKey","wasmInPrivKey","_ed25519_sign","signature","node_ed25519_verify","wasmInSignature","_ed25519_verify","SERIALIZED_SIZE","fromUserFriendlyAddress","CCODE","_ibanCheck","fromBase32","withSpaces","toBase32","check","HEX_SIZE","CONTRACT_CREATION","Account","balance","_type","_balance","TYPE_MAP","has","transaction","transactionsCache","revert","validityStartHeight","withBalance","fee","newBalance","containsTransaction","INITIAL","isInitial","Type","BASIC","VESTING","HTLC","PrunedAccount","address","account","_address","_account","BasicAccount","SignatureProof","verifyTransaction","hasFlag","Transaction","Flag","recipientType","withIncomingTransaction","create","Contract","recipient","getContractCreationAddress","HashedTimeLockedContract","sender","hashRoot","hashCount","timeout","totalAmount","isUint32","_sender","_recipient","_hashRoot","_hashCount","_timeout","_totalAmount","hashAlgorithm","toUserFriendlyAddress","proof","ProofType","REGULAR_TRANSFER","hashDepth","preImage","compute","verify","serializeContent","EARLY_RESOLVE","TIMEOUT_RESOLVE","verifyIncomingTransaction","minCap","isSignedBy","withOutgoingTransaction","VestingContract","owner","vestingStart","vestingStepBlocks","vestingStepAmount","vestingTotalAmount","_owner","_vestingStart","_vestingStepBlocks","_vestingStepAmount","_vestingTotalAmount","getMinCap","BlockHeader","prevHash","copy","_prevHash","_interlinkHash","_bodyHash","accountsHash","_accountsHash","_nBits","_height","_timestamp","_nonce","_version","height","timestamp","version","CURRENT_VERSION","isUint16","isHash","BlockUtils","isValidCompact","SUPPORTED_VERSIONS","includes","isProofOfWork","target","prevHeader","_pow","hard","compactToTarget","difficulty","compactToDifficulty","Version","V1","BlockInterlink","_hashes","repeatBits","_repeatBits","compressed","_compressed","repeatBitsSize","lastHash","computeRoot","BlockBody","extraData","minerAddr","prunedAccounts","_minerAddr","_extraData","_transactions","_prunedAccounts","extraDataLength","numTransactions","numPrunedAccounts","tx","acc","previousTx","compareBlockOrder","previousAcc","isToBePruned","getMerkleLeafs","addresses","transactionCount","isFinite","log2","getTargetHeight","targetToCompact","difficultyToTarget","targetToDifficulty","hashToTarget","getTargetDepth","isValidTarget","headBlock","tailBlock","deltaTotalDifficulty","that","actualTime","adjustment","averageDifficulty","nextTarget","_header","_interlink","_body","time","isLight","now","blockVerify","TIMESTAMP_DRIFT_MAX","verifyProofOfWork","_verifyInterlink","isFull","_verifyBody","predecessor","isImmediateSuccessorOf","getNextInterlink","prevPow","targetHeight","blockFound","depth","HashSet","addAll","removeAll","depthDiff","commonBlock","thisInterlink","prevInterlink","isInterlinkSuccessorOf","nextVersion","thisPowDepth","getHashDepth","nextTargetDepth","numOccurrences","format","senderType","flags","_format","_senderType","_recipientType","_value","_fee","_networkId","_validityStartHeight","_flags","_data","_proof","FORMAT_MAP","serializedContentSize","verifyOutgoingTransaction","recCompare","senderCompare","feePerByte","flag","Format","EXTENDED","NONE","ALL","signerKey","merklePath","_publicKey","_merklePath","_signature","merkleRoot","BasicTransaction","senderPubKey","singleSig","toAddress","_signatureProof","ExtendedTransaction","dataSize","proofSize"],"mappings":"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","file":"worker.js","sourcesContent":["class Class {\n    static get scope() {\n        if (typeof exports !== 'undefined') return exports;\n        return window;\n    }\n\n    static register(cls) {\n        if (typeof exports !== 'undefined') exports[cls.name] = cls;\n    }\n}\nClass.register(Class);\n","class PlatformUtils {\n    /**\n     * @returns {boolean}\n     */\n    static isBrowser() {\n        return typeof window !== 'undefined';\n    }\n\n    /**\n     * @return {boolean}\n     */\n    static isNodeJs() {\n        return !PlatformUtils.isBrowser() && typeof process === 'object' && typeof require === 'function';\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static supportsWebRTC() {\n        let RTCPeerConnection = PlatformUtils.isBrowser() ? (window.RTCPeerConnection || window.webkitRTCPeerConnection) : null;\n        return !!RTCPeerConnection;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static isOnline() {\n        return (!PlatformUtils.isBrowser() || !('onLine' in window.navigator)) || window.navigator.onLine;\n    }\n}\nClass.register(PlatformUtils);\n","class LogNative {\n    constructor() {\n        this._global_level = Log.INFO;\n        this._tag_levels = {};\n        try {\n            if (window.localStorage) {\n                try {\n                    let c = window.localStorage.getItem('log_tag_levels');\n                    if (c && typeof c === 'string') c = JSON.parse(c);\n                    if (c && typeof c === 'object') this._tag_levels = c;\n                } catch (e) {\n                    console.warn('Failed to load log configuration from local storage.');\n                }\n            }\n        } catch (e) {\n            // ignore\n        }\n    }\n\n    isLoggable(tag, level) {\n        if (tag && this._tag_levels[tag]) {\n            return this._tag_levels[tag] <= level;\n        }\n        if (this._tag_levels['*']) {\n            return this._tag_levels['*'] <= level;\n        }\n        return this._global_level <= level;\n    }\n\n    setLoggable(tag, level) {\n        if (tag && tag.name) tag = tag.name;\n        this._tag_levels[tag] = level;\n        if (window.localStorage) {\n            window.localStorage.setItem('log_tag_levels', JSON.stringify(this._tag_levels));\n        }\n    }\n\n    msg(level, tag, args) {\n        if (tag && tag.name) tag = tag.name;\n        if (!this.isLoggable(tag, level)) return;\n        if (tag) args.unshift(tag + ':');\n        args.unshift(`[${Log.Level.toStringTag(level)} ${new Date().toTimeString().substr(0, 8)}]`);\n        if (console.error && level >= Log.ERROR) {\n            console.error.apply(console, args);\n        } else if (console.warn && level >= Log.WARNING) {\n            console.warn.apply(console, args);\n        } else if (console.info && level >= Log.INFO) {\n            console.info.apply(console, args);\n        } else if (console.debug && level >= Log.DEBUG) {\n            console.debug.apply(console, args);\n        } else if (console.trace && level <= Log.TRACE) {\n            console.trace.apply(console, args);\n        } else {\n            console.log.apply(console, args);\n        }\n    }\n}\nClass.register(LogNative);\n","class Log {\n    /**\n     * @returns {Log}\n     */\n    static get instance() {\n        if (!Log._instance) {\n            Log._instance = new Log(new LogNative());\n        }\n        return Log._instance;\n    }\n\n    /**\n     * @param {LogNative} native\n     */\n    constructor(native) {\n        /** @type {LogNative} */\n        this._native = native;\n    }\n\n    /**\n     * @param {string} tag\n     * @param {Log.Level} level\n     */\n    setLoggable(tag, level) {\n        this._native.setLoggable(tag, Log.Level.get(level));\n    }\n\n    /** @type {Log.Level} */\n    get level() {\n        return this._native._global_level;\n    }\n\n    /** @type {Log.Level} */\n    set level(l) {\n        this._native._global_level = Log.Level.get(l);\n    }\n\n    /**\n     * @param {Log.Level} level\n     * @param {string|{name:string}} tag\n     * @param {Array} args\n     */\n    msg(level, tag, args) {\n        if (this._native.isLoggable(tag, level)) {\n            for (let i = 0; i < args.length; ++i) {\n                if (typeof args[i] === 'function') {\n                    args[i] = args[i]();\n                }\n                if (typeof args[i] === 'object') {\n                    if (typeof args[i].toString === 'function') {\n                        args[i] = args[i].toString();\n                    } else if (args[i].constructor && args[i].constructor.name) {\n                        args[i] = `{Object: ${args[i].constructor.name}}`;\n                    } else {\n                        args[i] = '{Object}';\n                    }\n                }\n            }\n            this._native.msg(level, tag, args);\n        }\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static d(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.DEBUG, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static e(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.ERROR, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static i(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.INFO, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static v(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.VERBOSE, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static w(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.WARNING, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static t(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.TRACE, tag, args);\n    }\n}\n\n/**\n * @enum {number|string}\n */\nLog.Level = {\n    TRACE: 1,\n    VERBOSE: 2,\n    DEBUG: 3,\n    INFO: 4,\n    WARNING: 5,\n    ERROR: 6,\n    ASSERT: 7,\n\n    /**\n     * @param {Log.Level} level\n     * @returns {string}\n     */\n    toStringTag: function (level) {\n        switch (level) {\n            case Log.Level.TRACE:\n                return 'T';\n            case Log.Level.VERBOSE:\n                return 'V';\n            case Log.Level.DEBUG:\n                return 'D';\n            case Log.Level.INFO:\n                return 'I';\n            case Log.Level.WARNING:\n                return 'W';\n            case Log.Level.ERROR:\n                return 'E';\n            case Log.Level.ASSERT:\n                return 'A';\n            default:\n                return '*';\n        }\n    },\n\n    toString: function (level) {\n        switch (level) {\n            case Log.Level.TRACE:\n                return 'trace';\n            case Log.Level.VERBOSE:\n                return 'verbose';\n            case Log.Level.DEBUG:\n                return 'debug';\n            case Log.Level.INFO:\n                return 'info';\n            case Log.Level.WARNING:\n                return 'warn';\n            case Log.Level.ERROR:\n                return 'error';\n            case Log.Level.ASSERT:\n                return 'assert';\n            default:\n                return 'unknown';\n        }\n    },\n\n    /**\n     * @param {string|number|Log.Level} v\n     * @returns {Log.Level}\n     */\n    get: function (v) {\n        if (typeof v === 'number') return /** @type {Log.Level} */ v;\n        if (!isNaN(parseInt(v))) return /** @type {Log.Level} */ parseInt(v);\n        switch (v.toLowerCase()) {\n            case 't':\n            case 'trace':\n                return Log.Level.TRACE;\n            case 'v':\n            case 'verbose':\n                return Log.Level.VERBOSE;\n            case 'd':\n            case 'debug':\n                return Log.Level.DEBUG;\n            case 'i':\n            case 'info':\n                return Log.Level.INFO;\n            case 'w':\n            case 'warn':\n            case 'warning':\n                return Log.Level.WARNING;\n            case 'e':\n            case 'error':\n            case 'exception':\n                return Log.Level.ERROR;\n            case 'a':\n            case 'assert':\n            case 'assertion':\n                return Log.Level.ASSERT;\n        }\n        return /** @type {Log.Level} */ 0;\n    }\n};\nLog.TRACE = Log.Level.TRACE;\nLog.VERBOSE = Log.Level.VERBOSE;\nLog.DEBUG = Log.Level.DEBUG;\nLog.INFO = Log.Level.INFO;\nLog.WARNING = Log.Level.WARNING;\nLog.ERROR = Log.Level.ERROR;\nLog.ASSERT = Log.Level.ASSERT;\nLog._instance = null;\n\nLog.d.tag = (tag) => Log.d.bind(null, tag);\nLog.e.tag = (tag) => Log.e.bind(null, tag);\nLog.i.tag = (tag) => Log.i.bind(null, tag);\nLog.v.tag = (tag) => Log.v.bind(null, tag);\nLog.w.tag = (tag) => Log.w.bind(null, tag);\nLog.t.tag = (tag) => Log.t.bind(null, tag);\n\nClass.register(Log);\n","/**\n * @interface\n */\nclass IWorker {\n    static async createProxy(clazz, name, worker) {\n        return new (IWorker.Proxy(clazz))(worker, name);\n    }\n\n    static async startWorkerForProxy(clazz, name, workerScript) {\n        if (!IWorker._workersSupported) {\n            await IWorker._workerImplementation[clazz.name].init(name);\n            return IWorker._workerImplementation[clazz.name];\n        } else {\n            if (!workerScript) {\n                workerScript = `${Nimiq._path}worker.js`;\n            }\n            return IWorker.createProxy(clazz, name, new Worker(window.URL.createObjectURL(new Blob([`Nimiq = {_path: '${Nimiq._path}'}; importScripts('${workerScript.replace(/'/g, '')}');`]))));\n        }\n    }\n\n    static async startWorkerPoolForProxy(clazz, name, size, workerScript) {\n        return (new (IWorker.Pool(clazz))((name) => IWorker.startWorkerForProxy(clazz, name, workerScript), name, size)).start();\n    }\n\n    static async stubBaseOnMessage(msg) {\n        try {\n            if (msg.data.command === 'init') {\n                if (IWorker._workerImplementation[msg.data.args[0]]) {\n                    const res = await IWorker._workerImplementation[msg.data.args[0]].init(msg.data.args[1]);\n                    self.postMessage({status: 'OK', result: res, id: msg.data.id});\n                } else {\n                    self.postMessage({status: 'error', result: 'Unknown worker!', id: msg.data.id});\n                }\n            } else {\n                self.postMessage({status: 'error', result: 'Worker not yet initialized!', id: msg.data.id});\n            }\n        } catch (e) {\n            self.postMessage({status: 'error', result: e, id: msg.data.id});\n        }\n    }\n\n    static get _workersSupported() {\n        return typeof Worker !== 'undefined';\n    }\n\n    static get areWorkersAsync() {\n        return IWorker._workersSupported;\n    }\n\n    static get _insideWebWorker() {\n        return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n\n    static prepareForWorkerUse(baseClazz, impl) {\n        if (IWorker._insideWebWorker) {\n            // Only inside WebWorker\n            self.onmessage = IWorker.stubBaseOnMessage;\n        }\n        IWorker._workerImplementation = IWorker._workerImplementation || {};\n        IWorker._workerImplementation[baseClazz.name] = impl;\n    }\n\n    static _loadBrowserScript(url, resolve) {\n        // Adding the script tag to the head as suggested before\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n\n        // Then bind the event to the callback function.\n        // There are several events for cross browser compatibility.\n        // These events might occur before processing, so delay them a bit.\n        const ret = () => window.setTimeout(resolve, 100);\n        script.onreadystatechange = ret;\n        script.onload = ret;\n\n        // Fire the loading\n        head.appendChild(script);\n    }\n\n    static Proxy(clazz) {\n        const proxyClass = class extends clazz {\n            /**\n             * @param {Worker} worker\n             * @param {string} [name]\n             */\n            constructor(worker, name) {\n                super();\n                this._name = name;\n                this._messageId = 0;\n                this._worker = worker;\n                this._worker.onmessage = this._receive.bind(this);\n                /** @type {Map.<number,{resolve:Function,error:Function}>} */\n                this._waiting = new Map();\n                return this._invoke('init', [clazz.name, name]).then(() => { return this; });\n            }\n\n            _receive(msg) {\n                const cb = this._waiting.get(msg.data.id);\n                if (!cb) {\n                    Log.w(WorkerProxy, 'Unknown reply', msg);\n                } else {\n                    this._waiting.delete(msg.data.id);\n                    if (msg.data.status === 'OK') {\n                        cb.resolve(msg.data.result);\n                    } else if (msg.data.status === 'error') {\n                        cb.error(msg.data.result);\n                    }\n                }\n            }\n\n            /**\n             * @param {string} command\n             * @param {object[]} [args]\n             * @returns {Promise}\n             * @private\n             */\n            _invoke(command, args = []) {\n                return new Promise((resolve, error) => {\n                    const obj = {command: command, args: args, id: this._messageId++};\n                    this._waiting.set(obj.id, {resolve, error});\n                    this._worker.postMessage(obj);\n                });\n            }\n\n            destroy() {\n                return this._invoke('destroy');\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                proxyClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return proxyClass;\n    }\n\n    /**\n     * @param {object} clazz\n     * @return {Stub}\n     * @constructor\n     */\n    static Stub(clazz) {\n        const Stub = class extends clazz {\n            constructor() {\n                super();\n            }\n\n            _result(msg, status, result) {\n                self.postMessage({status, result, id: msg.data.id});\n            }\n\n            _onmessage(msg) {\n                try {\n                    const res = this._invoke(msg.data.command, msg.data.args);\n                    if (res instanceof Promise) {\n                        res.then((finalRes) => { this._result(msg, 'OK', finalRes); });\n                    } else {\n                        this._result(msg, 'OK', res);\n                    }\n                } catch (e) {\n                    this._result(msg, 'error', e.message || e);\n                }\n            }\n\n            init(name) {\n                this._name = name;\n                if (IWorker._insideWebWorker) {\n                    self.name = name;\n                    self.onmessage = (msg) => this._onmessage(msg);\n                }\n            }\n\n            _invoke(command, args) {\n                return this[command].apply(this, args);\n            }\n\n            destroy() {\n                if (IWorker._insideWebWorker) {\n                    self.close();\n                }\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                Stub.prototype[funcName] = function () {\n                    throw `Not implemented in IWorker Stub: ${funcName}`;\n                };\n            }\n        }\n        return Stub;\n    }\n\n    static Pool(clazz) {\n        const poolClass = class extends clazz {\n            /**\n             *\n             * @param {function(string):Promise} proxyInitializer\n             * @param {string} [name]\n             * @param {number} [size] Number of workers in this pool.\n             */\n            constructor(proxyInitializer, name = 'pool', size = 1) {\n                super();\n                /** @type {function(string):Promise} */\n                this._proxyInitializer = proxyInitializer;\n                /** @type {string} */\n                this._name = name;\n                /** @type {number} */\n                this._poolSize = size;\n                /** @type {Array} */\n                this._workers = [];\n                /** @type {Array} */\n                this._freeWorkers = [];\n                /** @type {Array.<{name:string, args:Array, resolve:function, error:function}>} */\n                this._waitingCalls = [];\n            }\n\n            async start() {\n                await this._updateToSize();\n\n                return this;\n            }\n\n            get poolSize() {\n                return this._poolSize;\n            }\n\n            set poolSize(_size) {\n                this._poolSize = _size;\n                this._updateToSize().catch(Log.w.tag(IWorker));\n            }\n\n            destroy() {\n                this._poolSize = 0;\n                return this._updateToSize();\n            }\n\n            /**\n             * @param {string} name Name of the function to call on a worker\n             * @param {Array} args Arguments to pass to the function\n             * @returns {Promise}\n             */\n            _invoke(name, args) {\n                if (IWorker._workersSupported) {\n                    return new Promise((resolve, error) => {\n                        this._waitingCalls.push({name, args, resolve, error});\n                        const worker = this._freeWorkers.shift();\n                        if (worker) {\n                            this._step(worker).catch(Log.w.tag(IWorker));\n                        }\n                    });\n                } else {\n                    return this._workers[0][name].apply(this._workers[0], args);\n                }\n            }\n\n            /**\n             * @param worker\n             * @returns {Promise.<void>}\n             * @private\n             */\n            async _step(worker) {\n                let call = this._waitingCalls.shift();\n                while (call) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        call.resolve(await worker[call.name].apply(worker, call.args));\n                    } catch (e) {\n                        call.error(e);\n                    }\n                    if (this._workers.indexOf(worker) === -1) {\n                        worker.destroy();\n                        return;\n                    }\n                    call = this._waitingCalls.shift();\n                }\n                this._freeWorkers.push(worker);\n            }\n\n            async _updateToSize() {\n                if (typeof Worker === 'undefined' && this._poolSize > 1) {\n                    Log.d(IWorker, 'Pool of size larger than 1 requires WebWorker support.');\n                    this._poolSize = 1;\n                }\n\n                const workerPromises = [];\n                while (this._workers.length + workerPromises.length < this._poolSize) {\n                    workerPromises.push(this._proxyInitializer(`${this._name}#${this._workers.length + workerPromises.length}`));\n                }\n                const createdWorkers = await Promise.all(workerPromises);\n                for (const worker of createdWorkers) {\n                    this._workers.push(worker);\n                    this._step(worker).catch(Log.w.tag(IWorker));\n                }\n\n                while (this._workers.length > this._poolSize) {\n                    const worker = this._freeWorkers.shift() || this._workers.pop();\n                    const idx = this._workers.indexOf(worker);\n                    if (idx >= 0) {\n                        // This was a free worker, also remove it from the worker list and destroy it now.\n                        this._workers.splice(idx, 1);\n                        worker.destroy();\n                    }\n                }\n                return this;\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                poolClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return poolClass;\n    }\n}\n\nIWorker._moduleLoadedCallbacks = {};\nIWorker._workerImplementation = {};\nClass.register(IWorker);\n","class WasmHelper {\n\n    static async doImportBrowser() {\n        if (PlatformUtils.isNodeJs()) return;\n        if (WasmHelper._importStarted) {\n            Log.e(WasmHelper, 'doImportBrowser invoked twice');\n            return;\n        }\n        WasmHelper._importStarted = true;\n        if (await WasmHelper.importWasmBrowser('worker-wasm.wasm')) {\n            await WasmHelper.importScriptBrowser('worker-wasm.js');\n        } else {\n            await WasmHelper.importScriptBrowser('worker-js.js');\n        }\n        WasmHelper._importFinished = true;\n    }\n\n    static doImportNodeJs() {\n        if (!PlatformUtils.isNodeJs()) return;\n        if (WasmHelper.importWasmNodeJs('worker-wasm.wasm')) {\n            WasmHelper.importScriptNodeJs('worker-wasm.js');\n        } else {\n            WasmHelper.importScriptNodeJs('worker-js.js');\n        }\n    }\n\n    /**\n     * @param {string} wasm\n     * @param {string} module\n     * @returns {Promise.<boolean>}\n     */\n    static importWasmBrowser(wasm, module = 'Module') {\n        wasm = WasmHelper._adjustWasmPath(wasm);\n        if (!WasmHelper._global.WebAssembly) {\n            Log.w(WasmHelper, 'No support for WebAssembly available.');\n            return Promise.resolve(false);\n        }\n\n        return new Promise((resolve) => {\n            try {\n                const xhr = new XMLHttpRequest();\n                xhr.open('GET', wasm, true);\n                xhr.responseType = 'arraybuffer';\n                xhr.onload = function () {\n                    WasmHelper._global[module] = WasmHelper._global[module] || {};\n                    WasmHelper._global[module].wasmBinary = xhr.response;\n                    resolve(true);\n                };\n                xhr.onerror = function () {\n                    Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}`);\n                    resolve(false);\n                };\n                xhr.send(null);\n            } catch (e) {\n                Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}`);\n                resolve(false);\n            }\n        });\n    }\n\n    static importWasmNodeJs(wasm, module = 'Module') {\n        wasm = WasmHelper._adjustWasmPath(wasm);\n        if (!WasmHelper._global.WebAssembly) {\n            Log.w(WasmHelper, 'No support for WebAssembly available.');\n            return false;\n        }\n\n        const toUint8Array = function (buf) {\n            const u = new Uint8Array(buf.length);\n            for (let i = 0; i < buf.length; ++i) {\n                u[i] = buf[i];\n            }\n            return u;\n        };\n        const fs = require('fs');\n        try {\n            const data = fs.readFileSync(wasm);\n            WasmHelper._global[module] = WasmHelper._global[module] || {};\n            WasmHelper._global[module].wasmBinary = toUint8Array(data);\n            return true;\n        } catch (e) {\n            Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}: ${e}`);\n            return false;\n        }\n    }\n\n    static importScriptBrowser(script, module = 'Module') {\n        if (module && WasmHelper._global[module] && WasmHelper._global[module].asm) return false;\n        script = WasmHelper._adjustScriptPath(script);\n\n        const moduleSettings = WasmHelper._global[module] || {};\n        return new Promise(async (resolve, reject) => {\n            if (module) {\n                moduleSettings.onRuntimeInitialized = () => resolve(true);\n            }\n            if (typeof importScripts === 'function') {\n                await new Promise((resolve) => {\n                    WasmHelper._moduleLoadedCallbacks[module] = resolve;\n                    importScripts(script);\n                });\n                WasmHelper._global[module] = WasmHelper._global[module](moduleSettings);\n                if (!module) resolve(true);\n            } else if (typeof window === 'object') {\n                await new Promise((resolve) => {\n                    WasmHelper._moduleLoadedCallbacks[module] = resolve;\n                    WasmHelper._loadBrowserScript(script);\n                });\n                WasmHelper._global[module] = WasmHelper._global[module](moduleSettings);\n                if (!module) resolve(true);\n            } else if (typeof require === 'function') {\n                WasmHelper._global[module] = require(script)(moduleSettings);\n                if (!module) resolve(true);\n            } else {\n                reject('No way to load scripts.');\n            }\n        });\n    }\n\n    static importScriptNodeJs(script, module = 'Module') {\n        if (module && WasmHelper._global[module] && WasmHelper._global[module].asm) return false;\n        script = WasmHelper._adjustScriptPath(script);\n\n        const moduleSettings = WasmHelper._global[module] || {};\n\n        if (typeof require === 'function') {\n            WasmHelper._global[module] = require(script)(moduleSettings);\n            if (!module) return true;\n        }\n        return false;\n    }\n\n    static fireModuleLoaded(module = 'Module') {\n        if (typeof WasmHelper._moduleLoadedCallbacks[module] === 'function') {\n            WasmHelper._moduleLoadedCallbacks[module]();\n            WasmHelper._moduleLoadedCallbacks[module] = null;\n        }\n    }\n\n    static _loadBrowserScript(url) {\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        head.appendChild(script);\n    }\n\n    static _adjustWasmPath(wasm) {\n        if (typeof Nimiq !== 'undefined' && Nimiq._path) wasm = `${Nimiq._path}${wasm}`;\n        if (typeof __dirname === 'string' && wasm.indexOf('/') === -1) wasm = `${__dirname}/${wasm}`;\n        return wasm;\n    }\n\n    static _adjustScriptPath(script) {\n        if (typeof Nimiq !== 'undefined' && Nimiq._path) script = `${Nimiq._path}${script}`;\n        if (typeof __dirname === 'string' && script.indexOf('/') === -1) script = `${__dirname}/${script}`;\n        return script;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n}\nWasmHelper._moduleLoadedCallbacks = {};\n\nClass.register(WasmHelper);\n\n","/**\n * @interface\n */\nclass CryptoWorker {\n    static get lib() { return CryptoLib.instance; }\n\n    /**\n     * @returns {Promise.<CryptoWorker>}\n     */\n    static async getInstanceAsync() {\n        if (!CryptoWorker._workerAsync) {\n            CryptoWorker._workerAsync = await IWorker.startWorkerPoolForProxy(CryptoWorker, 'crypto', 4);\n        }\n        return CryptoWorker._workerAsync;\n    }\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeArgon2d(input) {}\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Promise.<Array.<Uint8Array>>}\n     */\n    async computeArgon2dBatch(inputs) {}\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Promise.<Uint8Array>}\n     */\n    async kdf(key, salt, iterations) {}\n\n    /**\n     * @param {Uint8Array} block\n     * @param {Array.<bool>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @param {number} networkId\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(block, transactionValid, timeNow, genesisHash, networkId) {}\n}\n/** @type {CryptoWorker} */\nCryptoWorker._workerAsync = null;\n\nClass.register(CryptoWorker);\n","class CryptoWorkerImpl extends IWorker.Stub(CryptoWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        await this._superInit.call(this, name);\n        await WasmHelper.doImportBrowser();\n        CryptoWorker._workerAsync = this;\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    computeArgon2d(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n            const res = NodeNative.node_argon2(out, new Uint8Array(input), 512);\n            if (res !== 0) {\n                throw res;\n            }\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Array.<Uint8Array>}\n     */\n    computeArgon2dBatch(inputs) {\n        const hashes = [];\n        if (PlatformUtils.isNodeJs()) {\n            for(const input of inputs) {\n                const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n                const res = NodeNative.node_argon2(out, new Uint8Array(input), 512);\n                if (res !== 0) {\n                    throw res;\n                }\n                hashes.push(out);\n            }\n            return hashes;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const stackTmp = Module.stackSave();\n                for (const input of inputs) {\n                    Module.stackRestore(stackTmp);\n                    const wasmIn = Module.stackAlloc(input.length);\n                    new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                    const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n                    if (res !== 0) {\n                        throw res;\n                    }\n                    const hash = new Uint8Array(hashSize);\n                    hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                    hashes.push(hash);\n                }\n                return hashes;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Uint8Array}\n     */\n    kdf(key, salt, iterations) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n            const res = NodeNative.node_kdf(out, new Uint8Array(key), new Uint8Array(salt), 512, iterations);\n            if (res !== 0) {\n                throw res;\n            }\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(key.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, key.length).set(key);\n                const wasmSalt = Module.stackAlloc(salt.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmSalt, salt.length).set(salt);\n                const res = Module._nimiq_kdf(wasmOut, wasmIn, key.length, wasmSalt, salt.length, 512, iterations);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} blockSerialized\n     * @param {Array.<boolean|undefined>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @param {number} networkId\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(blockSerialized, transactionValid, timeNow, genesisHash, networkId) {\n        // The worker only uses a stub genesis config.\n        GenesisConfig = {\n            GENESIS_HASH: Hash.unserialize(new SerialBuffer(genesisHash)),\n            NETWORK_ID: networkId\n        };\n\n        const block = Block.unserialize(new SerialBuffer(blockSerialized));\n        for (let i = 0; i < transactionValid.length; i++) {\n            block.body.transactions[i]._valid = transactionValid[i];\n        }\n\n        const valid = await block._verify(timeNow);\n        const pow = await block.header.pow();\n        const interlinkHash = block.interlink.hash();\n        const bodyHash = block.body.hash();\n        return { valid: valid, pow: pow.serialize(), interlinkHash: interlinkHash.serialize(), bodyHash: bodyHash.serialize() };\n    }\n}\n\nIWorker.prepareForWorkerUse(CryptoWorker, new CryptoWorkerImpl());\n","class NumberUtils {\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint8(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT8_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint16(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT16_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint32(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT32_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint64(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT64_MAX;\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint32() {\n        return Math.floor(Math.random() * (NumberUtils.UINT32_MAX + 1));\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint64() {\n        return Math.floor(Math.random() * (NumberUtils.UINT64_MAX + 1));\n    }\n}\n\nNumberUtils.UINT8_MAX = 255;\nNumberUtils.UINT16_MAX = 65535;\nNumberUtils.UINT32_MAX = 4294967295;\nNumberUtils.UINT64_MAX = Number.MAX_SAFE_INTEGER;\n//Object.freeze(NumberUtils);\nClass.register(NumberUtils);\n","class BufferUtils {\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toAscii(buffer) {\n        return String.fromCharCode.apply(null, new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} string\n     * @return {Uint8Array}\n     */\n    static fromAscii(string) {\n        const buf = new Uint8Array(string.length);\n        for (let i = 0; i < string.length; ++i) {\n            buf[i] = string.charCodeAt(i);\n        }\n        return buf;\n    }\n\n    static _codePointTextDecoder(u8) {\n        if (typeof TextDecoder === 'undefined') throw new Error('TextDecoder not supported');\n        if (BufferUtils._ISO_8859_15_DECODER === null) throw new Error('TextDecoder does not supprot iso-8859-15');\n        if (BufferUtils._ISO_8859_15_DECODER === undefined) {\n            try {\n                BufferUtils._ISO_8859_15_DECODER = new TextDecoder('iso-8859-15');\n            } finally {\n                BufferUtils._ISO_8859_15_DECODER = null;\n            }\n        }\n        return BufferUtils._ISO_8859_15_DECODER.decode(u8)\n            .replace('€', '¤').replace('Š', '¦').replace('š', '¨').replace('Ž', '´')\n            .replace('ž', '¸').replace('Œ', '¼').replace('œ', '½').replace('Ÿ', '¾');\n    }\n\n    static _tripletToBase64(num) {\n        return BufferUtils._BASE64_LOOKUP[num >> 18 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 12 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 6 & 0x3F] + BufferUtils._BASE64_LOOKUP[num & 0x3F];\n    }\n\n    static _base64encodeChunk(u8, start, end) {\n        let tmp;\n        const output = [];\n        for (let i = start; i < end; i += 3) {\n            tmp = ((u8[i] << 16) & 0xFF0000) + ((u8[i + 1] << 8) & 0xFF00) + (u8[i + 2] & 0xFF);\n            output.push(BufferUtils._tripletToBase64(tmp));\n        }\n        return output.join('');\n    }\n\n    static _base64fromByteArray(u8) {\n        let tmp;\n        const len = u8.length;\n        const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        let output = '';\n        const parts = [];\n        const maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n            parts.push(BufferUtils._base64encodeChunk(u8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n            tmp = u8[len - 1];\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 2];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 4) & 0x3F];\n            output += '==';\n        } else if (extraBytes === 2) {\n            tmp = (u8[len - 2] << 8) + (u8[len - 1]);\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 10];\n            output += BufferUtils._BASE64_LOOKUP[(tmp >> 4) & 0x3F];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 2) & 0x3F];\n            output += '=';\n        }\n\n        parts.push(output);\n\n        return parts.join('');\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64(buffer) {\n        if (PlatformUtils.isNodeJs()) {\n            return new Buffer(buffer).toString('base64');\n        } else if (typeof TextDecoder !== 'undefined' && BufferUtils._ISO_8859_15_DECODER !== null) {\n            try {\n                return btoa(BufferUtils._codePointTextDecoder(new Uint8Array(buffer)));\n            } catch (e) {\n                // Disabled itself\n            }\n        }\n\n        return BufferUtils._base64fromByteArray(new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64Url(buffer) {\n        return BufferUtils.toBase64(buffer).replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '.');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64Url(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64.replace(/_/g, '/').replace(/-/g, '+').replace(/\\./g, '=')), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {Uint8Array} buf\n     * @param {string} [alphabet] Alphabet to use\n     * @return {string}\n     */\n    static toBase32(buf, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        let shift = 3, carry = 0, byte, symbol, i, res = '';\n\n        for (i = 0; i < buf.length; i++) {\n            byte = buf[i];\n            symbol = carry | (byte >> shift);\n            res += alphabet[symbol & 0x1f];\n\n            if (shift > 5) {\n                shift -= 5;\n                symbol = byte >> shift;\n                res += alphabet[symbol & 0x1f];\n            }\n\n            shift = 5 - shift;\n            carry = byte << shift;\n            shift = 8 - shift;\n        }\n\n        if (shift !== 3) {\n            res += alphabet[carry & 0x1f];\n        }\n\n        while (res.length % 8 !== 0 && alphabet.length === 33) {\n            res += alphabet[32];\n        }\n\n        return res;\n    }\n\n    /**\n     * @param {string} base32\n     * @param {string} [alphabet] Alphabet to use\n     * @return {Uint8Array}\n     */\n    static fromBase32(base32, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        const charmap = [];\n        alphabet.toUpperCase().split('').forEach((c, i) => {\n            if (!(c in charmap)) charmap[c] = i;\n        });\n\n        let symbol, shift = 8, carry = 0, buf = [];\n        base32.toUpperCase().split('').forEach((char) => {\n            // ignore padding\n            if (alphabet.length === 33 && char === alphabet[32]) return;\n\n            symbol = charmap[char] & 0xff;\n\n            shift -= 5;\n            if (shift > 0) {\n                carry |= symbol << shift;\n            } else if (shift < 0) {\n                buf.push(carry | (symbol >> -shift));\n                shift += 8;\n                carry = (symbol << shift) & 0xff;\n            } else {\n                buf.push(carry | symbol);\n                shift = 8;\n                carry = 0;\n            }\n        });\n\n        if (shift !== 8 && carry !== 0) {\n            buf.push(carry);\n        }\n\n        return new Uint8Array(buf);\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toHex(buffer) {\n        let hex = '';\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            hex += BufferUtils.HEX_ALPHABET[code >>> 4];\n            hex += BufferUtils.HEX_ALPHABET[code & 0x0F];\n        }\n        return hex;\n    }\n\n    /**\n     * @param {string} hex\n     * @return {SerialBuffer}\n     */\n    static fromHex(hex) {\n        hex = hex.trim();\n        if (!StringUtils.isHexBytes(hex)) return null;\n        return new SerialBuffer(Uint8Array.from(hex.match(/.{2}/g) || [], byte => parseInt(byte, 16)));\n    }\n\n    /**\n     * @template T\n     * @param {T} a\n     * @param {*} b\n     * @return {T}\n     */\n    static concatTypedArrays(a, b) {\n        const c = new (a.constructor)(a.length + b.length);\n        c.set(a, 0);\n        c.set(b, a.length);\n        return c;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        if (a.length !== b.length) return false;\n        const viewA = new Uint8Array(a);\n        const viewB = new Uint8Array(b);\n        for (let i = 0; i < a.length; i++) {\n            if (viewA[i] !== viewB[i]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {number} -1 if a is smaller than b, 1 if a is larger than b, 0 if a equals b.\n     */\n    static compare(a, b) {\n        if (a.length < b.length) return -1;\n        if (a.length > b.length) return 1;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] < b[i]) return -1;\n            if (a[i] > b[i]) return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @return {Uint8Array}\n     */\n    static xor(a, b) {\n        const res = new Uint8Array(a.byteLength);\n        for (let i = 0; i < a.byteLength; ++i) {\n            res[i] = a[i] ^ b[i];\n        }\n        return res;\n    }\n}\nBufferUtils.BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nBufferUtils.BASE32_ALPHABET = {\n    RFC4648: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    RFC4648_HEX: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    NIMIQ: '0123456789ABCDEFGHJKLMNPQRSTUVXY'\n};\nBufferUtils.HEX_ALPHABET = '0123456789abcdef';\nBufferUtils._BASE64_LOOKUP = [];\nfor (let i = 0, len = BufferUtils.BASE64_ALPHABET.length; i < len; ++i) {\n    BufferUtils._BASE64_LOOKUP[i] = BufferUtils.BASE64_ALPHABET[i];\n}\n\nClass.register(BufferUtils);\n","class SerialBuffer extends Uint8Array {\n    /**\n     * @param {*} bufferOrArrayOrLength\n     */\n    constructor(bufferOrArrayOrLength) {\n        super(bufferOrArrayOrLength);\n        this._view = new DataView(this.buffer);\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} start\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    subarray(start, end) {\n        return ArrayUtils.subarray(this, start, end);\n    }\n\n    /** @type {number} */\n    get readPos() {\n        return this._readPos;\n    }\n\n    /** @type {number} */\n    set readPos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid readPos ${value}`;\n        this._readPos = value;\n    }\n\n    /** @type {number} */\n    get writePos() {\n        return this._writePos;\n    }\n\n    /** @type {number} */\n    set writePos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid writePos ${value}`;\n        this._writePos = value;\n    }\n\n    /**\n     * Resets the read and write position of the buffer to zero.\n     * @returns {void}\n     */\n    reset() {\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} length\n     * @return {Uint8Array}\n     */\n    read(length) {\n        const value = this.subarray(this._readPos, this._readPos + length);\n        this._readPos += length;\n        return value;\n    }\n\n    /**\n     * @param {*} array\n     */\n    write(array) {\n        this.set(array, this._writePos);\n        this._writePos += array.byteLength;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint8() {\n        return this._view.getUint8(this._readPos++);\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint8(value) {\n        this._view.setUint8(this._writePos++, value);\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint16() {\n        const value = this._view.getUint16(this._readPos);\n        this._readPos += 2;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint16(value) {\n        this._view.setUint16(this._writePos, value);\n        this._writePos += 2;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint32() {\n        const value = this._view.getUint32(this._readPos);\n        this._readPos += 4;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint32(value) {\n        this._view.setUint32(this._writePos, value);\n        this._writePos += 4;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint64() {\n        const value = this._view.getUint32(this._readPos) * Math.pow(2, 32) + this._view.getUint32(this._readPos + 4);\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint64(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._view.setUint32(this._writePos, Math.floor(value / Math.pow(2, 32)));\n        this._view.setUint32(this._writePos + 4, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @return {number}\n     */\n    readVarUint() {\n        const value = this.readUint8();\n        if (value < 0xFD) {\n            return value;\n        } else if (value === 0xFD) {\n            return this.readUint16();\n        } else if (value === 0xFE) {\n            return this.readUint32();\n        } else /*if (value === 0xFF)*/ {\n            return this.readUint64();\n        }\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeVarUint(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            this.writeUint8(value);\n        } else if (value <= 0xFFFF) {\n            this.writeUint8(0xFD);\n            this.writeUint16(value);\n        } else if (value <= 0xFFFFFFFF) {\n            this.writeUint8(0xFE);\n            this.writeUint32(value);\n        } else {\n            this.writeUint8(0xFF);\n            this.writeUint64(value);\n        }\n    }\n\n    /**\n     * @param {number} value\n     * @returns {number}\n     */\n    static varUintSize(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            return 1;\n        } else if (value <= 0xFFFF) {\n            return 3;\n        } else if (value <= 0xFFFFFFFF) {\n            return 5;\n        } else {\n            return 9;\n        }\n    }\n\n    /**\n     * @return {number}\n     */\n    readFloat64() {\n        const value = this._view.getFloat64(this._readPos);\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeFloat64(value) {\n        this._view.setFloat64(this._writePos, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readString(length) {\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writeString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length !== length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readPaddedString(length) {\n        const bytes = this.read(length);\n        let i = 0;\n        while (i < length && bytes[i] !== 0x0) i++;\n        const view = new Uint8Array(bytes.buffer, bytes.byteOffset, i);\n        return BufferUtils.toAscii(view);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writePaddedString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length > length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n        const padding = length - bytes.byteLength;\n        this.write(new Uint8Array(padding));\n    }\n\n    /**\n     * @return {string}\n     */\n    readVarLengthString() {\n        const length = this.readUint8();\n        if (this._readPos + length > this.length) throw 'Malformed length';\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     */\n    writeVarLengthString(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        const bytes = BufferUtils.fromAscii(value);\n        this.writeUint8(bytes.byteLength);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @returns {number}\n     */\n    static varLengthStringSize(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        return /*length*/ 1 + value.length;\n    }\n}\nClass.register(SerialBuffer);\n","/**\n * @interface\n */\nclass MinerWorker {\n    /**\n     * @param blockHeader\n     * @param compact\n     * @param minNonce\n     * @param maxNonce\n     * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n     */\n    async multiMine(blockHeader, compact, minNonce, maxNonce) {}\n}\nClass.register(MinerWorker);\n","class MinerWorkerImpl extends IWorker.Stub(MinerWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        await this._superInit.call(this, name);\n        await WasmHelper.doImportBrowser();\n    }\n\n    async multiMine(input, compact, minNonce, maxNonce) {\n        const hash = new Uint8Array(32);\n        let wasmOut, wasmIn;\n        try {\n            wasmOut = Module._malloc(hash.length);\n            wasmIn = Module._malloc(input.length);\n            Module.HEAPU8.set(input, wasmIn);\n            const nonce = Module._nimiq_argon2_target(wasmOut, wasmIn, input.length, compact, minNonce, maxNonce, 512);\n            if (nonce === maxNonce) return false;\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hash.length));\n            return {hash, nonce};\n        } catch (e) {\n            Log.w(MinerWorkerImpl, e);\n            throw e;\n        } finally {\n            if (wasmOut !== undefined) Module._free(wasmOut);\n            if (wasmIn !== undefined) Module._free(wasmIn);\n        }\n    }\n}\n\nIWorker.prepareForWorkerUse(MinerWorker, new MinerWorkerImpl());\n","/**\n *\n */\nclass MinerWorkerPool extends IWorker.Pool(MinerWorker) {\n    constructor(size = 1) {\n        super((name) => IWorker.startWorkerForProxy(MinerWorker, name), 'miner', size);\n        /** @type {boolean} */\n        this._miningEnabled = false;\n        /** @type {Array.<{minNonce: number, maxNonce: number}>} */\n        this._activeNonces = [];\n        /** @type {Block} */\n        this._block = null;\n        /** @type {number} */\n        this._noncesPerRun = 256;\n        /** @type {Observable} */\n        this._observable = new Observable();\n        /** @type {number} */\n        this._shareCompact = Policy.BLOCK_TARGET_MAX;\n        /** @type {number} */\n        this._runsPerCycle = Infinity;\n        /** @type {number} */\n        this._cycleWait = 100;\n\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superUpdateToSize = super._updateToSize;\n\n        if (PlatformUtils.isNodeJs()) {\n            /**\n             * @param {SerialBuffer} blockHeader\n             * @param {number} compact\n             * @param {number} minNonce\n             * @param {number} maxNonce\n             * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n             */\n            this.multiMine = function (blockHeader, compact, minNonce, maxNonce) {\n                return new Promise((resolve, fail) => {\n                    NodeNative.node_argon2_target_async(async (nonce) => {\n                        try {\n                            if (nonce === maxNonce) {\n                                resolve(false);\n                            } else {\n                                blockHeader.writePos -= 4;\n                                blockHeader.writeUint32(nonce);\n                                const hash = await (await CryptoWorker.getInstanceAsync()).computeArgon2d(blockHeader);\n                                resolve({hash, nonce});\n                            }\n                        } catch (e) {\n                            fail(e);\n                        }\n                    }, blockHeader, compact, minNonce, maxNonce, 512);\n                });\n            };\n        }\n    }\n\n    /**\n     * @type {number}\n     */\n    get noncesPerRun() {\n        return this._noncesPerRun;\n    }\n\n    /**\n     * @param {number} nonces\n     */\n    set noncesPerRun(nonces) {\n        this._noncesPerRun = nonces;\n    }\n\n    /**\n     * @type {number}\n     */\n    get runsPerCycle() {\n        return this._runsPerCycle;\n    }\n\n    /**\n     * @param {number} runsPerCycle\n     */\n    set runsPerCycle(runsPerCycle) {\n        this._runsPerCycle = runsPerCycle;\n    }\n\n    /**\n     * @type {number}\n     */\n    get cycleWait() {\n        return this._cycleWait;\n    }\n\n    /**\n     * @param {number} cycleWait\n     */\n    set cycleWait(cycleWait) {\n        this._cycleWait = cycleWait;\n    }\n\n    /**\n     * @param {string} type\n     * @param {Function} callback\n     * @return {number}\n     */\n    on(type, callback) { this._observable.on(type, callback); }\n\n    /**\n     * @param {string} type\n     * @param {number} id\n     */\n    off(type, id) { this._observable.off(type, id); }\n\n    /**\n     * @param {Block} block\n     * @param {number} [shareCompact] target of a share, in compact format.\n     */\n    async startMiningOnBlock(block, shareCompact = block.nBits) {\n        this._block = block;\n        this._shareCompact = shareCompact;\n        if (!this._miningEnabled) {\n            await this._updateToSize();\n            this._activeNonces = [];\n            this._miningEnabled = true;\n            for (let i = 0; i < this.poolSize; ++i) {\n                this._startMiner();\n            }\n        } else {\n            this._activeNonces = [{minNonce:0, maxNonce:0}];\n        }\n    }\n\n    stop() {\n        this._miningEnabled = false;\n    }\n\n    async _updateToSize() {\n        if (!PlatformUtils.isNodeJs()) {\n            await this._superUpdateToSize.call(this);\n        }\n\n        while (this._miningEnabled && this._activeNonces.length < this.poolSize) {\n            this._startMiner();\n        }\n    }\n\n    _startMiner() {\n        const minNonce = this._activeNonces.length === 0 ? 0 : Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n        const maxNonce = minNonce + this._noncesPerRun;\n        const nonceRange = {minNonce, maxNonce};\n        this._activeNonces.push(nonceRange);\n        this._singleMiner(nonceRange).catch((e) => Log.e(MinerWorkerPool, e));\n    }\n\n    /**\n     * @param {{minNonce: number, maxNonce: number}} nonceRange\n     * @return {Promise.<void>}\n     * @private\n     */\n    async _singleMiner(nonceRange) {\n        let i = 0;\n        while (this._miningEnabled && (IWorker.areWorkersAsync || PlatformUtils.isNodeJs() || i === 0) && i < this._runsPerCycle) {\n            i++;\n            const block = this._block;\n            const result = await this.multiMine(block.header.serialize(), this._shareCompact, nonceRange.minNonce, nonceRange.maxNonce);\n            if (result) {\n                const hash = new Hash(result.hash);\n                this._observable.fire('share', {\n                    block,\n                    nonce: result.nonce,\n                    hash\n                });\n            } else {\n                this._observable.fire('no-share', {\n                    nonce: nonceRange.maxNonce\n                });\n            }\n            if (this._activeNonces.length > this.poolSize) {\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1);\n                return;\n            } else {\n                const newMin = Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n                const newRange = {minNonce: newMin, maxNonce: newMin + this._noncesPerRun};\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1, newRange);\n                nonceRange = newRange;\n            }\n        }\n        if (this._miningEnabled) {\n            setTimeout(() => this._singleMiner(nonceRange), this._cycleWait);\n        }\n    }\n}\n\nClass.register(MinerWorkerPool);\n","class GenesisConfig {}\nClass.register(GenesisConfig);\n","class ArrayUtils {\n    /**\n     * @template T\n     * @param {Array.<T>} arr\n     * @return {T}\n     */\n    static randomElement(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n\n    /**\n     * @param {Uint8Array} uintarr\n     * @param {number} begin\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    static subarray(uintarr, begin, end) {\n        function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n        if (begin === undefined) { begin = 0; }\n        if (end === undefined) { end = uintarr.byteLength; }\n\n        begin = clamp(begin, 0, uintarr.byteLength);\n        end = clamp(end, 0, uintarr.byteLength);\n\n        let len = end - begin;\n        if (len < 0) {\n            len = 0;\n        }\n\n        return new Uint8Array(uintarr.buffer, uintarr.byteOffset + begin, len);\n    }\n\n    /**\n     * @param {Array} list\n     * @param {number} k\n     * @return {Generator}\n     */\n    static *k_combinations(list, k) {\n        const n = list.length;\n        // Shortcut:\n        if (k > n) {\n            return;\n        }\n        const indices = Array.from(new Array(k), (x,i) => i);\n        yield indices.map(i => list[i]);\n        const reverseRange = Array.from(new Array(k), (x,i) => k-i-1);\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n            let i = k-1, found = false;\n            for (i of reverseRange) {\n                if (indices[i] !== i + n - k) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return;\n            }\n            indices[i] += 1;\n            for (const j of Array.from(new Array(k-i-1), (x,k) => i+k+1)) {\n                indices[j] = indices[j-1] + 1;\n            }\n            yield indices.map(i => list[i]);\n        }\n    }\n}\nClass.register(ArrayUtils);\n","class Assert {\n    /**\n     * @param {boolean} condition\n     * @param {string} [message]\n     * @returns {void}\n     */\n    static that(condition, message = 'Assertion failed') {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nClass.register(Assert);\n","class MerkleTree {\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    static computeRoot(values, fnHash = MerkleTree._hash) {\n        return MerkleTree._computeRoot(values, fnHash);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} fnHash\n     * @returns {Hash}\n     * @private\n     */\n    static _computeRoot(values, fnHash) {\n        const len = values.length;\n        if (len === 0) {\n            return Hash.light(new Uint8Array(0));\n        }\n        if (len === 1) {\n            return fnHash(values[0]);\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const leftHash = MerkleTree._computeRoot(left, fnHash);\n        const rightHash = MerkleTree._computeRoot(right, fnHash);\n        return Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n    }\n\n    /**\n     * @param {Hash|Uint8Array|{hash: function():Hash}|{serialize: function():Uint8Array}} o\n     * @returns {Hash}\n     * @private\n     */\n    static _hash(o) {\n        if (o instanceof Hash) {\n            return o;\n        }\n        if (typeof o.hash === 'function') {\n            return o.hash();\n        }\n        if (typeof o.serialize === 'function') {\n            return Hash.light(o.serialize());\n        }\n        if (o instanceof Uint8Array) {\n            return Hash.light(o);\n        }\n        throw new Error('MerkleTree objects must be Uint8Array or have a .hash()/.serialize() method');\n    }\n}\nClass.register(MerkleTree);\n","class MerklePath {\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     */\n    constructor(nodes) {\n        if (!Array.isArray(nodes) || !NumberUtils.isUint8(nodes.length)\n            || nodes.some(it => !(it instanceof MerklePathNode))) throw new Error('Malformed nodes');\n        /**\n         * @type {Array.<MerklePathNode>}\n         * @private\n         */\n        this._nodes = nodes;\n    }\n\n    /**\n     * @param {Array} values\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerklePath}\n     */\n    static compute(values, leafValue, fnHash = MerkleTree._hash) {\n        const leafHash = fnHash(leafValue);\n        const path = [];\n        MerklePath._compute(values, leafHash, path, fnHash);\n        return new MerklePath(path);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Hash} leafHash\n     * @param {Array.<MerklePathNode>} path\n     * @param {function(o: *):Hash} fnHash\n     * @returns {{containsLeaf:boolean, inner:Hash}}\n     * @private\n     */\n    static _compute(values, leafHash, path, fnHash) {\n        const len = values.length;\n        let hash;\n        if (len === 0) {\n            hash = Hash.light(new Uint8Array(0));\n            return {containsLeaf: false, inner: hash};\n        }\n        if (len === 1) {\n            hash = fnHash(values[0]);\n            return {containsLeaf: hash.equals(leafHash), inner: hash};\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const {containsLeaf: leftLeaf, inner: leftHash} = MerklePath._compute(left, leafHash, path, fnHash);\n        const {containsLeaf: rightLeaf, inner: rightHash} = MerklePath._compute(right, leafHash, path, fnHash);\n        hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n\n        if (leftLeaf) {\n            path.push(new MerklePathNode(rightHash, false));\n            return {containsLeaf: true, inner: hash};\n        } else if (rightLeaf) {\n            path.push(new MerklePathNode(leftHash, true));\n            return {containsLeaf: true, inner: hash};\n        }\n\n        return {containsLeaf: false, inner: hash};\n    }\n\n    /**\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    computeRoot(leafValue, fnHash = MerkleTree._hash) {\n        /** @type {Hash} */\n        let root = fnHash(leafValue);\n        for (const node of this._nodes) {\n            const left = node.left;\n            const hash = node.hash;\n            const concat = new SerialBuffer(hash.serializedSize * 2);\n            if (left) hash.serialize(concat);\n            root.serialize(concat);\n            if (!left) hash.serialize(concat);\n            root = Hash.light(concat);\n        }\n        return root;\n    }\n\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _compress(nodes) {\n        const count = nodes.length;\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = new Uint8Array(leftBitsSize);\n\n        for (let i = 0; i < count; i++) {\n            if (nodes[i].left) {\n                leftBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return leftBits;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MerklePath}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint8();\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = buf.read(leftBitsSize);\n\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            const left = (leftBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            const hash = Hash.unserialize(buf);\n            nodes.push(new MerklePathNode(hash, left));\n        }\n        return new MerklePath(nodes);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._nodes.length);\n        buf.write(MerklePath._compress(this._nodes));\n\n        for (const node of this._nodes) {\n            node.hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        const leftBitsSize = Math.ceil(this._nodes.length / 8);\n        return /*count*/ 1\n            + leftBitsSize\n            + this._nodes.reduce((sum, node) => sum + node.hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {MerklePath} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePath\n            && this._nodes.length === o._nodes.length\n            && this._nodes.every((node, i) => node.equals(o._nodes[i]));\n    }\n\n    /** @type {Array.<MerklePathNode>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\nClass.register(MerklePath);\n\nclass MerklePathNode {\n    /**\n     * @param {Hash} hash\n     * @param {boolean} left\n     */\n    constructor(hash, left) {\n        this._hash = hash;\n        this._left = left;\n    }\n\n    /** @type {Hash} */\n    get hash() {\n        return this._hash;\n    }\n\n    /** @type {boolean} */\n    get left() {\n        return this._left;\n    }\n\n    /**\n     * @param {MerklePathNode} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePathNode\n            && this._hash.equals(o.hash)\n            && this._left === o.left;\n    }\n}\nClass.register(MerklePathNode);\n","class Policy {\n    /**\n     * Convert Nimiq decimal to Number of Satoshis.\n     * @param {number} coins Nimiq count in decimal\n     * @return {number} Number of Satoshis\n     */\n    static coinsToSatoshis(coins) {\n        return Math.round(coins * Policy.SATOSHIS_PER_COIN);\n    }\n\n    /**\n     * Convert Number of Satoshis to Nimiq decimal.\n     * @param {number} satoshis Number of Satoshis.\n     * @return {number} Nimiq count in decimal.\n     */\n    static satoshisToCoins(satoshis) {\n        return satoshis / Policy.SATOSHIS_PER_COIN;\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static supplyAfter(blockHeight) {\n        // Calculate last entry in supply cache that is below blockHeight.\n        let startHeight = Math.floor(blockHeight / Policy._supplyCacheInterval) * Policy._supplyCacheInterval;\n        startHeight = Math.max(0, Math.min(startHeight, Policy._supplyCacheMax));\n\n        // Calculate respective block for the last entry of the cache and the targeted height.\n        const startI = startHeight / Policy._supplyCacheInterval;\n        const endI = Math.floor(blockHeight / Policy._supplyCacheInterval);\n\n        // The starting supply is the initial supply at the beginning and a cached value afterwards.\n        let supply = startHeight === 0 ? Policy.INITIAL_SUPPLY : Policy._supplyCache.get(startHeight);\n        // Use and update cache.\n        for (let i = startI; i < endI; ++i) {\n            startHeight = i * Policy._supplyCacheInterval;\n            // Since the cache stores the supply *before* a certain block, subtract one.\n            const endHeight = (i + 1) * Policy._supplyCacheInterval - 1;\n            supply = Policy._supplyAfter(supply, endHeight, startHeight);\n            // Don't forget to add one again.\n            Policy._supplyCache.set(endHeight + 1, supply);\n            Policy._supplyCacheMax = endHeight + 1;\n        }\n\n        // Calculate remaining supply (this also adds the block reward for endI*interval).\n        return Policy._supplyAfter(supply, blockHeight, endI * Policy._supplyCacheInterval);\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} initialSupply\n     * @param {number} blockHeight\n     * @param {number} [startHeight]\n     * @return {number}\n     */\n    static _supplyAfter(initialSupply, blockHeight, startHeight=0) {\n        let supply = initialSupply;\n        for (let i = startHeight; i <= blockHeight; ++i) {\n            supply += Policy._blockRewardAt(supply, i);\n        }\n        return supply;\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static blockRewardAt(blockHeight) {\n        const currentSupply = Policy.supplyAfter(blockHeight - 1);\n        return Policy._blockRewardAt(currentSupply, blockHeight);\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} currentSupply\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static _blockRewardAt(currentSupply, blockHeight) {\n        if (blockHeight <= 0) return 0;\n        const remaining = Policy.TOTAL_SUPPLY - currentSupply;\n        if (blockHeight >= Policy.EMISSION_TAIL_START && remaining >= Policy.EMISSION_TAIL_REWARD) {\n            return Policy.EMISSION_TAIL_REWARD;\n        }\n        const remainder = remaining % Policy.EMISSION_SPEED;\n        return (remaining - remainder) / Policy.EMISSION_SPEED;\n    }\n}\n\n/**\n * Targeted block time in seconds.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TIME = 60;\n\n/**\n * Maximum block size in bytes.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_SIZE_MAX = 1e5; // 100 kb\n\n/**\n * The highest (easiest) block PoW target.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TARGET_MAX = Math.pow(2, 240);\n\n/**\n * Number of blocks we take into account to calculate next difficulty.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_BLOCK_WINDOW = 120;\n\n/**\n * Limits the rate at which the difficulty is adjusted min/max.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR = 2;\n\n/**\n * Number of blocks a transaction is valid.\n * @type {number}\n * @constant\n */\nPolicy.TRANSACTION_VALIDITY_WINDOW = 120;\n\n\n/* Supply & Emission Parameters */\n\n/**\n * Number of Satoshis per Nimiq.\n * @type {number}\n * @constant\n */\nPolicy.SATOSHIS_PER_COIN = 1e5;\n\n/**\n * Targeted total supply in satoshis.\n * @type {number}\n * @constant\n */\nPolicy.TOTAL_SUPPLY = 21e14;\n\n/**\n * Initial supply before genesis block in satoshis.\n * FIXME: Change for main net.\n * @type {number}\n * @constant\n */\nPolicy.INITIAL_SUPPLY = 252000000000000;\n\n/**\n * Emission speed.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_SPEED = Math.pow(2, 22);\n\n/**\n * First block using constant tail emission until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_START = 48692960;\n\n/**\n * Constant tail emission in satoshis until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_REWARD = 4000;\n\n/* Security parameters */\n\n/**\n * NIPoPoW Security parameter M\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.M = 240;\n\n/**\n * NIPoPoW Security parameter K\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.K = 120;\n\n/**\n * NIPoPoW Security parameter DELTA\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.DELTA = 0.1;\n\n/**\n * Number of blocks the light client downloads to verify the AccountsTree construction.\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.NUM_BLOCKS_VERIFICATION = 250;\n\n\n/* Snapshot Parameters */\n\n/**\n * Maximum number of snapshots.\n * @type {number}\n * @constant\n */\nPolicy.NUM_SNAPSHOTS_MAX = 20;\n\n\n/**\n * Stores the circulating supply before the given block.\n * @type {Map.<number, number>}\n * @private\n */\nPolicy._supplyCache = new Map();\nPolicy._supplyCacheMax = 0; // blocks\nPolicy._supplyCacheInterval = 5000; // blocks\nClass.register(Policy);\n","/**\n * @abstract\n */\nclass Serializable {\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Serializable && BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return BufferUtils.compare(this.serialize(), o.serialize());\n    }\n\n    hashCode() {\n        return this.toBase64();\n    }\n\n    /**\n     * @abstract\n     * @param {SerialBuffer} [buf]\n     */\n    serialize(buf) {}\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return this.toBase64();\n    }\n\n    /**\n     * @return {string}\n     */\n    toBase64() {\n        return BufferUtils.toBase64(this.serialize());\n    }\n\n    /**\n     * @return {string}\n     */\n    toHex() {\n        return BufferUtils.toHex(this.serialize());\n    }\n}\n\nClass.register(Serializable);\n","class Hash extends Serializable {\n    /**\n     * @param {Hash} o\n     * @returns {Hash}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new Hash(obj);\n    }\n\n    /**\n     * @param {?Uint8Array} arg\n     * @param {Hash.Algorithm} [algorithm]\n     * @private\n     */\n    constructor(arg, algorithm = Hash.Algorithm.BLAKE2B) {\n        if (arg === null) {\n            arg = new Uint8Array(Hash.getSize(algorithm));\n        } else {\n            if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n            if (arg.length !== Hash.getSize(algorithm)) throw new Error('Primitive: Invalid length');\n        }\n        super();\n        this._obj = arg;\n        /** @type {Hash.Algorithm} */\n        this._algorithm = algorithm;\n    }\n\n    /**\n     * @deprecated\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static light(arr) {\n        return Hash.blake2b(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static blake2b(arr) {\n        return new Hash(Hash.computeBlake2b(arr), Hash.Algorithm.BLAKE2B);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @deprecated\n     * @returns {Promise.<Hash>}\n     */\n    static hard(arr) {\n        return Hash.argon2d(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static async argon2d(arr) {\n        return new Hash(await (await CryptoWorker.getInstanceAsync()).computeArgon2d(arr), Hash.Algorithm.ARGON2D);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static sha256(arr) {\n        return new Hash(Hash.computeSha256(arr), Hash.Algorithm.SHA256);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @param {Hash.Algorithm} algorithm\n     * @returns {Hash}\n     */\n    static compute(arr, algorithm) {\n        // !! The algorithms supported by this function are the allowed hash algorithms for HTLCs !!\n        switch (algorithm) {\n            case Hash.Algorithm.BLAKE2B: return Hash.blake2b(arr);\n            case Hash.Algorithm.SHA256: return Hash.sha256(arr);\n            // Hash.Algorithm.ARGON2 intentionally omitted\n            default: throw new Error('Invalid hash algorithm');\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash.Algorithm} [algorithm]\n     * @returns {Hash}\n     */\n    static unserialize(buf, algorithm = Hash.Algorithm.BLAKE2B) {\n        return new Hash(buf.read(Hash.getSize(algorithm)), algorithm);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /**\n     * @param {number} begin\n     * @param {number} end\n     * @returns {Uint8Array}\n     */\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Hash.SIZE.get(this._algorithm);\n    }\n\n    /** @type {Uint8Array} */\n    get array() {\n        return this._obj;\n    }\n\n    /** @type {Hash.Algorithm} */\n    get algorithm() {\n        return this._algorithm;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Hash && o._algorithm === this._algorithm && super.equals(o);\n    }\n\n    /**\n     * @param {string} base64\n     * @returns {Hash}\n     */\n    static fromBase64(base64) {\n        return new Hash(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @returns {Hash}\n     */\n    static fromHex(hex) {\n        return new Hash(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @returns {Hash}\n     */\n    static fromString(str) {\n        try {\n            return Hash.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Hash.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid hash format');\n    }\n\n    /**\n     * @param {Hash} o\n     * @returns {boolean}\n     */\n    static isHash(o) {\n        return o instanceof Hash;\n    }\n\n    /**\n     * @param {Hash.Algorithm} algorithm\n     * @returns {number}\n     */\n    static getSize(algorithm) {\n        const size = Hash.SIZE.get(algorithm);\n        if (typeof size !== 'number') throw new Error('Invalid hash algorithm');\n        return size;\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeBlake2b(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.BLAKE2B));\n            NodeNative.node_blake2(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.BLAKE2B);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_blake2(wasmOut, wasmIn, input.length);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeSha256(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA256));\n            NodeNative.node_sha256(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA256);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                Module._nimiq_sha256(wasmOut, wasmIn, input.length);\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\n/**\n * @enum {number}\n */\nHash.Algorithm = {\n    BLAKE2B: 1,\n    ARGON2D: 2,\n    SHA256: 3,\n    SHA512: 4\n};\n/**\n * @type {Map<Hash.Algorithm, number>}\n */\nHash.SIZE = new Map();\nHash.SIZE.set(Hash.Algorithm.BLAKE2B, 32);\nHash.SIZE.set(Hash.Algorithm.ARGON2D, 32);\nHash.SIZE.set(Hash.Algorithm.SHA256, 32);\nHash.SIZE.set(Hash.Algorithm.SHA512, 64);\n\nHash.NULL = new Hash(new Uint8Array(32));\nClass.register(Hash);\n","class PublicKey extends Serializable {\n    /**\n     * @param {PublicKey} o\n     * @returns {PublicKey}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new PublicKey(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PublicKey.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {PublicKey}\n     */\n    static derive(privateKey) {\n        return new PublicKey(PublicKey._publicKeyDerive(privateKey._obj));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @return {PublicKey}\n     */\n    static sum(publicKeys) {\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n        return PublicKey._delinearizeAndAggregatePublicKeys(publicKeys);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PublicKey}\n     */\n    static unserialize(buf) {\n        return new PublicKey(buf.read(PublicKey.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PublicKey.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PublicKey && super.equals(o);\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        return Hash.light(this.serialize());\n    }\n\n    /**\n     * @param {PublicKey} o\n     * @return {number}\n     */\n    compare(o) {\n        return BufferUtils.compare(this._obj, o._obj);\n    }\n\n    /**\n     * @return {Address}\n     */\n    toAddress() {\n        return Address.fromHash(this.hash());\n    }\n\n    /**\n     * @return {PeerId}\n     */\n    toPeerId() {\n        return new PeerId(this.hash().subarray(0, 16));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @returns {PublicKey}\n     */\n    static _delinearizeAndAggregatePublicKeys(publicKeys) {\n        const publicKeysObj = publicKeys.map(k => k.serialize());\n        const publicKeysHash = PublicKey._publicKeysHash(publicKeysObj);\n        const raw = PublicKey._publicKeysDelinearizeAndAggregate(publicKeysObj, publicKeysHash);\n        return new PublicKey(raw);\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    static _publicKeyDerive(privateKey) {\n        if (privateKey.byteLength !== PrivateKey.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_public_key_derive(out, new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const pubKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOut, PrivateKey.SIZE);\n                pubKeyBuffer.set(privateKey);\n                const wasmIn = Module.stackAlloc(privateKey.length);\n                const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmIn, PrivateKey.SIZE);\n                privKeyBuffer.set(privateKey);\n\n                Module._ed25519_public_key_derive(wasmOut, wasmIn);\n                privKeyBuffer.fill(0);\n                const publicKey = new Uint8Array(PublicKey.SIZE);\n                publicKey.set(pubKeyBuffer);\n                return publicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    static _publicKeysHash(publicKeys) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA512));\n            NodeNative.node_ed25519_hash_public_keys(out, concatenatedPublicKeys, publicKeys.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA512);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                Module._ed25519_hash_public_keys(wasmOut, wasmInPublicKeys, publicKeys.length);\n                const hashedPublicKey = new Uint8Array(hashSize);\n                hashedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hashedPublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _publicKeyDelinearize(publicKey, publicKeysHash) {\n        if (publicKey.byteLength !== PublicKey.SIZE\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_delinearize_public_key(out, new Uint8Array(publicKeysHash), new Uint8Array(publicKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_delinearize_public_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey);\n                const delinearizedPublicKey = new Uint8Array(PublicKey.SIZE);\n                delinearizedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return delinearizedPublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_aggregate_delinearized_public_keys(out, new Uint8Array(publicKeysHash), concatenatedPublicKeys, publicKeys.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_aggregate_delinearized_public_keys(wasmOut, wasmInPublicKeysHash, wasmInPublicKeys, publicKeys.length);\n                const aggregatePublicKey = new Uint8Array(PublicKey.SIZE);\n                aggregatePublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return aggregatePublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPublicKey.SIZE = 32;\n\nClass.register(PublicKey);\n","class Signature extends Serializable {\n    /**\n     * @param {Signature} o\n     * @returns {Signature}\n     */\n    static copy(o) {\n        if (!o) return o;\n        // FIXME Move this to Crypto class.\n        const obj = new Uint8Array(o._obj);\n        return new Signature(obj);\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Signature.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {Signature}\n     */\n    static create(privateKey, publicKey, data) {\n        return new Signature(Signature._signatureCreate(privateKey._obj, publicKey._obj, data));\n    }\n\n    /**\n     * @param {Commitment} commitment\n     * @param {Array.<PartialSignature>} signatures\n     * @return {Signature}\n     */\n    static fromPartialSignatures(commitment, signatures) {\n        const raw = Signature._combinePartialSignatures(commitment.serialize(), signatures.map(s => s.serialize()));\n        return new Signature(raw);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Signature}\n     */\n    static unserialize(buf) {\n        return new Signature(buf.read(Signature.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Signature.SIZE;\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {boolean}\n     */\n    verify(publicKey, data) {\n        return Signature._signatureVerify(publicKey._obj, data, this._obj);\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Signature && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} combinedCommitment\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static _combinePartialSignatures(combinedCommitment, partialSignatures) {\n        const combinedSignature = Signature._aggregatePartialSignatures(partialSignatures);\n        return BufferUtils.concatTypedArrays(combinedCommitment, combinedSignature);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static _aggregatePartialSignatures(partialSignatures) {\n        return partialSignatures.reduce((sigA, sigB) => Signature._scalarsAdd(sigA, sigB));\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @returns {Uint8Array}\n     */\n    static _scalarsAdd(a, b) {\n        if (a.byteLength !== PartialSignature.SIZE || b.byteLength !== PartialSignature.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PartialSignature.SIZE);\n            NodeNative.node_ed25519_add_scalars(out, new Uint8Array(a), new Uint8Array(b));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutSum = Module.stackAlloc(PartialSignature.SIZE);\n                const wasmInA = Module.stackAlloc(a.length);\n                const wasmInB = Module.stackAlloc(b.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInA, a.length).set(a);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInB, b.length).set(b);\n                Module._ed25519_add_scalars(wasmOutSum, wasmInA, wasmInB);\n                const sum = new Uint8Array(PartialSignature.SIZE);\n                sum.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSum, PartialSignature.SIZE));\n                return sum;\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    static _signatureCreate(privateKey, publicKey, message) {\n        if (publicKey.byteLength !== PublicKey.SIZE\n            || privateKey.byteLength !== PrivateKey.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Signature.SIZE);\n            NodeNative.node_ed25519_sign(out, new Uint8Array(message), new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutSignature = Module.stackAlloc(Signature.SIZE);\n                const signatureBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOutSignature, Signature.SIZE);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);\n                const wasmInPubKey = Module.stackAlloc(publicKey.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);\n                const wasmInPrivKey = Module.stackAlloc(privateKey.length);\n                const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmInPrivKey, privateKey.length);\n                privKeyBuffer.set(privateKey);\n\n                Module._ed25519_sign(wasmOutSignature, wasmInMessage, message.byteLength, wasmInPubKey, wasmInPrivKey);\n                privKeyBuffer.fill(0);\n\n                const signature = new Uint8Array(Signature.SIZE);\n                signature.set(signatureBuffer);\n                return signature;\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    static _signatureVerify(publicKey, message, signature) {\n        if (PlatformUtils.isNodeJs()) {\n            return !!NodeNative.node_ed25519_verify(new Uint8Array(signature), new Uint8Array(message), new Uint8Array(publicKey));\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmInPubKey = Module.stackAlloc(publicKey.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);\n                const wasmInSignature = Module.stackAlloc(signature.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInSignature, signature.length).set(signature);\n\n                return !!Module._ed25519_verify(wasmInSignature, wasmInMessage, message.byteLength, wasmInPubKey);\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nSignature.SIZE = 64;\n\nClass.register(Signature);\n","class Address extends Serializable {\n    /**\n     * @param {Address} o\n     * @returns {Address}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new Address(obj);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Address}\n     */\n    static fromHash(hash) {\n        return new Address(hash.subarray(0, Address.SERIALIZED_SIZE));\n    }\n\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Address.SERIALIZED_SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * Create Address object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Address} Newly created Account object.\n     */\n    static unserialize(buf) {\n        return new Address(buf.read(Address.SERIALIZED_SIZE));\n    }\n\n    /**\n     * Serialize this Address object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return Address.SERIALIZED_SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Address\n            && super.equals(o);\n    }\n\n    static fromString(str) {\n        try {\n            return Address.fromUserFriendlyAddress(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid address format');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {Address}\n     */\n    static fromBase64(base64) {\n        return new Address(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @return {Address}\n     */\n    static fromHex(hex) {\n        return new Address(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @return {Address}\n     */\n    static fromUserFriendlyAddress(str) {\n        str = str.replace(/ /g, '');\n        if (str.substr(0, 2).toUpperCase() !== Address.CCODE) {\n            throw new Error('Invalid Address: Wrong country code');\n        }\n        if (str.length !== 36) {\n            throw new Error('Invalid Address: Should be 36 chars (ignoring spaces)');\n        }\n        if (Address._ibanCheck(str.substr(4) + str.substr(0, 4)) !== 1) {\n            throw new Error('Invalid Address: Checksum invalid');\n        }\n        return new Address(BufferUtils.fromBase32(str.substr(4)));\n    }\n\n    static _ibanCheck(str) {\n        const num = str.split('').map((c) => {\n            const code = c.toUpperCase().charCodeAt(0);\n            return code >= 48 && code <= 57 ? c : (code - 55).toString();\n        }).join('');\n        let tmp = '';\n\n        for (let i = 0; i < Math.ceil(num.length / 6); i++) {\n            tmp = (parseInt(tmp + num.substr(i * 6, 6)) % 97).toString();\n        }\n\n        return parseInt(tmp);\n    }\n\n    /**\n     * @param {boolean} [withSpaces]\n     * @return {string}\n     */\n    toUserFriendlyAddress(withSpaces = true) {\n        const base32 = BufferUtils.toBase32(this.serialize());\n        // eslint-disable-next-line prefer-template\n        const check = ('00' + (98 - Address._ibanCheck(base32 + Address.CCODE + '00'))).slice(-2);\n        let res = Address.CCODE + check + base32;\n        if (withSpaces) res = res.replace(/.{4}/g, '$& ').trim();\n        return res;\n    }\n}\nAddress.CCODE = 'NQ';\nAddress.SERIALIZED_SIZE = 20;\nAddress.HEX_SIZE = 40;\nAddress.NULL = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nAddress.CONTRACT_CREATION = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nClass.register(Address);\n","/**\n * @abstract\n */\nclass Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        if (!NumberUtils.isUint8(type)) throw new Error('Malformed type');\n        if (!NumberUtils.isUint64(balance)) throw new Error('Malformed balance');\n\n        /** @type {Account.Type} */\n        this._type = type;\n        /** @type {number} */\n        this._balance = balance;\n    }\n\n    /**\n     * Create Account object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Account} Newly created Account object.\n     */\n    static unserialize(buf) {\n        const type = /** @type {Account.Type} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Account.TYPE_MAP.has(type)) {\n            throw new Error('Unknown account type');\n        }\n\n        return Account.TYPE_MAP.get(type).unserialize(buf);\n    }\n\n    /**\n     * Serialize this Account object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        buf.writeUint64(this._balance);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return /*type*/ 1\n            + /*balance*/ 8;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    toString() {\n        return `Account{type=${this._type}, balance=${this._balance.toString()}`;\n    }\n\n    /**\n     * @type {number} Account balance\n     */\n    get balance() {\n        return this._balance;\n    }\n\n    /** @type {Account.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) { throw new Error('Not yet implemented.'); }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            if (transactionsCache.containsTransaction(transaction)) {\n                throw new Error('Double Transaction Error!');\n            }\n            return this.withBalance(newBalance);\n        } else {\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            return this.withBalance(this._balance + transaction.value + transaction.fee);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            return this.withBalance(this._balance + transaction.value);\n        } else {\n            const newBalance = this._balance - transaction.value;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            return this.withBalance(newBalance);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this === Account.INITIAL;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isToBePruned() {\n        return this._balance === 0 && !this.isInitial();\n    }\n}\n\n/**\n * Enum for Account types.\n * Non-zero values are contracts.\n * @enum\n */\nAccount.Type = {\n    /**\n     * Basic account type.\n     * @see {BasicAccount}\n     */\n    BASIC: 0,\n    /**\n     * Account with vesting functionality.\n     * @see {VestingContract}\n     */\n    VESTING: 1,\n    /**\n     * Hashed Time-Locked Contract\n     * @see {HashedTimeLockedContract}\n     */\n    HTLC: 2\n};\n/**\n * @type {Map.<Account.Type, {copy: function(o: *):Account, unserialize: function(buf: SerialBuffer):Account, create: function(balance: number, blockHeight: number, transaction: Transaction):Account, verifyOutgoingTransaction: function(transaction: Transaction):Promise.<boolean>, verifyIncomingTransaction: function(transaction: Transaction):Promise.<boolean>}>}\n */\nAccount.TYPE_MAP = new Map();\n\nClass.register(Account);\n","class PrunedAccount {\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     */\n    constructor(address, account) {\n        if (!(address instanceof Address)) throw new Error('Malformed address');\n\n        /** @type {Address} */\n        this._address = address;\n        /** @type {Account} */\n        this._account = account;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PrunedAccount}\n     */\n    static unserialize(buf) {\n        return new PrunedAccount(Address.unserialize(buf), Account.unserialize(buf));\n    }\n\n    /**\n     * @param {PrunedAccount} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return this._address.compare(o._address);\n    }\n\n    /**\n     * @returns {Address}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * @returns {Account}\n     */\n    get account() {\n        return this._account;\n    }\n\n    /**\n     * @param buf\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._address.serialize(buf);\n        this._account.serialize(buf);\n        return this;\n    }\n\n    get serializedSize() {\n        return this._address.serializedSize + this._account.serializedSize;\n    }\n}\n\nClass.register(PrunedAccount);\n","/**\n * This is a classic account that can send all his funds and receive any transaction.\n * All outgoing transactions are signed using the key corresponding to this address.\n */\nclass BasicAccount extends Account {\n    /**\n     * @param {BasicAccount} o\n     * @returns {BasicAccount}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new BasicAccount(o._balance);\n    }\n\n    /**\n     * @param {number} [balance]\n     */\n    constructor(balance = 0) {\n        super(Account.Type.BASIC, balance);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BasicAccount}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.BASIC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof BasicAccount\n            && this._type === o._type\n            && this._balance === o._balance;\n    }\n\n    toString() {\n        return `BasicAccount{balance=${this._balance}}`;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        return SignatureProof.verifyTransaction(transaction);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (transaction.data.byteLength > 64) return false;\n        return true;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            const isContractCreation = transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION);\n            const isTypeChange = transaction.recipientType !== this._type;\n            if (isContractCreation !== isTypeChange) {\n                throw new Error('Data Error!');\n            }\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.recipientType !== this._type && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract creation\n            return Account.TYPE_MAP.get(transaction.recipientType).create(this._balance, blockHeight, transaction);\n        }\n        return this;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this._balance === 0;\n    }\n}\n\nAccount.INITIAL = new BasicAccount(0);\nAccount.TYPE_MAP.set(Account.Type.BASIC, BasicAccount);\nClass.register(BasicAccount);\n","class Contract extends Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        super(type, balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (!transaction.recipient.equals(transaction.getContractCreationAddress())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract already created\n            throw new Error('Data error');\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Revert contract creation\n            return new BasicAccount(this.balance);\n        }\n        return this;\n    }\n}\n\nClass.register(Contract);\n","class HashedTimeLockedContract extends Contract {\n    /**\n     * @param {number} balance\n     * @param {Address} sender\n     * @param {Address} recipient\n     * @param {Hash} hashRoot\n     * @param {number} hashCount\n     * @param {number} timeout\n     * @param {number} totalAmount\n     */\n    constructor(balance = 0, sender = Address.NULL, recipient = Address.NULL, hashRoot = Hash.NULL, hashCount = 1, timeout = 0, totalAmount = balance) {\n        super(Account.Type.HTLC, balance);\n        if (!(sender instanceof Address)) throw new Error('Malformed address');\n        if (!(recipient instanceof Address)) throw new Error('Malformed address');\n        if (!(hashRoot instanceof Hash)) throw new Error('Malformed address');\n        if (!NumberUtils.isUint8(hashCount) || hashCount === 0) throw new Error('Malformed hashCount');\n        if (!NumberUtils.isUint32(timeout)) throw new Error('Malformed timeout');\n        if (!NumberUtils.isUint64(totalAmount)) throw new Error('Malformed totalAmount');\n\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Hash} */\n        this._hashRoot = hashRoot;\n        /** @type {number} */\n        this._hashCount = hashCount;\n        /** @type {number} */\n        this._timeout = timeout;\n        /** @type {number} */\n        this._totalAmount = totalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        const buf = new SerialBuffer(transaction.data);\n\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HashedTimeLockedContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.HTLC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n        const totalAmount = buf.readUint64();\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout, totalAmount);\n    }\n\n\n    /**\n     * Serialize this HTLC object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._sender.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._hashRoot.algorithm);\n        this._hashRoot.serialize(buf);\n        buf.writeUint8(this._hashCount);\n        buf.writeUint32(this._timeout);\n        buf.writeUint64(this._totalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._sender.serializedSize\n            + this._recipient.serializedSize\n            + /*hashAlgorithm*/ 1\n            + this._hashRoot.serializedSize\n            + /*hashCount*/ 1\n            + /*timeout*/ 4\n            + /*totalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Hash} */\n    get hashRoot() {\n        return this._hashRoot;\n    }\n\n    /** @type {number} */\n    get hashCount() {\n        return this._hashCount;\n    }\n\n    /** @type {number} */\n    get timeout() {\n        return this._timeout;\n    }\n\n    /** @type {number} */\n    get totalAmount() {\n        return this._totalAmount;\n    }\n\n    toString() {\n        return `HashedTimeLockedContract{balance=${this._balance}, sender=${this._sender.toUserFriendlyAddress(false)}, recipient=${this._sender.toUserFriendlyAddress(false)}, amount=${this._totalAmount}/${this._hashCount}, timeout=${this._timeout}}`;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof HashedTimeLockedContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._sender.equals(o._sender)\n            && this._recipient.equals(o._recipient)\n            && this._hashRoot.equals(o._hashRoot)\n            && this._hashCount === o._hashCount\n            && this._timeout === o._timeout\n            && this._totalAmount === o._totalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.proof);\n            const type = buf.readUint8();\n            switch (type) {\n                case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                    const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                    const hashDepth = buf.readUint8();\n                    const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                    let preImage = Hash.unserialize(buf, hashAlgorithm);\n\n                    // Verify that the preImage hashed hashDepth times matches the _provided_ hashRoot.\n                    for (let i = 0; i < hashDepth; ++i) {\n                        preImage = Hash.compute(preImage.array, hashAlgorithm);\n                    }\n                    if (!hashRoot.equals(preImage)) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                default:\n                    return false;\n            }\n\n            // Reject overlong proof.\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return true; // Accept\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.data);\n\n            Address.unserialize(buf); // sender address\n            Address.unserialize(buf); // recipient address\n            const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n            Hash.unserialize(buf, hashAlgorithm);\n            buf.readUint8(); // hash count\n            buf.readUint32(); // timeout\n\n            // Blacklist Argon2 hash function.\n            if (hashAlgorithm === Hash.Algorithm.ARGON2D) {\n                return false;\n            }\n\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return Contract.verifyIncomingTransaction(transaction);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new HashedTimeLockedContract(balance, this._sender, this._recipient, this._hashRoot, this._hashCount, this._timeout, this._totalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        const buf = new SerialBuffer(transaction.proof);\n        const type = buf.readUint8();\n        let minCap = 0;\n        switch (type) {\n            case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                // Check that the contract has not expired yet.\n                if (this._timeout < blockHeight) {\n                    throw new Error('Proof Error!');\n                }\n\n                // Check that the provided hashRoot is correct.\n                const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                const hashDepth = buf.readUint8();\n                const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                if (!hashRoot.equals(this._hashRoot)) {\n                    throw new Error('Proof Error!');\n                }\n\n                // Ignore the preImage.\n                Hash.unserialize(buf, hashAlgorithm);\n\n                // Verify that the transaction is signed by the authorized recipient.\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Error('Proof Error!');\n                }\n\n                minCap = Math.max(0, Math.floor((1 - (hashDepth / this._hashCount)) * this._totalAmount));\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Error('Proof Error!');\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Error('Proof Error!');\n                }\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE: {\n                if (this._timeout >= blockHeight) {\n                    throw new Error('Proof Error!');\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Error('Proof Error!');\n                }\n\n                break;\n            }\n            default:\n                throw new Error('Proof Error!');\n        }\n\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Error('Balance Error!');\n            }\n        }\n\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n}\n\nHashedTimeLockedContract.ProofType = {\n    REGULAR_TRANSFER: 1,\n    EARLY_RESOLVE: 2,\n    TIMEOUT_RESOLVE: 3\n};\n\nAccount.TYPE_MAP.set(Account.Type.HTLC, HashedTimeLockedContract);\nClass.register(HashedTimeLockedContract);\n","class VestingContract extends Contract {\n    /**\n     * @param {number} [balance]\n     * @param {Address} [owner]\n     * @param {number} [vestingStart]\n     * @param {number} [vestingStepBlocks]\n     * @param {number} [vestingStepAmount]\n     * @param {number} [vestingTotalAmount]\n     */\n    constructor(balance = 0, owner = Address.NULL, vestingStart = 0, vestingStepBlocks = 0, vestingStepAmount = balance, vestingTotalAmount = balance) {\n        super(Account.Type.VESTING, balance);\n        if (!(owner instanceof Address)) throw new Error('Malformed address');\n        if (!NumberUtils.isUint32(vestingStart)) throw new Error('Malformed vestingStart');\n        if (!NumberUtils.isUint32(vestingStepBlocks)) throw new Error('Malformed vestingStepBlocks');\n        if (!NumberUtils.isUint64(vestingStepAmount)) throw new Error('Malformed vestingStepAmount');\n        if (!NumberUtils.isUint64(vestingTotalAmount)) throw new Error('Malformed lowerCap');\n\n        /** @type {Address} */\n        this._owner = owner;\n        /** @type {number} */\n        this._vestingStart = vestingStart;\n        /** @type {number} */\n        this._vestingStepBlocks = vestingStepBlocks;\n        /** @type {number} */\n        this._vestingStepAmount = vestingStepAmount;\n        /** @type {number} */\n        this._vestingTotalAmount = vestingTotalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        /** @type {number} */\n        let vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount;\n        const buf = new SerialBuffer(transaction.data);\n        const owner = Address.unserialize(buf);\n        vestingTotalAmount = transaction.value;\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n                // Only block number: vest full amount at that block\n                vestingStart = 0;\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = vestingTotalAmount;\n                break;\n            case Address.SERIALIZED_SIZE + 16:\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                break;\n            case Address.SERIALIZED_SIZE + 24:\n                // Create a vesting account with some instantly vested funds or additional funds considered.\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                vestingTotalAmount = buf.readUint64();\n                break;\n            default:\n                throw new Error('Invalid transaction data');\n        }\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {VestingContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.VESTING) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const owner = Address.unserialize(buf);\n        const vestingStart = buf.readUint32();\n        const vestingStepBlocks = buf.readUint32();\n        const vestingStepAmount = buf.readUint64();\n        const vestingTotalAmount = buf.readUint64();\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * Serialize this VestingContract object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._owner.serialize(buf);\n        buf.writeUint32(this._vestingStart);\n        buf.writeUint32(this._vestingStepBlocks);\n        buf.writeUint64(this._vestingStepAmount);\n        buf.writeUint64(this._vestingTotalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._owner.serializedSize\n            + /*vestingStart*/ 4\n            + /*vestingStepBlocks*/ 4\n            + /*vestingStepAmount*/ 8\n            + /*vestingTotalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get owner() {\n        return this._owner;\n    }\n\n    /** @type {number} */\n    get vestingStart() {\n        return this._vestingStart;\n    }\n\n    /** @type {number} */\n    get vestingStepBlocks() {\n        return this._vestingStepBlocks;\n    }\n\n    /** @type {number} */\n    get vestingStepAmount() {\n        return this._vestingStepAmount;\n    }\n\n    /** @type {number} */\n    get vestingTotalAmount() {\n        return this._vestingTotalAmount;\n    }\n\n    toString() {\n        return `VestingAccount{balance=${this._balance}, owner=${this._owner.toUserFriendlyAddress()}`;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof VestingContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._owner.equals(o._owner)\n            && this._vestingStart === o._vestingStart\n            && this._vestingStepBlocks === o._vestingStepBlocks\n            && this._vestingStepAmount === o._vestingStepAmount\n            && this._vestingTotalAmount === o._vestingTotalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        const buf = new SerialBuffer(transaction.proof);\n\n        if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n            return false;\n        }\n\n        if (buf.readPos !== buf.byteLength) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n            case Address.SERIALIZED_SIZE + 16:\n            case Address.SERIALIZED_SIZE + 24:\n                return Contract.verifyIncomingTransaction(transaction);\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new VestingContract(balance, this._owner, this._vestingStart, this._vestingStepBlocks, this._vestingStepAmount, this._vestingTotalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const minCap = this.getMinCap(blockHeight);\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Error('Balance Error!');\n            }\n\n            const buf = new SerialBuffer(transaction.proof);\n            if (!SignatureProof.unserialize(buf).isSignedBy(this._owner)) {\n                throw new Error('Proof Error!');\n            }\n        }\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n\n    /**\n     * @param {number} blockHeight\n     * @returns {number}\n     */\n    getMinCap(blockHeight) {\n        return this._vestingStepBlocks && this._vestingStepAmount > 0\n            ? Math.max(0, this._vestingTotalAmount - Math.floor((blockHeight - this._vestingStart) / this._vestingStepBlocks) * this._vestingStepAmount)\n            : 0;\n    }\n}\n\nAccount.TYPE_MAP.set(Account.Type.VESTING, VestingContract);\nClass.register(VestingContract);\n","class BlockHeader {\n    /**\n     * @param {BlockHeader} o\n     * @returns {BlockHeader}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const prevHash = Hash.copy(o._prevHash);\n        const interlinkHash = Hash.copy(o._interlinkHash);\n        const bodyHash = Hash.copy(o._bodyHash);\n        const accountsHash = Hash.copy(o._accountsHash);\n        return new BlockHeader(\n            prevHash, interlinkHash, bodyHash, accountsHash,\n            o._nBits, o._height, o._timestamp, o._nonce, o._version\n        );\n    }\n\n    /**\n     * @param {Hash} prevHash\n     * @param {Hash} interlinkHash\n     * @param {Hash} bodyHash\n     * @param {Hash} accountsHash\n     * @param {number} nBits\n     * @param {number} height\n     * @param {number} timestamp\n     * @param {number} nonce\n     * @param {number} version\n     */\n    constructor(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version = BlockHeader.CURRENT_VERSION) {\n        if (!NumberUtils.isUint16(version)) throw 'Malformed version';\n        if (!Hash.isHash(prevHash)) throw 'Malformed prevHash';\n        if (!Hash.isHash(interlinkHash)) throw 'Malformed interlinkHash';\n        if (!Hash.isHash(bodyHash)) throw 'Malformed bodyHash';\n        if (!Hash.isHash(accountsHash)) throw 'Malformed accountsHash';\n        if (!NumberUtils.isUint32(nBits) || !BlockUtils.isValidCompact(nBits)) throw 'Malformed nBits';\n        if (!NumberUtils.isUint32(height)) throw 'Invalid height';\n        if (!NumberUtils.isUint32(timestamp)) throw 'Malformed timestamp';\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n\n        /** @type {number} */\n        this._version = version;\n        /** @type {Hash} */\n        this._prevHash = prevHash;\n        /** @type {Hash} */\n        this._interlinkHash = interlinkHash;\n        /** @type {Hash} */\n        this._bodyHash = bodyHash;\n        /** @type {Hash} */\n        this._accountsHash = accountsHash;\n        /** @type {number} */\n        this._nBits = nBits;\n        /** @type {number} */\n        this._height = height;\n        /** @type {number} */\n        this._timestamp = timestamp;\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockHeader}\n     */\n    static unserialize(buf) {\n        const version = buf.readUint16();\n        if (!BlockHeader.SUPPORTED_VERSIONS.includes(version)) throw new Error(`Unsupported block version ${version}`);\n        const prevHash = Hash.unserialize(buf);\n        const interlinkHash = Hash.unserialize(buf);\n        const bodyHash = Hash.unserialize(buf);\n        const accountsHash = Hash.unserialize(buf);\n        const nBits = buf.readUint32();\n        const height = buf.readUint32();\n        const timestamp = buf.readUint32();\n        const nonce = buf.readUint32();\n        return new BlockHeader(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._version);\n        this._prevHash.serialize(buf);\n        this._interlinkHash.serialize(buf);\n        this._bodyHash.serialize(buf);\n        this._accountsHash.serialize(buf);\n        buf.writeUint32(this._nBits);\n        buf.writeUint32(this._height);\n        buf.writeUint32(this._timestamp);\n        buf.writeUint32(this._nonce);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*version*/ 2\n            + this._prevHash.serializedSize\n            + this._interlinkHash.serializedSize\n            + this._bodyHash.serializedSize\n            + this._accountsHash.serializedSize\n            + /*nBits*/ 4\n            + /*height*/ 4\n            + /*timestamp*/ 4\n            + /*nonce*/ 4;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<boolean>}\n     */\n    async verifyProofOfWork(buf) {\n        const pow = await this.pow(buf);\n        return BlockUtils.isProofOfWork(pow, this.target);\n    }\n\n    /**\n     * @param {BlockHeader} prevHeader\n     * @returns {boolean}\n     */\n    isImmediateSuccessorOf(prevHeader) {\n        // Check that the height is one higher than the previous height.\n        if (this.height !== prevHeader.height + 1) {\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this.timestamp < prevHeader.timestamp) {\n            return false;\n        }\n\n        // Check that the hash of the predecessor block equals prevHash.\n        const prevHash = prevHeader.hash();\n        if (!this.prevHash.equals(prevHash)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Hash}\n     */\n    hash(buf) {\n        this._hash = this._hash || Hash.light(this.serialize(buf));\n        return this._hash;\n    }\n    \n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<Hash>}\n     */\n    async pow(buf) {\n        this._pow = this._pow || await Hash.hard(this.serialize(buf));\n        return this._pow;\n    }\n\n    /**\n     * @param {BlockHeader|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockHeader\n            && this._prevHash.equals(o.prevHash)\n            && this._interlinkHash.equals(o.interlinkHash)\n            && this._bodyHash.equals(o.bodyHash)\n            && this._accountsHash.equals(o.accountsHash)\n            && this._nBits === o.nBits\n            && this._height === o.height\n            && this._timestamp === o.timestamp\n            && this._nonce === o.nonce;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return 'BlockHeader{'\n            + `prevHash=${this._prevHash}, `\n            + `interlinkHash=${this._interlinkHash}, `\n            + `bodyHash=${this._bodyHash}, `\n            + `accountsHash=${this._accountsHash}, `\n            + `nBits=${this._nBits.toString(16)}, `\n            + `height=${this._height}, `\n            + `timestamp=${this._timestamp}, `\n            + `nonce=${this._nonce}`\n            + '}';\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {Hash} */\n    get prevHash() {\n        return this._prevHash;\n    }\n\n    /** @type {Hash} */\n    get interlinkHash() {\n        return this._interlinkHash;\n    }\n\n    /** @type {Hash} */\n    get bodyHash() {\n        return this._bodyHash;\n    }\n\n    /** @type {Hash} */\n    get accountsHash() {\n        return this._accountsHash;\n    }\n\n    /** @type {number} */\n    get nBits() {\n        return this._nBits;\n    }\n\n    /** @type {number} */\n    get target() {\n        return BlockUtils.compactToTarget(this._nBits);\n    }\n\n    /** @type {number} */\n    get difficulty() {\n        return BlockUtils.compactToDifficulty(this._nBits);\n    }\n\n    /** @type {number} */\n    get height() {\n        return this._height;\n    }\n\n    /** @type {number} */\n    get timestamp() {\n        return this._timestamp;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    // XXX The miner changes the nonce of an existing BlockHeader during the\n    // mining process.\n    /** @type {number} */\n    set nonce(n) {\n        this._nonce = n;\n        this._hash = null;\n        this._pow = null;\n    }\n}\n// FIXME: Clean up for mainnet.\nBlockHeader.Version = {\n    V1: 1\n};\nBlockHeader.CURRENT_VERSION = BlockHeader.Version.V1;\nBlockHeader.SUPPORTED_VERSIONS = [\n    BlockHeader.Version.V1\n];\nBlockHeader.SERIALIZED_SIZE = 146;\nClass.register(BlockHeader);\n","class BlockInterlink {\n    /**\n     * @param {BlockInterlink} o\n     * @returns {BlockInterlink}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const hashes = o._hashes.map(it => Hash.copy(it));\n        const repeatBits = new Uint8Array(o._repeatBits);\n        const compressed = o._compressed.map(it => Hash.copy(it));\n        return new BlockInterlink(hashes, undefined, repeatBits, compressed);\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} prevHash\n     * @returns {{repeatBits: Uint8Array, compressed: Array.<Hash>}}\n     * @protected\n     */\n    static _compress(hashes, prevHash) {\n        const count = hashes.length;\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = new Uint8Array(repeatBitsSize);\n\n        let lastHash = prevHash;\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const hash = hashes[i];\n            if (!hash.equals(lastHash)) {\n                compressed.push(hash);\n                lastHash = hash;\n            } else {\n                repeatBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return {repeatBits, compressed};\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} [prevHash]\n     * @param {Uint8Array} [repeatBits]\n     * @param {Array.<Hash>} [compressed]\n     */\n    constructor(hashes, prevHash, repeatBits, compressed) {\n        if (!Array.isArray(hashes) || !NumberUtils.isUint8(hashes.length)\n            || hashes.some(it => !(it instanceof Hash))) throw new Error('Malformed hashes');\n        if ((repeatBits || compressed) && !(repeatBits && compressed)) throw new Error('Malformed repeatBits/compressed');\n        if (!prevHash && !repeatBits) throw new Error('Either prevHash or repeatBits/compressed required');\n\n        if (!repeatBits) {\n            ({repeatBits, compressed} = BlockInterlink._compress(hashes, prevHash));\n        }\n\n        /** @type {Array.<Hash>} */\n        this._hashes = hashes;\n        /** @type {Uint8Array} */\n        this._repeatBits = repeatBits;\n        /** @type {Array.<Hash>} */\n        this._compressed = compressed;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash} prevHash\n     * @returns {BlockInterlink}\n     */\n    static unserialize(buf, prevHash) {\n        const count = buf.readUint8();\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = buf.read(repeatBitsSize);\n\n        let hash = prevHash;\n        const hashes = [];\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const repeated = (repeatBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            if (!repeated) {\n                hash = Hash.unserialize(buf);\n                compressed.push(hash);\n            }\n            hashes.push(hash);\n        }\n\n        return new BlockInterlink(hashes, prevHash, repeatBits, compressed);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._hashes.length);\n        buf.write(this._repeatBits);\n        for (const hash of this._compressed) {\n            hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return /*count*/ 1\n            + this._repeatBits.length\n            + this._compressed.reduce((sum, hash) => sum + hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {BlockInterlink|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockInterlink\n            && this._hashes.length === o._hashes.length\n            && this._hashes.every((hash, i) => hash.equals(o.hashes[i]));\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot([this._repeatBits, GenesisConfig.GENESIS_HASH, ...this._compressed]);\n        }\n        return this._hash;\n    }\n\n    /**\n     * @type {Array.<Hash>}\n     */\n    get hashes() {\n        return this._hashes;\n    }\n\n    /**\n     * @type {number}\n     */\n    get length() {\n        return this._hashes.length;\n    }\n}\nClass.register(BlockInterlink);\n","class BlockBody {\n    /**\n     * @param {Uint8Array} extraData\n     * @returns {number}\n     */\n    static getMetadataSize(extraData) {\n        return Address.SERIALIZED_SIZE\n            + /*extraDataLength*/ 1\n            + extraData.byteLength\n            + /*transactionsLength*/ 2\n            + /*prunedAccountsLength*/ 2;\n    }\n\n    /**\n     * @param {Address} minerAddr\n     * @param {Array.<Transaction>} transactions\n     * @param {Uint8Array} [extraData]\n     * @param {Array.<PrunedAccount>} prunedAccounts\n     */\n    constructor(minerAddr, transactions, extraData = new Uint8Array(0), prunedAccounts = []) {\n        if (!(minerAddr instanceof Address)) throw 'Malformed minerAddr';\n        if (!Array.isArray(transactions) || transactions.some(it => !(it instanceof Transaction))) throw 'Malformed transactions';\n        if (!(extraData instanceof Uint8Array) || !NumberUtils.isUint8(extraData.byteLength)) throw 'Malformed extraData';\n\n        /** @type {Address} */\n        this._minerAddr = minerAddr;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n        /** @type {Array.<Transaction>} */\n        this._transactions = transactions;\n        /** @type {Array.<PrunedAccount>} */\n        this._prunedAccounts = prunedAccounts;\n        /** @type {Hash} */\n        this._hash = null;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BlockBody}\n     */\n    static unserialize(buf) {\n        const minerAddr = Address.unserialize(buf);\n        const extraDataLength = buf.readUint8();\n        const extraData = buf.read(extraDataLength);\n        const numTransactions = buf.readUint16();\n        const transactions = new Array(numTransactions);\n        for (let i = 0; i < numTransactions; i++) {\n            transactions[i] = Transaction.unserialize(buf);\n        }\n        const numPrunedAccounts = buf.readUint16();\n        const prunedAccounts = [];\n        for (let i = 0; i < numPrunedAccounts; i++) {\n            prunedAccounts.push(PrunedAccount.unserialize(buf));\n        }\n        return new BlockBody(minerAddr, transactions, extraData, prunedAccounts);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._minerAddr.serialize(buf);\n        buf.writeUint8(this._extraData.byteLength);\n        buf.write(this._extraData);\n        buf.writeUint16(this._transactions.length);\n        for (const tx of this._transactions) {\n            tx.serialize(buf);\n        }\n        buf.writeUint16(this._prunedAccounts.length);\n        for (const acc of this._prunedAccounts) {\n            acc.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        let size = this._minerAddr.serializedSize\n            + /*extraDataLength*/ 1\n            + this._extraData.byteLength\n            + /*transactionsLength*/ 2\n            + /*prunedAccountsLength*/ 2;\n        for (const tx of this._transactions) {\n            size += tx.serializedSize;\n        }\n        size += this._prunedAccounts.reduce((sum, acc) => sum + acc.serializedSize, 0);\n        return size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        /** @type {Transaction} */\n        let previousTx = null;\n        for (const tx of this._transactions) {\n            // Ensure transactions are ordered and unique.\n            if (previousTx && previousTx.compareBlockOrder(tx) >= 0) {\n                Log.w(BlockBody, 'Invalid block - transactions not ordered.');\n                return false;\n            }\n            previousTx = tx;\n\n            // Check that all transactions are valid.\n            if (!tx.verify()) {\n                Log.w(BlockBody, 'Invalid block - invalid transaction');\n                return false;\n            }\n        }\n\n        let previousAcc = null;\n        for (const acc of this._prunedAccounts) {\n            // Ensure pruned accounts are ordered and unique.\n            if (previousAcc && previousAcc.compare(acc) >= 0) {\n                Log.w(BlockBody, 'Invalid block - pruned accounts not ordered.');\n                return false;\n            }\n            previousAcc = acc;\n            \n            // Check that pruned accounts are actually supposed to be pruned\n            if (!acc.account.isToBePruned()) {\n                Log.w(BlockBody, 'Invalid block - invalid pruned account');\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {Array}\n     */\n    getMerkleLeafs() {\n        return [this._minerAddr, this._extraData, ...this._transactions, ...this.prunedAccounts];\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot(this.getMerkleLeafs());\n        }\n        return this._hash;\n    }\n\n    /**\n     * @param {BlockBody} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockBody\n            && this._minerAddr.equals(o.minerAddr)\n            && BufferUtils.equals(this._extraData, o.extraData)\n            && this._transactions.length === o.transactions.length\n            && this._transactions.every((tx, i) => tx.equals(o.transactions[i]));\n    }\n\n    /**\n     * @return {Array.<Address>}\n     */\n    getAddresses() {\n        const addresses = [this._minerAddr];\n        for (const tx of this._transactions) {\n            addresses.push(tx.sender, tx.recipient);\n        }\n        return addresses;\n    }\n\n    /** @type {Uint8Array} */\n    get extraData() {\n        return this._extraData;\n    }\n\n    /** @type {Address} */\n    get minerAddr() {\n        return this._minerAddr;\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /** @type {number} */\n    get transactionCount() {\n        return this._transactions.length;\n    }\n\n    /** @type {Array.<PrunedAccount>} */\n    get prunedAccounts() {\n        return this._prunedAccounts;\n    }\n}\n\nClass.register(BlockBody);\n","class BlockUtils {\n    /**\n     * @param {number} compact\n     * @returns {number}\n     */\n    static compactToTarget(compact) {\n        return (compact & 0xffffff) * Math.pow(2, (8 * ((compact >> 24) - 3)));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static targetToCompact(target) {\n        if (!Number.isFinite(target) || Number.isNaN(target)) throw 'Invalid Target';\n\n        // Divide to get first byte\n        let size = Math.max(Math.ceil(Math.log2(target) / 8), 1);\n        const firstByte = target / Math.pow(2, (size - 1) * 8);\n\n        // If the first (most significant) byte is greater than 127 (0x7f),\n        // prepend a zero byte.\n        if (firstByte >= 0x80) {\n            size++;\n        }\n\n        // The first byte of the 'compact' format is the number of bytes,\n        // including the prepended zero if it's present.\n        // The following three bytes are the first three bytes of the above\n        // representation. If less than three bytes are present, then one or\n        // more of the last bytes of the compact representation will be zero.\n        return (size << 24) + ((target / Math.pow(2, (size - 3) * 8)) & 0xffffff);\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static getTargetHeight(target) {\n        return Math.ceil(Math.log2(target));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static getTargetDepth(target) {\n        return BlockUtils.getTargetHeight(Policy.BLOCK_TARGET_MAX) - BlockUtils.getTargetHeight(target);\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {number}\n     */\n    static compactToDifficulty(compact) {\n        return Policy.BLOCK_TARGET_MAX / BlockUtils.compactToTarget(compact);\n    }\n\n    /**\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    static difficultyToCompact(difficulty) {\n        return BlockUtils.targetToCompact(BlockUtils.difficultyToTarget(difficulty));\n    }\n\n    /**\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    static difficultyToTarget(difficulty) {\n        return Policy.BLOCK_TARGET_MAX / difficulty;\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static targetToDifficulty(target) {\n        return Policy.BLOCK_TARGET_MAX / target;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static hashToTarget(hash) {\n        return parseInt(hash.toHex(), 16);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static realDifficulty(hash) {\n        return BlockUtils.targetToDifficulty(BlockUtils.hashToTarget(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static getHashDepth(hash) {\n        return BlockUtils.getTargetDepth(BlockUtils.hashToTarget(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {number} target\n     * @returns {boolean}\n     */\n    static isProofOfWork(hash, target) {\n        return parseInt(hash.toHex(), 16) <= target;\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {boolean}\n     */\n\n    static isValidCompact(compact) {\n        return BlockUtils.isValidTarget(BlockUtils.compactToTarget(compact));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {boolean}\n     */\n    static isValidTarget(target) {\n        return target >= 1 && target <= Policy.BLOCK_TARGET_MAX;\n    }\n\n    /**\n     * @param {BlockHeader} headBlock\n     * @param {BlockHeader} tailBlock\n     * @param {number} deltaTotalDifficulty\n     * @returns {number}\n     */\n    static getNextTarget(headBlock, tailBlock, deltaTotalDifficulty) {\n        Assert.that(\n            (headBlock.height - tailBlock.height === Policy.DIFFICULTY_BLOCK_WINDOW)\n                || (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW && tailBlock.height === 1),\n            `Tail and head block must be ${Policy.DIFFICULTY_BLOCK_WINDOW} blocks apart`);\n\n        let actualTime = headBlock.timestamp - tailBlock.timestamp;\n\n        // Simulate that the Policy.BLOCK_TIME was achieved for the blocks before the genesis block, i.e. we simulate\n        // a sliding window that starts before the genesis block. Assume difficulty = 1 for these blocks.\n        if (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW) {\n            actualTime += (Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1) * Policy.BLOCK_TIME;\n            deltaTotalDifficulty += Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1;\n        }\n\n        // Compute the target adjustment factor.\n        const expectedTime = Policy.DIFFICULTY_BLOCK_WINDOW * Policy.BLOCK_TIME;\n        let adjustment = actualTime / expectedTime;\n\n        // Clamp the adjustment factor to [1 / MAX_ADJUSTMENT_FACTOR, MAX_ADJUSTMENT_FACTOR].\n        adjustment = Math.max(adjustment, 1 / Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n        adjustment = Math.min(adjustment, Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n\n        // Compute the next target.\n        const averageDifficulty = deltaTotalDifficulty / Policy.DIFFICULTY_BLOCK_WINDOW;\n        const averageTarget = BlockUtils.difficultyToTarget(averageDifficulty);\n        let nextTarget = averageTarget * adjustment;\n\n        // Make sure the target is below or equal the maximum allowed target (difficulty 1).\n        // Also enforce a minimum target of 1.\n        nextTarget = Math.min(nextTarget, Policy.BLOCK_TARGET_MAX);\n        nextTarget = Math.max(nextTarget, 1);\n\n        // XXX Reduce target precision to nBits precision.\n        const nBits = BlockUtils.targetToCompact(nextTarget);\n        return BlockUtils.compactToTarget(nBits);\n    }\n}\nClass.register(BlockUtils);\n","class Block {\n    /**\n     * @param {Block} o\n     * @returns {Block}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new Block(\n            BlockHeader.copy(o._header),\n            BlockInterlink.copy(o._interlink),\n            BlockBody.copy(o._body)\n        );\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @param {BlockInterlink} interlink\n     * @param {BlockBody} [body]\n     */\n    constructor(header, interlink, body) {\n        if (!(header instanceof BlockHeader)) throw 'Malformed header';\n        if (!(interlink instanceof BlockInterlink)) throw 'Malformed interlink';\n        if (body && !(body instanceof BlockBody)) throw 'Malformed body';\n\n        /** @type {BlockHeader} */\n        this._header = header;\n        /** @type {BlockInterlink} */\n        this._interlink = interlink;\n        /** @type {BlockBody} */\n        this._body = body;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Block}\n     */\n    static unserialize(buf) {\n        const header = BlockHeader.unserialize(buf);\n        const interlink = BlockInterlink.unserialize(buf, header.prevHash);\n\n        let body = undefined;\n        const bodyPresent = buf.readUint8();\n        if (bodyPresent) {\n            body = BlockBody.unserialize(buf);\n        }\n\n        return new Block(header, interlink, body);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._header.serialize(buf);\n        this._interlink.serialize(buf);\n\n        if (this._body) {\n            buf.writeUint8(1);\n            this._body.serialize(buf);\n        } else {\n            buf.writeUint8(0);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._header.serializedSize\n            + this._interlink.serializedSize\n            + /*bodyPresent*/ 1\n            + (this._body ? this._body.serializedSize : 0);\n    }\n\n    /**\n     * @param {Time} time\n     * @returns {Promise.<boolean>}\n     */\n    async verify(time) {\n        if (this._valid === undefined) {\n            if (this.isLight() || this.body.transactions.length < 150 || !IWorker.areWorkersAsync) {\n                // worker overhead doesn't pay off for small transaction numbers\n                this._valid = await this._verify(time.now());\n            } else {\n                const transactionValid = this.body.transactions.map(t => t._valid);\n                const worker = await CryptoWorker.getInstanceAsync();\n                const {valid, pow, interlinkHash, bodyHash} = await worker.blockVerify(this.serialize(),\n                    transactionValid, time.now(), GenesisConfig.GENESIS_HASH.serialize(), GenesisConfig.NETWORK_ID);\n                this._valid = valid;\n                this.header._pow = Hash.unserialize(new SerialBuffer(pow));\n                this.interlink._hash = Hash.unserialize(new SerialBuffer(interlinkHash));\n                this.body._hash = Hash.unserialize(new SerialBuffer(bodyHash));\n            }\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} timeNow\n     * @returns {Promise.<boolean>}\n     */\n    async _verify(timeNow) {\n        // Check that the timestamp is not too far into the future.\n        if (this._header.timestamp * 1000 > timeNow + Block.TIMESTAMP_DRIFT_MAX * 1000) {\n            Log.w(Block, 'Invalid block - timestamp too far in the future');\n            return false;\n        }\n\n        // Check that the header hash matches the difficulty.\n        if (!(await this._header.verifyProofOfWork())) {\n            Log.w(Block, 'Invalid block - PoW verification failed');\n            return false;\n        }\n\n        // Check that the maximum block size is not exceeded.\n        if (this.serializedSize > Policy.BLOCK_SIZE_MAX) {\n            Log.w(Block, 'Invalid block - max block size exceeded');\n            return false;\n        }\n\n        // Verify that the interlink is valid.\n        if (!this._verifyInterlink()) {\n            return false;\n        }\n\n        // XXX Verify the body only if it is present.\n        if (this.isFull() && !this._verifyBody()) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyInterlink() {\n        // Skip check for genesis block due to the cyclic dependency (since the interlink hash contains the genesis block hash).\n        if (this.height === 1 && this._header.interlinkHash.equals(new Hash(null))) {\n            return true;\n        }\n\n        // Check that the interlinkHash given in the header matches the actual interlinkHash.\n        const interlinkHash = this._interlink.hash();\n        if (!this._header.interlinkHash.equals(interlinkHash)) {\n            Log.w(Block, 'Invalid block - interlink hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyBody() {\n        // Check that the body is valid.\n        if (!this._body.verify()) {\n            return false;\n        }\n\n        // Check that bodyHash given in the header matches the actual body hash.\n        const bodyHash = this._body.hash();\n        if (!this._header.bodyHash.equals(bodyHash)) {\n            Log.w(Block, 'Invalid block - body hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isImmediateSuccessorOf(predecessor) {\n        // Check the header.\n        if (!this._header.isImmediateSuccessorOf(predecessor.header)) {\n            return false;\n        }\n\n        // Check that the interlink is correct.\n        const interlink = await predecessor.getNextInterlink(this.target, this.version);\n        if (!this._interlink.equals(interlink)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isInterlinkSuccessorOf(predecessor) {\n        // Check that the height is higher than the predecessor's.\n        if (this._header.height <= predecessor.header.height) {\n            Log.v(Block, 'No interlink successor - height');\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this._header.timestamp < predecessor.header.timestamp) {\n            Log.v(Block, 'No interlink successor - timestamp');\n            return false;\n        }\n\n        // Check that the predecessor is contained in this block's interlink and verify its position.\n        const prevHash = predecessor.hash();\n        if (!GenesisConfig.GENESIS_HASH.equals(prevHash)) {\n            const prevPow = await predecessor.pow();\n            const targetHeight = BlockUtils.getTargetHeight(this.target);\n            let blockFound = false;\n\n            let depth = 0;\n            for (; depth < this._interlink.length; depth++) {\n                if (prevHash.equals(this._interlink.hashes[depth])) {\n                    blockFound = true;\n                    if (!BlockUtils.isProofOfWork(prevPow, Math.pow(2, targetHeight - depth))) {\n                        Log.v(Block, 'No interlink successor - invalid position in interlink');\n                        return false;\n                    }\n                }\n            }\n\n            if (!blockFound) {\n                Log.v(Block, 'No interlink successor - not in interlink');\n                return false;\n            }\n        }\n\n        // If the predecessor happens to be the immediate predecessor, check additionally:\n        // - that the height of the successor is one higher\n        // - that the interlink is correct.\n        if (this._header.prevHash.equals(prevHash)) {\n            if (this._header.height !== predecessor.header.height + 1) {\n                Log.v(Block, 'No interlink successor - immediate height');\n                return false;\n            }\n\n            const interlink = await predecessor.getNextInterlink(this.target, this.version);\n            const interlinkHash = interlink.hash();\n            if (!this._header.interlinkHash.equals(interlinkHash)) {\n                Log.v(Block, 'No interlink successor - immediate interlink');\n                return false;\n            }\n        }\n        // Otherwise, if the prevHash doesn't match but the blocks should be adjacent according to their height fields,\n        // this cannot be a valid successor of predecessor.\n        else if (this._header.height === predecessor.height.height + 1) {\n            Log.v(Block, 'No interlink successor - immediate height (2)');\n            return false;\n        }\n        // Otherwise, check that the interlink construction is valid given the information we have.\n        else {\n            // TODO Take different targets into account.\n\n            // The number of new blocks in the interlink is bounded by the height difference.\n            /** @type {HashSet.<Hash>} */\n            const hashes = new HashSet();\n            hashes.addAll(this._interlink.hashes);\n            hashes.removeAll(predecessor.interlink.hashes);\n            if (hashes.length > this._header.height - predecessor.header.height) {\n                Log.v(Block, 'No interlink successor - too many new blocks');\n                return false;\n            }\n\n            // Check that the interlink is not too short.\n            const thisDepth = BlockUtils.getTargetDepth(this.target);\n            const prevDepth = BlockUtils.getTargetDepth(predecessor.target);\n            const depthDiff = thisDepth - prevDepth;\n            if (this._interlink.length < predecessor.interlink.length - depthDiff) {\n                Log.v(Block, 'No interlink successor - interlink too short');\n                return false;\n            }\n\n            // If the same block is found in both interlinks, all blocks at lower depths must be the same in both interlinks.\n            let commonBlock = false;\n            const thisInterlink = this._interlink.hashes;\n            const prevInterlink = predecessor.interlink.hashes;\n            for (let i = 1; i < prevInterlink.length && i - depthDiff < thisInterlink.length; i++) {\n                if (prevInterlink[i].equals(thisInterlink[i - depthDiff])) {\n                    commonBlock = true;\n                }\n                else if (commonBlock) {\n                    Log.v(Block, 'No interlink successor - invalid common suffix');\n                    return false;\n                }\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isSuccessorOf(predecessor) {\n        // TODO Improve this! Lots of duplicate checks.\n        return (await this.isImmediateSuccessorOf(predecessor)) || (await this.isInterlinkSuccessorOf(predecessor));\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @param {number} [nextVersion]\n     * @returns {Promise.<BlockInterlink>}\n     */\n    async getNextInterlink(nextTarget, nextVersion = BlockHeader.CURRENT_VERSION) {\n        /** @type {Array.<Hash>} */\n        const hashes = [];\n        const hash = this.hash();\n\n        // Compute how many times this blockHash should be included in the next interlink.\n        const thisPowDepth = BlockUtils.getHashDepth(await this.pow());\n        const nextTargetDepth = BlockUtils.getTargetDepth(nextTarget);\n        const numOccurrences = Math.max(thisPowDepth - nextTargetDepth + 1, 0);\n\n        // Push this blockHash numOccurrences times onto the next interlink.\n        for (let i = 0; i < numOccurrences; i++) {\n            hashes.push(hash);\n        }\n\n        // Compute how many blocks to omit from the beginning of this interlink.\n        const thisTargetDepth = BlockUtils.getTargetDepth(this.target);\n        const targetOffset = nextTargetDepth - thisTargetDepth;\n        const interlinkOffset = numOccurrences + targetOffset;\n\n        // Push the remaining hashes from this interlink.\n        for (let i = interlinkOffset; i < this.interlink.length; i++) {\n            hashes.push(this.interlink.hashes[i]);\n        }\n        \n        return new BlockInterlink(hashes, hash);\n    }\n\n    /**\n     * @param {Block|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Block\n            && this._header.equals(o._header)\n            && this._interlink.equals(o._interlink)\n            && (this._body ? this._body.equals(o._body) : !o._body);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isLight() {\n        return !this._body;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isFull() {\n        return !!this._body;\n    }\n\n    /**\n     * @returns {Block}\n     */\n    toLight() {\n        return this.isLight() ? this : new Block(this._header, this._interlink);\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @returns {Block}\n     */\n    toFull(body) {\n        return this.isFull() ? this : new Block(this._header, this._interlink, body);\n    }\n\n    /**\n     * @type {BlockHeader}\n     */\n    get header() {\n        return this._header;\n    }\n\n    /**\n     * @type {BlockInterlink}\n     */\n    get interlink() {\n        return this._interlink;\n    }\n\n    /**\n     * @type {BlockBody}\n     */\n    get body() {\n        if (this.isLight()) {\n            throw 'Cannot access body of light block';\n        }\n        return this._body;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get version() {\n        return this._header.version;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get prevHash() {\n        return this._header.prevHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get bodyHash() {\n        return this._header.bodyHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get accountsHash() {\n        return this._header.accountsHash;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nBits() {\n        return this._header.nBits;\n    }\n\n    /**\n     * @type {number}\n     */\n    get target() {\n        return this._header.target;\n    }\n\n    /**\n     * @type {number}\n     */\n    get difficulty() {\n        return this._header.difficulty;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this._header.height;\n    }\n    \n    /**\n     * @type {number}\n     */\n    get timestamp() {\n        return this._header.timestamp;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nonce() {\n        return this._header.nonce;\n    }\n\n    /**\n     * @type {Address}\n     */\n    get minerAddr() {\n        return this._body.minerAddr;\n    }\n\n    /**\n     * @type {Array.<Transaction>}\n     */\n    get transactions() {\n        return this._body.transactions;\n    }\n\n    /**\n     * @type {number}\n     */\n    get transactionCount() {\n        return this._body.transactionCount;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Hash}\n     */\n    hash(buf) {\n        return this._header.hash(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Promise.<Hash>}\n     */\n    pow(buf) {\n        return this._header.pow(buf);\n    }\n\n}\nBlock.TIMESTAMP_DRIFT_MAX = 600 /* seconds */; // 10 minutes\nClass.register(Block);\n","/**\n * @abstract\n */\nclass Transaction {\n    /**\n     * @param {Transaction.Format} format\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     * @param {number} [networkId]\n     */\n    constructor(format, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId = GenesisConfig.NETWORK_ID) {\n        if (!(sender instanceof Address)) throw new Error('Malformed sender');\n        if (!NumberUtils.isUint8(senderType)) throw new Error('Malformed sender type');\n        if (!(recipient instanceof Address)) throw new Error('Malformed recipient');\n        if (!NumberUtils.isUint8(recipientType)) throw new Error('Malformed recipient type');\n        if (!NumberUtils.isUint64(value) || value === 0) throw new Error('Malformed value');\n        if (!NumberUtils.isUint64(fee)) throw new Error('Malformed fee');\n        if (!NumberUtils.isUint32(validityStartHeight)) throw new Error('Malformed validityStartHeight');\n        if (!NumberUtils.isUint8(flags) && (flags & ~(Transaction.Flag.ALL)) > 0) throw new Error('Malformed flags');\n        if (!(data instanceof Uint8Array) || !(NumberUtils.isUint16(data.byteLength))) throw new Error('Malformed data');\n        if (proof && (!(proof instanceof Uint8Array) || !(NumberUtils.isUint16(proof.byteLength)))) throw new Error('Malformed proof');\n        if (!NumberUtils.isUint8(networkId)) throw new Error('Malformed networkId');\n\n        /** @type {Transaction.Format} */\n        this._format = format;\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Account.Type} */\n        this._senderType = senderType;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Account.Type} */\n        this._recipientType = recipientType;\n        /** @type {number} */\n        this._value = value;\n        /** @type {number} */\n        this._fee = fee;\n        /** @type {number} */\n        this._networkId = networkId;\n        /** @type {number} */\n        this._validityStartHeight = validityStartHeight;\n        /** @type {Transaction.Flag | *} */\n        this._flags = flags;\n        /** @type {Uint8Array} */\n        this._data = data;\n        /** @type {Uint8Array} */\n        this._proof = proof;\n\n        if (this._recipient === Address.CONTRACT_CREATION) this._recipient = this.getContractCreationAddress();\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const format = /** @type {Transaction.Format} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Transaction.FORMAT_MAP.has(format)) throw new Error('Invalid transaction type');\n        return Transaction.FORMAT_MAP.get(format).unserialize(buf);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n        buf.writeUint16(this._data.byteLength);\n        buf.write(this._data);\n        this._sender.serialize(buf);\n        buf.writeUint8(this._senderType);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._recipientType);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._networkId);\n        buf.writeUint8(this._flags);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return /*dataSize*/ 2\n            + this._data.byteLength\n            + this._sender.serializedSize\n            + /*senderType*/ 1\n            + this._recipient.serializedSize\n            + /*recipientType*/ 1\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*networkId*/ 1\n            + /*flags*/ 1;\n    }\n\n    /**\n     * @param {number} [networkId]\n     * @returns {boolean}\n     */\n    verify(networkId) {\n        if (this._valid === undefined) {\n            this._valid = this._verify(networkId);\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} [networkId]\n     * @returns {boolean}\n     * @private\n     */\n    _verify(networkId = GenesisConfig.NETWORK_ID) {\n        if (this._networkId !== networkId) {\n            Log.w(Transaction, 'Transaction is not valid in this network', this);\n            return false;\n        }\n        // Check that sender != recipient.\n        if (this._recipient.equals(this._sender)) {\n            Log.w(Transaction, 'Sender and recipient must not match', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.has(this._senderType) || !Account.TYPE_MAP.has(this._recipientType)) {\n            Log.w(Transaction, 'Invalid account type', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for sender', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for recipient', this);\n            return false;\n        }\n        return true;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        throw new Error('Getter needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        throw new Error('Method needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        // Exclude the signature, we don't want transactions to be malleable.\n        this._hash = this._hash || Hash.light(this.serializeContent());\n        return this._hash;\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compare(o) {\n        if (this.fee / this.serializedSize > o.fee / o.serializedSize) return -1;\n        if (this.fee / this.serializedSize < o.fee / o.serializedSize) return 1;\n        if (this.serializedSize > o.serializedSize) return -1;\n        if (this.serializedSize < o.serializedSize) return 1;\n        if (this.fee > o.fee) return -1;\n        if (this.fee < o.fee) return 1;\n        if (this.value > o.value) return -1;\n        if (this.value < o.value) return 1;\n        return this.compareBlockOrder(o);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compareBlockOrder(o) {\n        // This function must return 0 iff this.equals(o).\n        const recCompare = this._recipient.compare(o._recipient);\n        if (recCompare !== 0) return recCompare;\n        if (this._validityStartHeight < o._validityStartHeight) return -1;\n        if (this._validityStartHeight > o._validityStartHeight) return 1;\n        if (this._fee > o._fee) return -1;\n        if (this._fee < o._fee) return 1;\n        if (this._value > o._value) return -1;\n        if (this._value < o._value) return 1;\n        const senderCompare = this._sender.compare(o._sender);\n        if (senderCompare !== 0) return senderCompare;\n        if (this._recipientType < o._recipientType) return -1;\n        if (this._recipientType > o._recipientType) return 1;\n        if (this._senderType < o._senderType) return -1;\n        if (this._senderType > o._senderType) return 1;\n        if (this._flags < o._flags) return -1;\n        if (this._flags > o._flags) return 1;\n        return BufferUtils.compare(this._data, o._data);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {boolean}\n     */\n    equals(o) {\n        // This ignores format and proof to be consistent with hash():\n        //   tx1.hash() == tx2.hash() iff tx1.equals(t2)\n        return o instanceof Transaction\n            && this._sender.equals(o._sender)\n            && this._senderType === o._senderType\n            && this._recipient.equals(o._recipient)\n            && this._recipientType === o._recipientType\n            && this._value === o._value\n            && this._fee === o._fee\n            && this._validityStartHeight === o._validityStartHeight\n            && this._networkId === o._networkId\n            && this._flags === o._flags\n            && BufferUtils.equals(this._data, o._data);\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `Transaction{`\n            + `sender=${this._sender.toBase64()}, `\n            + `recipient=${this._recipient.toBase64()}, `\n            + `value=${this._value}, `\n            + `fee=${this._fee}, `\n            + `validityStartHeight=${this._validityStartHeight}, `\n            + `networkId=${this._networkId}`\n            + `}`;\n    }\n\n    /**\n     * @return {Address}\n     */\n    getContractCreationAddress() {\n        const tx = Transaction.unserialize(this.serialize());\n        tx._recipient = Address.NULL;\n        tx._hash = null;\n        return Address.fromHash(tx.hash());\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Account.Type} */\n    get senderType() {\n        return this._senderType;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Account.Type} */\n    get recipientType() {\n        return this._recipientType;\n    }\n\n    /** @type {number} */\n    get value() {\n        return this._value;\n    }\n\n    /** @type {number} */\n    get fee() {\n        return this._fee;\n    }\n\n    /** @type {number} */\n    get feePerByte() {\n        return this._fee / this.serializedSize;\n    }\n\n    /** @type {number} */\n    get networkId() {\n        return this._networkId;\n    }\n\n    /** @type {number} */\n    get validityStartHeight() {\n        return this._validityStartHeight;\n    }\n\n    /** @type {number} */\n    get flags() {\n        return this._flags;\n    }\n\n    /**\n     * @param {Transaction.Flag} flag\n     * @returns {boolean}\n     */\n    hasFlag(flag) {\n        return (this._flags & flag) > 0;\n    }\n\n    /** @type {Uint8Array} */\n    get data() {\n        return this._data;\n    }\n\n    /** @type {Uint8Array} */\n    get proof() {\n        return this._proof;\n    }\n\n    // Sender proof is set by the Wallet after signing a transaction.\n    /** @type {Uint8Array} */\n    set proof(proof) {\n        this._proof = proof;\n    }\n}\n\n/**\n * Enum for Transaction formats.\n * @enum\n */\nTransaction.Format = {\n    BASIC: 0,\n    EXTENDED: 1\n};\n/**\n * @enum\n */\nTransaction.Flag = {\n    NONE: 0,\n    CONTRACT_CREATION: 0b1,\n    ALL: 0b1\n};\n/** @type {Map.<Transaction.Format, {unserialize: function(buf: SerialBuffer):Transaction}>} */\nTransaction.FORMAT_MAP = new Map();\n\nClass.register(Transaction);\n","class SignatureProof {\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    static verifyTransaction(transaction) {\n        try {\n            const buffer = new SerialBuffer(transaction.proof);\n            const proof = SignatureProof.unserialize(buffer);\n\n            // Reject proof if it is longer than needed.\n            if (buffer.readPos !== buffer.byteLength) {\n                Log.w(SignatureProof, 'Invalid SignatureProof - overlong');\n                return false;\n            }\n\n            return proof.verify(transaction.sender, transaction.serializeContent());\n        } catch (e) {\n            Log.w(SignatureProof, `Failed to verify transaction: ${e.message || e}`, e);\n            return false;\n        }\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static singleSig(publicKey, signature) {\n        return new SignatureProof(publicKey, new MerklePath([]), signature);\n    }\n\n    /**\n     * @param {PublicKey} signerKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static multiSig(signerKey, publicKeys, signature) {\n        const merklePath = MerklePath.compute(publicKeys, signerKey);\n        return new SignatureProof(signerKey, merklePath, signature);\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {MerklePath} merklePath\n     * @param {Signature} signature\n     */\n    constructor(publicKey, merklePath, signature) {\n        if (!(publicKey instanceof PublicKey)) throw new Error('Malformed publickKey');\n        if (!(merklePath instanceof MerklePath)) throw new Error('Malformed merklePath');\n        if (signature && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        /**\n         * @type {PublicKey}\n         * @private\n         */\n        this._publicKey = publicKey;\n        /**\n         * @type {MerklePath}\n         * @private\n         */\n        this._merklePath = merklePath;\n        /**\n         * @type {Signature}\n         * @private\n         */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {SignatureProof}\n     */\n    static unserialize(buf) {\n        const publicKey = PublicKey.unserialize(buf);\n        const merklePath = MerklePath.unserialize(buf);\n        const signature = Signature.unserialize(buf);\n        return new SignatureProof(publicKey, merklePath, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._publicKey.serialize(buf);\n        this._merklePath.serialize(buf);\n\n        // The SignatureProof is sometimes serialized before the signature is set (e.g. when creating transactions).\n        // Simply don't serialize the signature if it's missing as this should never go over the wire.\n        // We always expect the signature to be present when unserializing.\n        if (this._signature) {\n            this._signature.serialize(buf);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._publicKey.serializedSize\n            + this._merklePath.serializedSize\n            + (this._signature ? this._signature.serializedSize : 0);\n    }\n\n    /**\n     * @param {SignatureProof} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof SignatureProof\n            && this._publicKey.equals(o._publicKey)\n            && this._merklePath.equals(o._merklePath)\n            && (this._signature ? this._signature.equals(o._signature) : this._signature === o._signature);\n    }\n\n    /**\n     * @param {?Address} sender\n     * @param {Uint8Array} data\n     * @returns {boolean}\n     */\n    verify(sender, data) {\n        if (sender !== null && !this.isSignedBy(sender)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signer does not match sender address');\n            return false;\n        }\n\n        if (!this._signature) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is missing');\n            return false;\n        }\n\n        if (!this._signature.verify(this._publicKey, data)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is invalid');\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Address} sender\n     * @returns {boolean}\n     */\n    isSignedBy(sender) {\n        const merkleRoot = this._merklePath.computeRoot(this._publicKey);\n        const signerAddr = Address.fromHash(merkleRoot);\n        return signerAddr.equals(sender);\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {MerklePath} */\n    get merklePath() {\n        return this._merklePath;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {Signature} */\n    set signature(signature) {\n        this._signature = signature;\n    }\n}\n\nClass.register(SignatureProof);\n","class BasicTransaction extends Transaction {\n    /**\n     * @param {PublicKey} senderPubKey\n     * @param {Address} recipient\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Signature} [signature]\n     * @param {number} [networkId]\n     */\n    constructor(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId) {\n        if (!(senderPubKey instanceof PublicKey)) throw new Error('Malformed senderPubKey');\n        // Signature may be initially empty and can be set later.\n        if (signature !== undefined && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        const proof = SignatureProof.singleSig(senderPubKey, signature);\n        super(Transaction.Format.BASIC, senderPubKey.toAddress(), Account.Type.BASIC, recipient, Account.Type.BASIC, value, fee, validityStartHeight, Transaction.Flag.NONE, new Uint8Array(0), proof.serialize(), networkId);\n\n        /**\n         * @type {SignatureProof}\n         * @private\n         */\n        this._signatureProof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        Assert.that(type === Transaction.Format.BASIC);\n\n        const senderPubKey = PublicKey.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const networkId = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new BasicTransaction(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.BASIC);\n        this.senderPubKey.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._networkId);\n        this.signature.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.senderPubKey.serializedSize\n            + this._recipient.serializedSize\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*networkId*/ 1\n            + this.signature.serializedSize;\n    }\n\n    /**\n     * @type {PublicKey}\n     */\n    get senderPubKey() {\n        return this._signatureProof.publicKey;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    get signature() {\n        return this._signatureProof.signature;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    set signature(signature) {\n        this._signatureProof.signature = signature;\n        this._proof = this._signatureProof.serialize();\n    }\n}\nTransaction.FORMAT_MAP.set(Transaction.Format.BASIC, BasicTransaction);\nClass.register(BasicTransaction);\n","class ExtendedTransaction extends Transaction {\n\n    /**\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     * @param {number} [networkId]\n     */\n    constructor(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof = new Uint8Array(0), networkId) {\n        super(Transaction.Format.EXTENDED, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = /** @type {Transaction.Format} */ buf.readUint8();\n        Assert.that(type === Transaction.Format.EXTENDED);\n\n        const dataSize = buf.readUint16();\n        const data = buf.read(dataSize);\n        const sender = Address.unserialize(buf);\n        const senderType = /** @type {Account.Type} */ buf.readUint8();\n        const recipient = Address.unserialize(buf);\n        const recipientType = /** @type {Account.Type} */ buf.readUint8();\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const networkId = buf.readUint8();\n        const flags = buf.readUint8();\n        const proofSize = buf.readUint16();\n        const proof = buf.read(proofSize);\n        return new ExtendedTransaction(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.EXTENDED);\n        this.serializeContent(buf);\n        buf.writeUint16(this._proof.byteLength);\n        buf.write(this._proof);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.serializedContentSize\n            + /*proofSize*/ 2\n            + this._proof.byteLength;\n    }\n}\n\nTransaction.FORMAT_MAP.set(Transaction.Format.EXTENDED, ExtendedTransaction);\nClass.register(ExtendedTransaction);\n"]}