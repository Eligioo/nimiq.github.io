if("undefined"==typeof Nimiq)var Nimiq="undefined"!=typeof window?window:{};var Proxy;!function(e){(Nimiq=e="undefined"!=typeof e?e:{})._currentScript||(Nimiq._currentScript=document.currentScript);if(!Nimiq._currentScript){const e=document.getElementsByTagName("script");Nimiq._currentScript=e[e.length-1]}Nimiq._path||(Nimiq._currentScript&&-1!==Nimiq._currentScript.src.indexOf("/")?Nimiq._path=Nimiq._currentScript.src.substring(0,Nimiq._currentScript.src.lastIndexOf("/")+1):Nimiq._path="./");class Class{static get scope(){return"undefined"!=typeof e?e:window}static register(t){"undefined"!=typeof e&&(e[t.name]=t)}}Class.register(Class);class LogNative{constructor(){this._global_level=Log.INFO;this._tag_levels={};try{if(window.localStorage)try{let t=window.localStorage.getItem("log_tag_levels");t&&"string"==typeof t&&(t=JSON.parse(t));t&&"object"==typeof t&&(this._tag_levels=t)}catch(e){console.warn("Failed to load log configuration from local storage.")}}catch(e){}}isLoggable(e,t){return e&&this._tag_levels[e]?this._tag_levels[e]<=t:this._tag_levels["*"]?this._tag_levels["*"]<=t:this._global_level<=t}setLoggable(e,t){e&&e.name&&(e=e.name);this._tag_levels[e]=t;window.localStorage&&window.localStorage.setItem("log_tag_levels",JSON.stringify(this._tag_levels))}msg(e,t,r){t&&t.name&&(t=t.name);if(this.isLoggable(t,e)){t&&r.unshift(t+":");r.unshift(`[${Log.Level.toStringTag(e)} ${(new Date).toTimeString().substr(0,8)}]`);console.error&&e>=Log.ERROR?console.error.apply(console,r):console.warn&&e>=Log.WARNING?console.warn.apply(console,r):console.info&&e>=Log.INFO?console.info.apply(console,r):console.debug&&e>=Log.DEBUG?console.debug.apply(console,r):console.trace&&e<=Log.TRACE?console.trace.apply(console,r):console.log.apply(console,r)}}}Class.register(LogNative);class Log{static get instance(){Log._instance||(Log._instance=new Log(new LogNative));return Log._instance}constructor(e){this._native=e}setLoggable(e,t){this._native.setLoggable(e,Log.Level.get(t))}get level(){return this._native._global_level}set level(e){this._native._global_level=Log.Level.get(e)}msg(e,t,r){if(this._native.isLoggable(t,e)){for(let e=0;e<r.length;++e){"function"==typeof r[e]&&(r[e]=r[e]());"object"==typeof r[e]&&("function"==typeof r[e].toString?r[e]=r[e].toString():r[e].constructor&&r[e].constructor.name?r[e]=`{Object: ${r[e].constructor.name}}`:r[e]="{Object}")}this._native.msg(e,t,r)}}static d(e,t,...r){if(arguments.length>=2){e=arguments[0];r=Array.prototype.slice.call(arguments,1)}else{e=undefined;r=Array.prototype.slice.call(arguments,0)}Log.instance.msg(Log.DEBUG,e,r)}static e(e,t,...r){if(arguments.length>=2){e=arguments[0];r=Array.prototype.slice.call(arguments,1)}else{e=undefined;r=Array.prototype.slice.call(arguments,0)}Log.instance.msg(Log.ERROR,e,r)}static i(e,t,...r){if(arguments.length>=2){e=arguments[0];r=Array.prototype.slice.call(arguments,1)}else{e=undefined;r=Array.prototype.slice.call(arguments,0)}Log.instance.msg(Log.INFO,e,r)}static v(e,t,...r){if(arguments.length>=2){e=arguments[0];r=Array.prototype.slice.call(arguments,1)}else{e=undefined;r=Array.prototype.slice.call(arguments,0)}Log.instance.msg(Log.VERBOSE,e,r)}static w(e,t,...r){if(arguments.length>=2){e=arguments[0];r=Array.prototype.slice.call(arguments,1)}else{e=undefined;r=Array.prototype.slice.call(arguments,0)}Log.instance.msg(Log.WARNING,e,r)}static t(e,t,...r){if(arguments.length>=2){e=arguments[0];r=Array.prototype.slice.call(arguments,1)}else{e=undefined;r=Array.prototype.slice.call(arguments,0)}Log.instance.msg(Log.TRACE,e,r)}}Log.Level={TRACE:1,VERBOSE:2,DEBUG:3,INFO:4,WARNING:5,ERROR:6,ASSERT:7,toStringTag:function(e){switch(e){case Log.Level.TRACE:return"T";case Log.Level.VERBOSE:return"V";case Log.Level.DEBUG:return"D";case Log.Level.INFO:return"I";case Log.Level.WARNING:return"W";case Log.Level.ERROR:return"E";case Log.Level.ASSERT:return"A";default:return"*"}},toString:function(e){switch(e){case Log.Level.TRACE:return"trace";case Log.Level.VERBOSE:return"verbose";case Log.Level.DEBUG:return"debug";case Log.Level.INFO:return"info";case Log.Level.WARNING:return"warn";case Log.Level.ERROR:return"error";case Log.Level.ASSERT:return"assert";default:return"unknown"}},get:function(e){if("number"==typeof e)return e;if(!isNaN(parseInt(e)))return parseInt(e);switch(e.toLowerCase()){case"t":case"trace":return Log.Level.TRACE;case"v":case"verbose":return Log.Level.VERBOSE;case"d":case"debug":return Log.Level.DEBUG;case"i":case"info":return Log.Level.INFO;case"w":case"warn":case"warning":return Log.Level.WARNING;case"e":case"error":case"exception":return Log.Level.ERROR;case"a":case"assert":case"assertion":return Log.Level.ASSERT}return 0}};Log.TRACE=Log.Level.TRACE;Log.VERBOSE=Log.Level.VERBOSE;Log.DEBUG=Log.Level.DEBUG;Log.INFO=Log.Level.INFO;Log.WARNING=Log.Level.WARNING;Log.ERROR=Log.Level.ERROR;Log.ASSERT=Log.Level.ASSERT;Log._instance=null;Log.d.tag=(e=>Log.d.bind(null,e));Log.e.tag=(e=>Log.e.bind(null,e));Log.i.tag=(e=>Log.i.bind(null,e));Log.v.tag=(e=>Log.v.bind(null,e));Log.w.tag=(e=>Log.w.bind(null,e));Log.t.tag=(e=>Log.t.bind(null,e));Class.register(Log);class Observable{static get WILDCARD(){return"*"}constructor(){this._listeners=new Map}_offAll(){this._listeners.clear()}on(e,t){if(this._listeners.has(e))return this._listeners.get(e).push(t)-1;this._listeners.set(e,[t]);return 0}off(e,t){this._listeners.has(e)&&this._listeners.get(e)[t]&&delete this._listeners.get(e)[t]}fire(e,...t){const r=[];if(this._listeners.has(e)){const i=this._listeners.get(e);for(const e in i){if(isNaN(e))continue;const s=i[e].apply(null,t);s instanceof Promise&&r.push(s)}}if(this._listeners.has(Observable.WILDCARD)){const e=this._listeners.get(Observable.WILDCARD);for(const t in e){if(isNaN(t))continue;const i=e[t].apply(null,arguments);i instanceof Promise&&r.push(i)}}return r.length>0?Promise.all(r):null}bubble(e,...t){for(const r of t){let t;t=r===Observable.WILDCARD?function(){this.fire.apply(this,arguments)}:function(){this.fire.apply(this,[r,...arguments])};e.on(r,t.bind(this))}}}Class.register(Observable);class CryptoLib{static get instance(){if(!CryptoLib._instance){const e={};e.getRandomValues=(window.crypto||window.msCrypto).getRandomValues.bind(window.crypto);CryptoLib._instance=e}return CryptoLib._instance}}CryptoLib._instance=null;Class.register(CryptoLib);class ArrayUtils{static randomElement(e){return e[Math.floor(Math.random()*e.length)]}static subarray(e,t,r){function clamp(e,t,r){return e<t?t:e>r?r:e}t===undefined&&(t=0);r===undefined&&(r=e.byteLength);t=clamp(t,0,e.byteLength);let i=(r=clamp(r,0,e.byteLength))-t;i<0&&(i=0);return new Uint8Array(e.buffer,e.byteOffset+t,i)}static*k_combinations(e,t){const r=e.length;if(t>r)return;const i=Array.from(new Array(t),(e,t)=>t);yield i.map(t=>e[t]);const s=Array.from(new Array(t),(e,r)=>t-r-1);for(;;){let n=t-1,a=!1;for(n of s)if(i[n]!==n+r-t){a=!0;break}if(!a)return;i[n]+=1;for(const e of Array.from(new Array(t-n-1),(e,t)=>n+t+1))i[e]=i[e-1]+1;yield i.map(t=>e[t])}}}Class.register(ArrayUtils);class Assert{static that(e,t="Assertion failed"){if(!e)throw new Error(t)}}Class.register(Assert);class BufferUtils{static toAscii(e){return String.fromCharCode.apply(null,new Uint8Array(e))}static fromAscii(e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t[r]=e.charCodeAt(r);return t}static _codePointTextDecoder(e){if("undefined"==typeof TextDecoder)throw new Error("TextDecoder not supported");if(null===BufferUtils._ISO_8859_15_DECODER)throw new Error("TextDecoder does not supprot iso-8859-15");if(BufferUtils._ISO_8859_15_DECODER===undefined)try{BufferUtils._ISO_8859_15_DECODER=new TextDecoder("iso-8859-15")}finally{BufferUtils._ISO_8859_15_DECODER=null}return BufferUtils._ISO_8859_15_DECODER.decode(e).replace("€","¤").replace("Š","¦").replace("š","¨").replace("Ž","´").replace("ž","¸").replace("Œ","¼").replace("œ","½").replace("Ÿ","¾")}static _tripletToBase64(e){return BufferUtils._BASE64_LOOKUP[e>>18&63]+BufferUtils._BASE64_LOOKUP[e>>12&63]+BufferUtils._BASE64_LOOKUP[e>>6&63]+BufferUtils._BASE64_LOOKUP[63&e]}static _base64encodeChunk(e,t,r){let i;const s=[];for(let n=t;n<r;n+=3){i=(e[n]<<16&16711680)+(e[n+1]<<8&65280)+(255&e[n+2]);s.push(BufferUtils._tripletToBase64(i))}return s.join("")}static _base64fromByteArray(e){let t;const r=e.length,i=r%3;let s="";const n=[];for(let a=0,o=r-i;a<o;a+=16383)n.push(BufferUtils._base64encodeChunk(e,a,a+16383>o?o:a+16383));if(1===i){t=e[r-1];s+=BufferUtils._BASE64_LOOKUP[t>>2];s+=BufferUtils._BASE64_LOOKUP[t<<4&63];s+="=="}else if(2===i){t=(e[r-2]<<8)+e[r-1];s+=BufferUtils._BASE64_LOOKUP[t>>10];s+=BufferUtils._BASE64_LOOKUP[t>>4&63];s+=BufferUtils._BASE64_LOOKUP[t<<2&63];s+="="}n.push(s);return n.join("")}static toBase64(e){if(PlatformUtils.isNodeJs())return new Buffer(e).toString("base64");if("undefined"!=typeof TextDecoder&&null!==BufferUtils._ISO_8859_15_DECODER)try{return btoa(BufferUtils._codePointTextDecoder(new Uint8Array(e)))}catch(t){}return BufferUtils._base64fromByteArray(new Uint8Array(e))}static fromBase64(e){return new SerialBuffer(Uint8Array.from(atob(e),e=>e.charCodeAt(0)))}static toBase64Url(e){return BufferUtils.toBase64(e).replace(/\//g,"_").replace(/\+/g,"-").replace(/=/g,".")}static fromBase64Url(e){return new SerialBuffer(Uint8Array.from(atob(e.replace(/_/g,"/").replace(/-/g,"+").replace(/\./g,"=")),e=>e.charCodeAt(0)))}static toBase32(e,t=BufferUtils.BASE32_ALPHABET.NIMIQ){let r,i,s,n=3,a=0,o="";for(s=0;s<e.length;s++){o+=t[31&(i=a|(r=e[s])>>n)];n>5&&(o+=t[31&(i=r>>(n-=5))]);a=r<<(n=5-n);n=8-n}3!==n&&(o+=t[31&a]);for(;o.length%8!=0&&33===t.length;)o+=t[32];return o}static fromBase32(e,t=BufferUtils.BASE32_ALPHABET.NIMIQ){const r=[];t.toUpperCase().split("").forEach((e,t)=>{e in r||(r[e]=t)});let i,s=8,n=0,a=[];e.toUpperCase().split("").forEach(e=>{if(33!==t.length||e!==t[32]){i=255&r[e];if((s-=5)>0)n|=i<<s;else if(s<0){a.push(n|i>>-s);n=i<<(s+=8)&255}else{a.push(n|i);s=8;n=0}}});8!==s&&0!==n&&a.push(n);return new Uint8Array(a)}static toHex(e){let t="";for(let r=0;r<e.length;r++){const i=e[r];t+=BufferUtils.HEX_ALPHABET[i>>>4];t+=BufferUtils.HEX_ALPHABET[15&i]}return t}static fromHex(e){e=e.trim();return StringUtils.isHexBytes(e)?new SerialBuffer(Uint8Array.from(e.match(/.{2}/g)||[],e=>parseInt(e,16))):null}static concatTypedArrays(e,t){const r=new e.constructor(e.length+t.length);r.set(e,0);r.set(t,e.length);return r}static equals(e,t){if(e.length!==t.length)return!1;const r=new Uint8Array(e),i=new Uint8Array(t);for(let s=0;s<e.length;s++)if(r[s]!==i[s])return!1;return!0}static compare(e,t){if(e.length<t.length)return-1;if(e.length>t.length)return 1;for(let r=0;r<e.length;r++){if(e[r]<t[r])return-1;if(e[r]>t[r])return 1}return 0}static xor(e,t){const r=new Uint8Array(e.byteLength);for(let i=0;i<e.byteLength;++i)r[i]=e[i]^t[i];return r}}BufferUtils.BASE64_ALPHABET="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";BufferUtils.BASE32_ALPHABET={RFC4648:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",RFC4648_HEX:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",NIMIQ:"0123456789ABCDEFGHJKLMNPQRSTUVXY"};BufferUtils.HEX_ALPHABET="0123456789abcdef";BufferUtils._BASE64_LOOKUP=[];for(let t=0,r=BufferUtils.BASE64_ALPHABET.length;t<r;++t)BufferUtils._BASE64_LOOKUP[t]=BufferUtils.BASE64_ALPHABET[t];Class.register(BufferUtils);class SerialBuffer extends Uint8Array{constructor(e){super(e);this._view=new DataView(this.buffer);this._readPos=0;this._writePos=0}subarray(e,t){return ArrayUtils.subarray(this,e,t)}get readPos(){return this._readPos}set readPos(e){if(e<0||e>this.byteLength)throw`Invalid readPos ${e}`;this._readPos=e}get writePos(){return this._writePos}set writePos(e){if(e<0||e>this.byteLength)throw`Invalid writePos ${e}`;this._writePos=e}reset(){this._readPos=0;this._writePos=0}read(e){const t=this.subarray(this._readPos,this._readPos+e);this._readPos+=e;return t}write(e){this.set(e,this._writePos);this._writePos+=e.byteLength}readUint8(){return this._view.getUint8(this._readPos++)}writeUint8(e){this._view.setUint8(this._writePos++,e)}readUint16(){const e=this._view.getUint16(this._readPos);this._readPos+=2;return e}writeUint16(e){this._view.setUint16(this._writePos,e);this._writePos+=2}readUint32(){const e=this._view.getUint32(this._readPos);this._readPos+=4;return e}writeUint32(e){this._view.setUint32(this._writePos,e);this._writePos+=4}readUint64(){const e=this._view.getUint32(this._readPos)*Math.pow(2,32)+this._view.getUint32(this._readPos+4);if(!NumberUtils.isUint64(e))throw new Error("Malformed value");this._readPos+=8;return e}writeUint64(e){if(!NumberUtils.isUint64(e))throw new Error("Malformed value");this._view.setUint32(this._writePos,Math.floor(e/Math.pow(2,32)));this._view.setUint32(this._writePos+4,e);this._writePos+=8}readVarUint(){const e=this.readUint8();return e<253?e:253===e?this.readUint16():254===e?this.readUint32():this.readUint64()}writeVarUint(e){if(!NumberUtils.isUint64(e))throw new Error("Malformed value");if(e<253)this.writeUint8(e);else if(e<=65535){this.writeUint8(253);this.writeUint16(e)}else if(e<=4294967295){this.writeUint8(254);this.writeUint32(e)}else{this.writeUint8(255);this.writeUint64(e)}}static varUintSize(e){if(!NumberUtils.isUint64(e))throw new Error("Malformed value");return e<253?1:e<=65535?3:e<=4294967295?5:9}readFloat64(){const e=this._view.getFloat64(this._readPos);this._readPos+=8;return e}writeFloat64(e){this._view.setFloat64(this._writePos,e);this._writePos+=8}readString(e){const t=this.read(e);return BufferUtils.toAscii(t)}writeString(e,t){if(StringUtils.isMultibyte(e)||e.length!==t)throw"Malformed value/length";const r=BufferUtils.fromAscii(e);this.write(r)}readPaddedString(e){const t=this.read(e);let r=0;for(;r<e&&0!==t[r];)r++;const i=new Uint8Array(t.buffer,t.byteOffset,r);return BufferUtils.toAscii(i)}writePaddedString(e,t){if(StringUtils.isMultibyte(e)||e.length>t)throw"Malformed value/length";const r=BufferUtils.fromAscii(e);this.write(r);const i=t-r.byteLength;this.write(new Uint8Array(i))}readVarLengthString(){const e=this.readUint8();if(this._readPos+e>this.length)throw"Malformed length";const t=this.read(e);return BufferUtils.toAscii(t)}writeVarLengthString(e){if(StringUtils.isMultibyte(e)||!NumberUtils.isUint8(e.length))throw new Error("Malformed value");const t=BufferUtils.fromAscii(e);this.writeUint8(t.byteLength);this.write(t)}static varLengthStringSize(e){if(StringUtils.isMultibyte(e)||!NumberUtils.isUint8(e.length))throw new Error("Malformed value");return 1+e.length}}Class.register(SerialBuffer);class NumberUtils{static isUint8(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT8_MAX}static isUint16(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT16_MAX}static isUint32(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT32_MAX}static isUint64(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT64_MAX}static randomUint32(){return Math.floor(Math.random()*(NumberUtils.UINT32_MAX+1))}static randomUint64(){return Math.floor(Math.random()*(NumberUtils.UINT64_MAX+1))}}NumberUtils.UINT8_MAX=255;NumberUtils.UINT16_MAX=65535;NumberUtils.UINT32_MAX=4294967295;NumberUtils.UINT64_MAX=Number.MAX_SAFE_INTEGER;Class.register(NumberUtils);class MerklePath{constructor(e){if(!Array.isArray(e)||!NumberUtils.isUint8(e.length)||e.some(e=>!(e instanceof MerklePathNode)))throw new Error("Malformed nodes");this._nodes=e}static compute(e,t,r=MerkleTree._hash){const i=r(t),s=[];MerklePath._compute(e,i,s,r);return new MerklePath(s)}static _compute(e,t,r,i){const s=e.length;let n;if(0===s)return{containsLeaf:!1,inner:n=Hash.light(new Uint8Array(0))};if(1===s)return{containsLeaf:(n=i(e[0])).equals(t),inner:n};const a=Math.round(s/2),o=e.slice(0,a),l=e.slice(a),{containsLeaf:c,inner:u}=MerklePath._compute(o,t,r,i),{containsLeaf:h,inner:d}=MerklePath._compute(l,t,r,i);n=Hash.light(BufferUtils.concatTypedArrays(u.serialize(),d.serialize()));if(c){r.push(new MerklePathNode(d,!1));return{containsLeaf:!0,inner:n}}if(h){r.push(new MerklePathNode(u,!0));return{containsLeaf:!0,inner:n}}return{containsLeaf:!1,inner:n}}computeRoot(e,t=MerkleTree._hash){let r=t(e);for(const i of this._nodes){const e=i.left,t=i.hash,s=new SerialBuffer(2*t.serializedSize);e&&t.serialize(s);r.serialize(s);e||t.serialize(s);r=Hash.light(s)}return r}static _compress(e){const t=e.length,r=Math.ceil(t/8),i=new Uint8Array(r);for(let s=0;s<t;s++)e[s].left&&(i[Math.floor(s/8)]|=128>>>s%8);return i}static unserialize(e){const t=e.readUint8(),r=Math.ceil(t/8),i=e.read(r),s=[];for(let n=0;n<t;n++){const t=0!=(i[Math.floor(n/8)]&128>>>n%8),r=Hash.unserialize(e);s.push(new MerklePathNode(r,t))}return new MerklePath(s)}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).writeUint8(this._nodes.length);e.write(MerklePath._compress(this._nodes));for(const t of this._nodes)t.hash.serialize(e);return e}get serializedSize(){return 1+Math.ceil(this._nodes.length/8)+this._nodes.reduce((e,t)=>e+t.hash.serializedSize,0)}equals(e){return e instanceof MerklePath&&this._nodes.length===e._nodes.length&&this._nodes.every((t,r)=>t.equals(e._nodes[r]))}get nodes(){return this._nodes}}Class.register(MerklePath);class MerklePathNode{constructor(e,t){this._hash=e;this._left=t}get hash(){return this._hash}get left(){return this._left}equals(e){return e instanceof MerklePathNode&&this._hash.equals(e.hash)&&this._left===e.left}}Class.register(MerklePathNode);class PlatformUtils{static isBrowser(){return"undefined"!=typeof window}static isNodeJs(){return!PlatformUtils.isBrowser()&&"object"==typeof process&&"function"==typeof require}static supportsWebRTC(){return!!(PlatformUtils.isBrowser()?window.RTCPeerConnection||window.webkitRTCPeerConnection:null)}static isOnline(){return!PlatformUtils.isBrowser()||!("onLine"in window.navigator)||window.navigator.onLine}}Class.register(PlatformUtils);class StringUtils{static isMultibyte(e){return/[\uD800-\uDFFF]/.test(e)}static isHex(e){return/^[0-9A-Fa-f]*$/.test(e)}static isHexBytes(e,t){return!!StringUtils.isHex(e)&&(e.length%2==0&&("number"!=typeof t||e.length/2===t))}static commonPrefix(e,t){let r=0;for(;r<e.length&&e[r]===t[r];++r);return e.substr(0,r)}}Class.register(StringUtils);class Policy{static coinsToSatoshis(e){return Math.round(e*Policy.SATOSHIS_PER_COIN)}static satoshisToCoins(e){return e/Policy.SATOSHIS_PER_COIN}static supplyAfter(e){let t=Math.floor(e/Policy._supplyCacheInterval)*Policy._supplyCacheInterval;const r=(t=Math.max(0,Math.min(t,Policy._supplyCacheMax)))/Policy._supplyCacheInterval,i=Math.floor(e/Policy._supplyCacheInterval);let s=0===t?Policy.INITIAL_SUPPLY:Policy._supplyCache.get(t);for(let n=r;n<i;++n){t=n*Policy._supplyCacheInterval;const e=(n+1)*Policy._supplyCacheInterval-1;s=Policy._supplyAfter(s,e,t);Policy._supplyCache.set(e+1,s);Policy._supplyCacheMax=e+1}return Policy._supplyAfter(s,e,i*Policy._supplyCacheInterval)}static _supplyAfter(e,t,r=0){let i=e;for(let s=r;s<=t;++s)i+=Policy._blockRewardAt(i,s);return i}static blockRewardAt(e){const t=Policy.supplyAfter(e-1);return Policy._blockRewardAt(t,e)}static _blockRewardAt(e,t){if(t<=0)return 0;const r=Policy.TOTAL_SUPPLY-e;return t>=Policy.EMISSION_TAIL_START&&r>=Policy.EMISSION_TAIL_REWARD?Policy.EMISSION_TAIL_REWARD:(r-r%Policy.EMISSION_SPEED)/Policy.EMISSION_SPEED}}Policy.BLOCK_TIME=60;Policy.BLOCK_SIZE_MAX=1e5;Policy.BLOCK_TARGET_MAX=Math.pow(2,240);Policy.DIFFICULTY_BLOCK_WINDOW=120;Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR=2;Policy.TRANSACTION_VALIDITY_WINDOW=120;Policy.SATOSHIS_PER_COIN=1e5;Policy.TOTAL_SUPPLY=21e14;Policy.INITIAL_SUPPLY=252e12;Policy.EMISSION_SPEED=Math.pow(2,22);Policy.EMISSION_TAIL_START=48692960;Policy.EMISSION_TAIL_REWARD=4e3;Policy.M=240;Policy.K=120;Policy.DELTA=.1;Policy.NUM_BLOCKS_VERIFICATION=250;Policy.NUM_SNAPSHOTS_MAX=20;Policy._supplyCache=new Map;Policy._supplyCacheMax=0;Policy._supplyCacheInterval=5e3;Class.register(Policy);class Serializable{equals(e){return e instanceof Serializable&&BufferUtils.equals(this.serialize(),e.serialize())}compare(e){return BufferUtils.compare(this.serialize(),e.serialize())}hashCode(){return this.toBase64()}serialize(e){}toString(){return this.toBase64()}toBase64(){return BufferUtils.toBase64(this.serialize())}toHex(){return BufferUtils.toHex(this.serialize())}}Class.register(Serializable);class Hash extends Serializable{constructor(e,t=Hash.Algorithm.BLAKE2B){if(null===e)e=new Uint8Array(Hash.getSize(t));else{if(!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==Hash.getSize(t))throw new Error("Primitive: Invalid length")}super();this._obj=e;this._algorithm=t}static light(e){return Hash.blake2b(e)}static blake2b(e){return new Hash(Hash.computeBlake2b(e),Hash.Algorithm.BLAKE2B)}static hard(e){return Hash.argon2d(e)}static async argon2d(e){return new Hash(await(await CryptoWorker.getInstanceAsync()).computeArgon2d(e),Hash.Algorithm.ARGON2D)}static sha256(e){return new Hash(Hash.computeSha256(e),Hash.Algorithm.SHA256)}static compute(e,t){switch(t){case Hash.Algorithm.BLAKE2B:return Hash.blake2b(e);case Hash.Algorithm.SHA256:return Hash.sha256(e);default:throw new Error("Invalid hash algorithm")}}static unserialize(e,t=Hash.Algorithm.BLAKE2B){return new Hash(e.read(Hash.getSize(t)),t)}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).write(this._obj);return e}subarray(e,t){return this._obj.subarray(e,t)}get serializedSize(){return Hash.SIZE.get(this._algorithm)}get array(){return this._obj}get algorithm(){return this._algorithm}equals(e){return e instanceof Hash&&e._algorithm===this._algorithm&&super.equals(e)}static fromBase64(e){return new Hash(BufferUtils.fromBase64(e))}static fromHex(e){return new Hash(BufferUtils.fromHex(e))}static fromString(e){try{return Hash.fromHex(e)}catch(t){}try{return Hash.fromBase64(e)}catch(t){}throw new Error("Invalid hash format")}static isHash(e){return e instanceof Hash}static getSize(e){const t=Hash.SIZE.get(e);if("number"!=typeof t)throw new Error("Invalid hash algorithm");return t}static computeBlake2b(e){if(PlatformUtils.isNodeJs()){const t=new Uint8Array(Hash.getSize(Hash.Algorithm.BLAKE2B));NodeNative.node_blake2(t,new Uint8Array(e));return t}{let r;try{r=Module.stackSave();const i=Hash.getSize(Hash.Algorithm.BLAKE2B),s=Module.stackAlloc(i),n=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,n,e.length).set(e);const a=Module._nimiq_blake2(s,n,e.length);if(0!==a)throw a;const o=new Uint8Array(i);o.set(new Uint8Array(Module.HEAPU8.buffer,s,i));return o}catch(t){Log.w(Hash,t);throw t}finally{r!==undefined&&Module.stackRestore(r)}}}static computeSha256(e){if(PlatformUtils.isNodeJs()){const t=new Uint8Array(Hash.getSize(Hash.Algorithm.SHA256));NodeNative.node_sha256(t,new Uint8Array(e));return t}{let r;try{r=Module.stackSave();const i=Hash.getSize(Hash.Algorithm.SHA256),s=Module.stackAlloc(i),n=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,n,e.length).set(e);Module._nimiq_sha256(s,n,e.length);const a=new Uint8Array(i);a.set(new Uint8Array(Module.HEAPU8.buffer,s,i));return a}catch(t){Log.w(Hash,t);throw t}finally{r!==undefined&&Module.stackRestore(r)}}}}Hash.Algorithm={BLAKE2B:1,ARGON2D:2,SHA256:3,SHA512:4};Hash.SIZE=new Map;Hash.SIZE.set(Hash.Algorithm.BLAKE2B,32);Hash.SIZE.set(Hash.Algorithm.ARGON2D,32);Hash.SIZE.set(Hash.Algorithm.SHA256,32);Hash.SIZE.set(Hash.Algorithm.SHA512,64);Hash.NULL=new Hash(new Uint8Array(32));Class.register(Hash);class PrivateKey extends Serializable{constructor(e){super();if(!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==PrivateKey.SIZE)throw new Error("Primitive: Invalid length");this._obj=e}static generate(){const e=new Uint8Array(PrivateKey.SIZE);CryptoWorker.lib.getRandomValues(e);return new PrivateKey(e)}static unserialize(e){return new PrivateKey(e.read(PrivateKey.SIZE))}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).write(this._obj);return e}get serializedSize(){return PrivateKey.SIZE}overwrite(e){this._obj.set(e._obj)}equals(e){return e instanceof PrivateKey&&super.equals(e)}static _privateKeyDelinearize(e,t,r){if(e.byteLength!==PrivateKey.SIZE||t.byteLength!==PublicKey.SIZE||r.byteLength!==Hash.getSize(Hash.Algorithm.SHA512))throw Error("Wrong buffer size.");if(PlatformUtils.isNodeJs()){const i=new Uint8Array(PublicKey.SIZE);NodeNative.node_ed25519_derive_delinearized_private_key(i,new Uint8Array(r),new Uint8Array(t),new Uint8Array(e));return i}{let s;try{s=Module.stackSave();const n=Module.stackAlloc(PublicKey.SIZE),a=Module.stackAlloc(e.length),o=Module.stackAlloc(t.length),l=Module.stackAlloc(r.length);new Uint8Array(Module.HEAPU8.buffer,a,e.length).set(e);new Uint8Array(Module.HEAPU8.buffer,o,t.length).set(t);new Uint8Array(Module.HEAPU8.buffer,l,r.length).set(r);Module._ed25519_derive_delinearized_private_key(n,l,o,a);const c=new Uint8Array(PrivateKey.SIZE);c.set(new Uint8Array(Module.HEAPU8.buffer,n,PrivateKey.SIZE));return c}catch(i){Log.w(CryptoWorkerImpl,i);throw i}finally{s!==undefined&&Module.stackRestore(s)}}}}PrivateKey.SIZE=32;Class.register(PrivateKey);class PublicKey extends Serializable{static copy(e){return e?new PublicKey(new Uint8Array(e._obj)):e}constructor(e){super();if(!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==PublicKey.SIZE)throw new Error("Primitive: Invalid length");this._obj=e}static derive(e){return new PublicKey(PublicKey._publicKeyDerive(e._obj))}static sum(e){(e=e.slice()).sort((e,t)=>e.compare(t));return PublicKey._delinearizeAndAggregatePublicKeys(e)}static unserialize(e){return new PublicKey(e.read(PublicKey.SIZE))}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).write(this._obj);return e}get serializedSize(){return PublicKey.SIZE}equals(e){return e instanceof PublicKey&&super.equals(e)}hash(){return Hash.light(this.serialize())}compare(e){return BufferUtils.compare(this._obj,e._obj)}toAddress(){return Address.fromHash(this.hash())}toPeerId(){return new PeerId(this.hash().subarray(0,16))}static _delinearizeAndAggregatePublicKeys(e){const t=e.map(e=>e.serialize()),r=PublicKey._publicKeysHash(t),i=PublicKey._publicKeysDelinearizeAndAggregate(t,r);return new PublicKey(i)}static _publicKeyDerive(e){if(e.byteLength!==PrivateKey.SIZE)throw Error("Wrong buffer size.");if(PlatformUtils.isNodeJs()){const t=new Uint8Array(PublicKey.SIZE);NodeNative.node_ed25519_public_key_derive(t,new Uint8Array(e));return t}{let r;try{r=Module.stackSave();const i=Module.stackAlloc(PublicKey.SIZE),s=new Uint8Array(Module.HEAP8.buffer,i,PrivateKey.SIZE);s.set(e);const n=Module.stackAlloc(e.length),a=new Uint8Array(Module.HEAP8.buffer,n,PrivateKey.SIZE);a.set(e);Module._ed25519_public_key_derive(i,n);a.fill(0);const o=new Uint8Array(PublicKey.SIZE);o.set(s);return o}catch(t){Log.w(PublicKey,t);throw t}finally{r!==undefined&&Module.stackRestore(r)}}}static _publicKeysHash(e){if(e.some(e=>e.byteLength!==PublicKey.SIZE))throw Error("Wrong buffer size.");const t=new Uint8Array(e.length*PublicKey.SIZE);for(let i=0;i<e.length;++i)t.set(e[i],i*PublicKey.SIZE);if(PlatformUtils.isNodeJs()){const r=new Uint8Array(Hash.getSize(Hash.Algorithm.SHA512));NodeNative.node_ed25519_hash_public_keys(r,t,e.length);return r}{let i;try{i=Module.stackSave();const s=Hash.getSize(Hash.Algorithm.SHA512),n=Module.stackAlloc(s),a=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,a,t.length).set(t);Module._ed25519_hash_public_keys(n,a,e.length);const o=new Uint8Array(s);o.set(new Uint8Array(Module.HEAPU8.buffer,n,s));return o}catch(r){Log.w(PublicKey,r);throw r}finally{i!==undefined&&Module.stackRestore(i)}}}static _publicKeyDelinearize(e,t){if(e.byteLength!==PublicKey.SIZE||t.byteLength!==Hash.getSize(Hash.Algorithm.SHA512))throw Error("Wrong buffer size.");if(PlatformUtils.isNodeJs()){const r=new Uint8Array(PublicKey.SIZE);NodeNative.node_ed25519_delinearize_public_key(r,new Uint8Array(t),new Uint8Array(e));return r}{let i;try{i=Module.stackSave();const s=Module.stackAlloc(PublicKey.SIZE),n=Module.stackAlloc(e.length),a=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,n,e.length).set(e);new Uint8Array(Module.HEAPU8.buffer,a,t.length).set(t);Module._ed25519_delinearize_public_key(s,a,n);const o=new Uint8Array(PublicKey.SIZE);o.set(new Uint8Array(Module.HEAPU8.buffer,s,PublicKey.SIZE));return o}catch(r){Log.w(PublicKey,r);throw r}finally{i!==undefined&&Module.stackRestore(i)}}}static _publicKeysDelinearizeAndAggregate(e,t){if(e.some(e=>e.byteLength!==PublicKey.SIZE)||t.byteLength!==Hash.getSize(Hash.Algorithm.SHA512))throw Error("Wrong buffer size.");const r=new Uint8Array(e.length*PublicKey.SIZE);for(let s=0;s<e.length;++s)r.set(e[s],s*PublicKey.SIZE);if(PlatformUtils.isNodeJs()){const i=new Uint8Array(PublicKey.SIZE);NodeNative.node_ed25519_aggregate_delinearized_public_keys(i,new Uint8Array(t),r,e.length);return i}{let s;try{s=Module.stackSave();const n=Module.stackAlloc(PublicKey.SIZE),a=Module.stackAlloc(r.length),o=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,a,r.length).set(r);new Uint8Array(Module.HEAPU8.buffer,o,t.length).set(t);Module._ed25519_aggregate_delinearized_public_keys(n,o,a,e.length);const l=new Uint8Array(PublicKey.SIZE);l.set(new Uint8Array(Module.HEAPU8.buffer,n,PublicKey.SIZE));return l}catch(i){Log.w(PublicKey,i);throw i}finally{s!==undefined&&Module.stackRestore(s)}}}}PublicKey.SIZE=32;Class.register(PublicKey);class KeyPair extends Serializable{constructor(e,t,r=!1,i=null){if(!(e instanceof Object))throw new Error("Primitive: Invalid type");if(!(t instanceof Object))throw new Error("Primitive: Invalid type");super();this._locked=r;this._lockedInternally=r;this._lockSalt=i;this._publicKey=t;this._internalPrivateKey=new PrivateKey(e.serialize())}static generate(){const e=PrivateKey.generate();return new KeyPair(e,PublicKey.derive(e))}static derive(e){return new KeyPair(e,PublicKey.derive(e))}static fromHex(e){return KeyPair.unserialize(BufferUtils.fromHex(e))}static async fromEncrypted(e,t){if(1!==e.readUint8())throw new Error("Unsupported type");const r=e.readUint8();if(r>32)throw new Error("Rounds out-of-bounds");const i=Math.pow(2,r),s=PrivateKey.unserialize(e),n=e.read(KeyPair.EXPORT_SALT_LENGTH),a=e.read(KeyPair.EXPORT_CHECKSUM_LENGTH),o=new PrivateKey(await KeyPair._otpKdf(s.serialize(),t,n,i)),l=KeyPair.derive(o),c=l.publicKey.hash();if(!BufferUtils.equals(c.subarray(0,4),a))throw new Error("Invalid key");return l}static unserialize(e){const t=PrivateKey.unserialize(e),r=PublicKey.unserialize(e);let i=!1,s=null;if(e.readPos<e.byteLength){if(1===e.readUint8()){i=!0;s=e.read(32)}}return new KeyPair(t,r,i,s)}serialize(e){e=e||new SerialBuffer(this.serializedSize);this._privateKey.serialize(e);this.publicKey.serialize(e);if(this._locked){e.writeUint8(1);e.write(this._lockSalt)}else e.writeUint8(0);return e}get privateKey(){if(this.isLocked)throw new Error("Wallet is locked");return this._privateKey}get _privateKey(){return this._unlockedPrivateKey||this._internalPrivateKey}get publicKey(){return this._publicKey||(this._publicKey=new PublicKey(this._obj.publicKey))}get serializedSize(){return this._privateKey.serializedSize+this.publicKey.serializedSize+(this._locked?this._lockSalt.byteLength+1:1)}async exportEncrypted(e,t){const r=this._locked;if(this._locked)try{await this.unlock(t||e)}catch(n){throw new Error("KeyPair is locked and lock key mismatches")}const i=new Uint8Array(KeyPair.EXPORT_SALT_LENGTH);CryptoWorker.lib.getRandomValues(i);const s=new SerialBuffer(this.encryptedSize);s.writeUint8(1);s.writeUint8(Math.log2(KeyPair.EXPORT_KDF_ROUNDS));s.write(await KeyPair._otpKdf(this.privateKey.serialize(),e,i,KeyPair.EXPORT_KDF_ROUNDS));s.write(i);s.write(this.publicKey.hash().subarray(0,KeyPair.EXPORT_CHECKSUM_LENGTH));r&&this.relock();return s}get encryptedSize(){return 2+this.privateKey.serializedSize+KeyPair.EXPORT_SALT_LENGTH+KeyPair.EXPORT_CHECKSUM_LENGTH}async lock(e,t){if(this._locked)throw new Error("KeyPair already locked");t&&(this._lockSalt=t);if(!this._lockSalt||0===this._lockSalt.length){this._lockSalt=new Uint8Array(32);CryptoWorker.lib.getRandomValues(this._lockSalt)}this._internalPrivateKey.overwrite(await this._otpPrivateKey(e));this._clearUnlockedPrivateKey();this._locked=!0;this._lockedInternally=!0}async unlock(e){if(!this._locked)throw new Error("KeyPair not locked");const t=await this._otpPrivateKey(e);if(!PublicKey.derive(t).equals(this.publicKey))throw new Error("Invalid key");this._unlockedPrivateKey=t;this._locked=!1}relock(){if(this._locked)throw new Error("KeyPair already locked");if(!this._lockedInternally)throw new Error("KeyPair was never locked");this._clearUnlockedPrivateKey();this._locked=!0}_clearUnlockedPrivateKey(){if(this._lockedInternally&&!this._locked){this._unlockedPrivateKey.overwrite(PrivateKey.unserialize(new SerialBuffer(this._unlockedPrivateKey.serializedSize)));this._unlockedPrivateKey=null}}async _otpPrivateKey(e){return new PrivateKey(await KeyPair._otpKdf(this._privateKey.serialize(),e,this._lockSalt,KeyPair.LOCK_KDF_ROUNDS))}static async _otpKdf(e,t,r,i){return BufferUtils.xor(e,await(await CryptoWorker.getInstanceAsync()).kdf(t,r,i))}get isLocked(){return this._locked}equals(e){return e instanceof KeyPair&&super.equals(e)}}KeyPair.LOCK_KDF_ROUNDS=256;KeyPair.EXPORT_KDF_ROUNDS=256;KeyPair.EXPORT_CHECKSUM_LENGTH=4;KeyPair.EXPORT_SALT_LENGTH=16;Class.register(KeyPair);class RandomSecret extends Serializable{constructor(e){super();if(!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==RandomSecret.SIZE)throw new Error("Primitive: Invalid length");this._obj=e}static unserialize(e){return new RandomSecret(e.read(RandomSecret.SIZE))}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).write(this._obj);return e}get serializedSize(){return RandomSecret.SIZE}equals(e){return e instanceof RandomSecret&&super.equals(e)}}RandomSecret.SIZE=32;Class.register(RandomSecret);class Signature extends Serializable{static copy(e){if(!e)return e;const t=new Uint8Array(e._obj);return new Signature(t)}constructor(e){super();if(!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==Signature.SIZE)throw new Error("Primitive: Invalid length");this._obj=e}static create(e,t,r){return new Signature(Signature._signatureCreate(e._obj,t._obj,r))}static fromPartialSignatures(e,t){const r=Signature._combinePartialSignatures(e.serialize(),t.map(e=>e.serialize()));return new Signature(r)}static unserialize(e){return new Signature(e.read(Signature.SIZE))}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).write(this._obj);return e}get serializedSize(){return Signature.SIZE}verify(e,t){return Signature._signatureVerify(e._obj,t,this._obj)}equals(e){return e instanceof Signature&&super.equals(e)}static _combinePartialSignatures(e,t){const r=Signature._aggregatePartialSignatures(t);return BufferUtils.concatTypedArrays(e,r)}static _aggregatePartialSignatures(e){return e.reduce((e,t)=>Signature._scalarsAdd(e,t))}static _scalarsAdd(e,t){if(e.byteLength!==PartialSignature.SIZE||t.byteLength!==PartialSignature.SIZE)throw Error("Wrong buffer size.");if(PlatformUtils.isNodeJs()){const r=new Uint8Array(PartialSignature.SIZE);NodeNative.node_ed25519_add_scalars(r,new Uint8Array(e),new Uint8Array(t));return r}{let i;try{i=Module.stackSave();const s=Module.stackAlloc(PartialSignature.SIZE),n=Module.stackAlloc(e.length),a=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,n,e.length).set(e);new Uint8Array(Module.HEAPU8.buffer,a,t.length).set(t);Module._ed25519_add_scalars(s,n,a);const o=new Uint8Array(PartialSignature.SIZE);o.set(new Uint8Array(Module.HEAPU8.buffer,s,PartialSignature.SIZE));return o}catch(r){Log.w(Signature,r);throw r}finally{i!==undefined&&Module.stackRestore(i)}}}static _signatureCreate(e,t,r){if(t.byteLength!==PublicKey.SIZE||e.byteLength!==PrivateKey.SIZE)throw Error("Wrong buffer size.");if(PlatformUtils.isNodeJs()){const i=new Uint8Array(Signature.SIZE);NodeNative.node_ed25519_sign(i,new Uint8Array(r),new Uint8Array(t),new Uint8Array(e));return i}{let s;try{s=Module.stackSave();const n=Module.stackAlloc(Signature.SIZE),a=new Uint8Array(Module.HEAP8.buffer,n,Signature.SIZE),o=Module.stackAlloc(r.length);new Uint8Array(Module.HEAP8.buffer,o,r.length).set(r);const l=Module.stackAlloc(t.length);new Uint8Array(Module.HEAP8.buffer,l,t.length).set(t);const c=Module.stackAlloc(e.length),u=new Uint8Array(Module.HEAP8.buffer,c,e.length);u.set(e);Module._ed25519_sign(n,o,r.byteLength,l,c);u.fill(0);const h=new Uint8Array(Signature.SIZE);h.set(a);return h}catch(i){Log.w(Signature,i);throw i}finally{s!==undefined&&Module.stackRestore(s)}}}static _signatureVerify(e,t,r){if(PlatformUtils.isNodeJs())return!!NodeNative.node_ed25519_verify(new Uint8Array(r),new Uint8Array(t),new Uint8Array(e));{let s;try{s=Module.stackSave();const n=Module.stackAlloc(e.length);new Uint8Array(Module.HEAP8.buffer,n,e.length).set(e);const a=Module.stackAlloc(t.length);new Uint8Array(Module.HEAP8.buffer,a,t.length).set(t);const o=Module.stackAlloc(r.length);new Uint8Array(Module.HEAP8.buffer,o,r.length).set(r);return!!Module._ed25519_verify(o,a,t.byteLength,n)}catch(i){Log.w(Signature,i);throw i}finally{s!==undefined&&Module.stackRestore(s)}}}}Signature.SIZE=64;Class.register(Signature);class Commitment extends Serializable{static copy(e){return e?new Commitment(new Uint8Array(e._obj)):e}static sum(e){return new Commitment(Commitment._commitmentsAggregate(e.map(e=>e._obj)))}constructor(e){super();if(!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==Commitment.SIZE)throw new Error("Primitive: Invalid length");this._obj=e}static unserialize(e){return new Commitment(e.read(Commitment.SIZE))}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).write(this._obj);return e}get serializedSize(){return Commitment.SIZE}equals(e){return e instanceof Commitment&&super.equals(e)}static _commitmentsAggregate(e){if(e.some(e=>e.byteLength!==PublicKey.SIZE))throw Error("Wrong buffer size.");const t=new Uint8Array(e.length*PublicKey.SIZE);for(let i=0;i<e.length;++i)t.set(e[i],i*PublicKey.SIZE);if(PlatformUtils.isNodeJs()){const r=new Uint8Array(PublicKey.SIZE);NodeNative.node_ed25519_aggregate_commitments(r,t,e.length);return r}{let i;try{i=Module.stackSave();const s=Module.stackAlloc(PublicKey.SIZE),n=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,n,t.length).set(t);Module._ed25519_aggregate_commitments(s,n,e.length);const a=new Uint8Array(PublicKey.SIZE);a.set(new Uint8Array(Module.HEAPU8.buffer,s,PublicKey.SIZE));return a}catch(r){Log.w(CryptoWorkerImpl,r);throw r}finally{i!==undefined&&Module.stackRestore(i)}}}}Commitment.SIZE=32;Class.register(Commitment);class CommitmentPair extends Serializable{constructor(e,t){super();if(!(e instanceof RandomSecret))throw new Error("Primitive: Invalid type");if(!(t instanceof Commitment))throw new Error("Primitive: Invalid type");this._secret=e;this._commitment=t}static generate(){const e=new Uint8Array(CommitmentPair.RANDOMNESS_SIZE);CryptoWorker.lib.getRandomValues(e);const t=CommitmentPair._commitmentCreate(e);return new CommitmentPair(new RandomSecret(t.secret),new Commitment(t.commitment))}static unserialize(e){const t=RandomSecret.unserialize(e),r=Commitment.unserialize(e);return new CommitmentPair(t,r)}static fromHex(e){return this.unserialize(BufferUtils.fromHex(e))}serialize(e){e=e||new SerialBuffer(this.serializedSize);this.secret.serialize(e);this.commitment.serialize(e);return e}get secret(){return this._secret}get commitment(){return this._commitment}get serializedSize(){return this.secret.serializedSize+this.commitment.serializedSize}equals(e){return e instanceof CommitmentPair&&super.equals(e)}static _commitmentCreate(e){if(PlatformUtils.isNodeJs()){const t=new Uint8Array(PublicKey.SIZE),r=new Uint8Array(PrivateKey.SIZE);NodeNative.node_ed25519_create_commitment(r,t,e);return{commitment:t,secret:r}}{let r;try{r=Module.stackSave();const i=Module.stackAlloc(PublicKey.SIZE),s=Module.stackAlloc(PrivateKey.SIZE),n=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,n,e.length).set(e);const a=Module._ed25519_create_commitment(s,i,n);if(1!==a)throw new Error(`Secret must not be 0 or 1: ${a}`);const o=new Uint8Array(PublicKey.SIZE),l=new Uint8Array(PrivateKey.SIZE);o.set(new Uint8Array(Module.HEAPU8.buffer,i,PublicKey.SIZE));l.set(new Uint8Array(Module.HEAPU8.buffer,s,PrivateKey.SIZE));return{commitment:o,secret:l}}catch(t){Log.w(CommitmentPair,t);throw t}finally{r!==undefined&&Module.stackRestore(r)}}}}CommitmentPair.SERIALIZED_SIZE=RandomSecret.SIZE+Signature.SIZE;CommitmentPair.RANDOMNESS_SIZE=32;Class.register(CommitmentPair);class PartialSignature extends Serializable{constructor(e){super();if(!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==PartialSignature.SIZE)throw new Error("Primitive: Invalid length");this._obj=e}static create(e,t,r,i,s,n){const a=PartialSignature._delinearizedPartialSignatureCreate(r.map(e=>e._obj),e._obj,t._obj,i._obj,s._obj,n);return new PartialSignature(a)}static unserialize(e){return new PartialSignature(e.read(PartialSignature.SIZE))}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).write(this._obj);return e}get serializedSize(){return PartialSignature.SIZE}equals(e){return e instanceof PartialSignature&&super.equals(e)}static _delinearizedPartialSignatureCreate(e,t,r,i,s,n){if(e.some(e=>e.byteLength!==PublicKey.SIZE)||t.byteLength!==PrivateKey.SIZE||r.byteLength!==PublicKey.SIZE||i.byteLength!==RandomSecret.SIZE||s.byteLength!==Commitment.SIZE)throw Error("Wrong buffer size.");const a=new Uint8Array(e.length*PublicKey.SIZE);for(let l=0;l<e.length;++l)a.set(e[l],l*PublicKey.SIZE);if(PlatformUtils.isNodeJs()){const o=new Uint8Array(PartialSignature.SIZE);NodeNative.node_ed25519_delinearized_partial_sign(o,new Uint8Array(n),new Uint8Array(s),new Uint8Array(i),new Uint8Array(a),e.length,new Uint8Array(r),new Uint8Array(t));return o}{let l;try{l=Module.stackSave();const c=Module.stackAlloc(PartialSignature.SIZE),u=Module.stackAlloc(a.length),h=Module.stackAlloc(t.length),d=Module.stackAlloc(r.length),f=Module.stackAlloc(i.length),g=Module.stackAlloc(s.length),_=Module.stackAlloc(n.length);new Uint8Array(Module.HEAPU8.buffer,u,a.length).set(a);new Uint8Array(Module.HEAPU8.buffer,h,t.length).set(t);new Uint8Array(Module.HEAPU8.buffer,d,r.length).set(r);new Uint8Array(Module.HEAPU8.buffer,f,i.length).set(i);new Uint8Array(Module.HEAPU8.buffer,g,s.length).set(s);new Uint8Array(Module.HEAPU8.buffer,_,n.length).set(n);Module._ed25519_delinearized_partial_sign(c,_,n.length,g,f,u,e.length,d,h);const y=new Uint8Array(PartialSignature.SIZE);y.set(new Uint8Array(Module.HEAPU8.buffer,c,PartialSignature.SIZE));return y}catch(o){Log.w(CryptoWorkerImpl,o);throw o}finally{l!==undefined&&Module.stackRestore(l)}}}}PartialSignature.SIZE=32;Class.register(PartialSignature);class Address extends Serializable{static copy(e){if(!e)return e;const t=new Uint8Array(e._obj);return new Address(t)}static fromHash(e){return new Address(e.subarray(0,Address.SERIALIZED_SIZE))}constructor(e){super();if(!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==Address.SERIALIZED_SIZE)throw new Error("Primitive: Invalid length");this._obj=e}static unserialize(e){return new Address(e.read(Address.SERIALIZED_SIZE))}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).write(this._obj);return e}subarray(e,t){return this._obj.subarray(e,t)}get serializedSize(){return Address.SERIALIZED_SIZE}equals(e){return e instanceof Address&&super.equals(e)}static fromString(e){try{return Address.fromUserFriendlyAddress(e)}catch(t){}try{return Address.fromHex(e)}catch(t){}try{return Address.fromBase64(e)}catch(t){}throw new Error("Invalid address format")}static fromBase64(e){return new Address(BufferUtils.fromBase64(e))}static fromHex(e){return new Address(BufferUtils.fromHex(e))}static fromUserFriendlyAddress(e){if((e=e.replace(/ /g,"")).substr(0,2).toUpperCase()!==Address.CCODE)throw new Error("Invalid Address: Wrong country code");if(36!==e.length)throw new Error("Invalid Address: Should be 36 chars (ignoring spaces)");if(1!==Address._ibanCheck(e.substr(4)+e.substr(0,4)))throw new Error("Invalid Address: Checksum invalid");return new Address(BufferUtils.fromBase32(e.substr(4)))}static _ibanCheck(e){const t=e.split("").map(e=>{const t=e.toUpperCase().charCodeAt(0);return t>=48&&t<=57?e:(t-55).toString()}).join("");let r="";for(let i=0;i<Math.ceil(t.length/6);i++)r=(parseInt(r+t.substr(6*i,6))%97).toString();return parseInt(r)}toUserFriendlyAddress(e=!0){const t=BufferUtils.toBase32(this.serialize()),r=("00"+(98-Address._ibanCheck(t+Address.CCODE+"00"))).slice(-2);let i=Address.CCODE+r+t;e&&(i=i.replace(/.{4}/g,"$& ").trim());return i}}Address.CCODE="NQ";Address.SERIALIZED_SIZE=20;Address.HEX_SIZE=40;Address.NULL=new Address(new Uint8Array(Address.SERIALIZED_SIZE));Address.CONTRACT_CREATION=new Address(new Uint8Array(Address.SERIALIZED_SIZE));Class.register(Address);class Account{constructor(e,t){if(!NumberUtils.isUint8(e))throw new Error("Malformed type");if(!NumberUtils.isUint64(t))throw new Error("Malformed balance");this._type=e;this._balance=t}static unserialize(e){const t=e.readUint8();e.readPos--;if(!Account.TYPE_MAP.has(t))throw new Error("Unknown account type");return Account.TYPE_MAP.get(t).unserialize(e)}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).writeUint8(this._type);e.writeUint64(this._balance);return e}get serializedSize(){return 9}equals(e){return BufferUtils.equals(this.serialize(),e.serialize())}toString(){return`Account{type=${this._type}, balance=${this._balance.toString()}`}get balance(){return this._balance}get type(){return this._type}withBalance(e){throw new Error("Not yet implemented.")}withOutgoingTransaction(e,t,r,i=!1){if(i){if(t<e.validityStartHeight||t>=e.validityStartHeight+Policy.TRANSACTION_VALIDITY_WINDOW)throw new Error("Validity Error!");return this.withBalance(this._balance+e.value+e.fee)}{const i=this._balance-e.value-e.fee;if(i<0)throw new Error("Balance Error!");if(t<e.validityStartHeight||t>=e.validityStartHeight+Policy.TRANSACTION_VALIDITY_WINDOW)throw new Error("Validity Error!");if(r.containsTransaction(e))throw new Error("Double Transaction Error!");return this.withBalance(i)}}withIncomingTransaction(e,t,r=!1){if(r){const t=this._balance-e.value;if(t<0)throw new Error("Balance Error!");return this.withBalance(t)}return this.withBalance(this._balance+e.value)}withContractCommand(e,t,r=!1){throw new Error("Not yet implemented")}isInitial(){return this===Account.INITIAL}isToBePruned(){return 0===this._balance&&!this.isInitial()}}Account.Type={BASIC:0,VESTING:1,HTLC:2};Account.TYPE_MAP=new Map;Class.register(Account);class Transaction{constructor(e,t,r,i,s,n,a,o,l,c,u,h=GenesisConfig.NETWORK_ID){if(!(t instanceof Address))throw new Error("Malformed sender");if(!NumberUtils.isUint8(r))throw new Error("Malformed sender type");if(!(i instanceof Address))throw new Error("Malformed recipient");if(!NumberUtils.isUint8(s))throw new Error("Malformed recipient type");if(!NumberUtils.isUint64(n)||0===n)throw new Error("Malformed value");if(!NumberUtils.isUint64(a))throw new Error("Malformed fee");if(!NumberUtils.isUint32(o))throw new Error("Malformed validityStartHeight");if(!NumberUtils.isUint8(l)&&(l&~Transaction.Flag.ALL)>0)throw new Error("Malformed flags");if(!(c instanceof Uint8Array&&NumberUtils.isUint16(c.byteLength)))throw new Error("Malformed data");if(u&&(!(u instanceof Uint8Array)||!NumberUtils.isUint16(u.byteLength)))throw new Error("Malformed proof");if(!NumberUtils.isUint8(h))throw new Error("Malformed networkId");this._format=e;this._sender=t;this._senderType=r;this._recipient=i;this._recipientType=s;this._value=n;this._fee=a;this._networkId=h;this._validityStartHeight=o;this._flags=l;this._data=c;this._proof=u;this._recipient===Address.CONTRACT_CREATION&&(this._recipient=this.getContractCreationAddress())}static unserialize(e){const t=e.readUint8();e.readPos--;if(!Transaction.FORMAT_MAP.has(t))throw new Error("Invalid transaction type");return Transaction.FORMAT_MAP.get(t).unserialize(e)}serializeContent(e){(e=e||new SerialBuffer(this.serializedContentSize)).writeUint16(this._data.byteLength);e.write(this._data);this._sender.serialize(e);e.writeUint8(this._senderType);this._recipient.serialize(e);e.writeUint8(this._recipientType);e.writeUint64(this._value);e.writeUint64(this._fee);e.writeUint32(this._validityStartHeight);e.writeUint8(this._networkId);e.writeUint8(this._flags);return e}get serializedContentSize(){return 2+this._data.byteLength+this._sender.serializedSize+1+this._recipient.serializedSize+1+8+8+4+1+1}verify(e){this._valid===undefined&&(this._valid=this._verify(e));return this._valid}_verify(e=GenesisConfig.NETWORK_ID){if(this._networkId!==e){Log.w(Transaction,"Transaction is not valid in this network",this);return!1}if(this._recipient.equals(this._sender)){Log.w(Transaction,"Sender and recipient must not match",this);return!1}if(!Account.TYPE_MAP.has(this._senderType)||!Account.TYPE_MAP.has(this._recipientType)){Log.w(Transaction,"Invalid account type",this);return!1}if(!Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)){Log.w(Transaction,"Invalid for sender",this);return!1}if(!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)){Log.w(Transaction,"Invalid for recipient",this);return!1}return!0}get serializedSize(){throw new Error("Getter needs to be overwritten by subclasses")}serialize(e){throw new Error("Method needs to be overwritten by subclasses")}hash(){this._hash=this._hash||Hash.light(this.serializeContent());return this._hash}compare(e){return this.fee/this.serializedSize>e.fee/e.serializedSize?-1:this.fee/this.serializedSize<e.fee/e.serializedSize?1:this.serializedSize>e.serializedSize?-1:this.serializedSize<e.serializedSize?1:this.fee>e.fee?-1:this.fee<e.fee?1:this.value>e.value?-1:this.value<e.value?1:this.compareBlockOrder(e)}compareBlockOrder(e){const t=this._recipient.compare(e._recipient);if(0!==t)return t;if(this._validityStartHeight<e._validityStartHeight)return-1;if(this._validityStartHeight>e._validityStartHeight)return 1;if(this._fee>e._fee)return-1;if(this._fee<e._fee)return 1;if(this._value>e._value)return-1;if(this._value<e._value)return 1;const r=this._sender.compare(e._sender);return 0!==r?r:this._recipientType<e._recipientType?-1:this._recipientType>e._recipientType?1:this._senderType<e._senderType?-1:this._senderType>e._senderType?1:this._flags<e._flags?-1:this._flags>e._flags?1:BufferUtils.compare(this._data,e._data)}equals(e){return e instanceof Transaction&&this._sender.equals(e._sender)&&this._senderType===e._senderType&&this._recipient.equals(e._recipient)&&this._recipientType===e._recipientType&&this._value===e._value&&this._fee===e._fee&&this._validityStartHeight===e._validityStartHeight&&this._networkId===e._networkId&&this._flags===e._flags&&BufferUtils.equals(this._data,e._data)}toString(){return"Transaction{"+`sender=${this._sender.toBase64()}, `+`recipient=${this._recipient.toBase64()}, `+`value=${this._value}, `+`fee=${this._fee}, `+`validityStartHeight=${this._validityStartHeight}, `+`networkId=${this._networkId}`+"}"}getContractCreationAddress(){const e=Transaction.unserialize(this.serialize());e._recipient=Address.NULL;e._hash=null;return Address.fromHash(e.hash())}get sender(){return this._sender}get senderType(){return this._senderType}get recipient(){return this._recipient}get recipientType(){return this._recipientType}get value(){return this._value}get fee(){return this._fee}get feePerByte(){return this._fee/this.serializedSize}get networkId(){return this._networkId}get validityStartHeight(){return this._validityStartHeight}get flags(){return this._flags}hasFlag(e){return(this._flags&e)>0}get data(){return this._data}get proof(){return this._proof}set proof(e){this._proof=e}}Transaction.Format={BASIC:0,EXTENDED:1};Transaction.Flag={NONE:0,CONTRACT_CREATION:1,ALL:1};Transaction.FORMAT_MAP=new Map;Class.register(Transaction);class SignatureProof{static verifyTransaction(e){try{const r=new SerialBuffer(e.proof),i=SignatureProof.unserialize(r);if(r.readPos!==r.byteLength){Log.w(SignatureProof,"Invalid SignatureProof - overlong");return!1}return i.verify(e.sender,e.serializeContent())}catch(t){Log.w(SignatureProof,`Failed to verify transaction: ${t.message||t}`,t);return!1}}static singleSig(e,t){return new SignatureProof(e,new MerklePath([]),t)}static multiSig(e,t,r){const i=MerklePath.compute(t,e);return new SignatureProof(e,i,r)}constructor(e,t,r){if(!(e instanceof PublicKey))throw new Error("Malformed publickKey");if(!(t instanceof MerklePath))throw new Error("Malformed merklePath");if(r&&!(r instanceof Signature))throw new Error("Malformed signature");this._publicKey=e;this._merklePath=t;this._signature=r}static unserialize(e){const t=PublicKey.unserialize(e),r=MerklePath.unserialize(e),i=Signature.unserialize(e);return new SignatureProof(t,r,i)}serialize(e){e=e||new SerialBuffer(this.serializedSize);this._publicKey.serialize(e);this._merklePath.serialize(e);this._signature&&this._signature.serialize(e);return e}get serializedSize(){return this._publicKey.serializedSize+this._merklePath.serializedSize+(this._signature?this._signature.serializedSize:0)}equals(e){return e instanceof SignatureProof&&this._publicKey.equals(e._publicKey)&&this._merklePath.equals(e._merklePath)&&(this._signature?this._signature.equals(e._signature):this._signature===e._signature)}verify(e,t){if(null!==e&&!this.isSignedBy(e)){Log.w(SignatureProof,"Invalid SignatureProof - signer does not match sender address");return!1}if(!this._signature){Log.w(SignatureProof,"Invalid SignatureProof - signature is missing");return!1}if(!this._signature.verify(this._publicKey,t)){Log.w(SignatureProof,"Invalid SignatureProof - signature is invalid");return!1}return!0}isSignedBy(e){const t=this._merklePath.computeRoot(this._publicKey);return Address.fromHash(t).equals(e)}get publicKey(){return this._publicKey}get merklePath(){return this._merklePath}get signature(){return this._signature}set signature(e){this._signature=e}}Class.register(SignatureProof);class BasicTransaction extends Transaction{constructor(e,t,r,i,s,n,a){if(!(e instanceof PublicKey))throw new Error("Malformed senderPubKey");if(n!==undefined&&!(n instanceof Signature))throw new Error("Malformed signature");const o=SignatureProof.singleSig(e,n);super(Transaction.Format.BASIC,e.toAddress(),Account.Type.BASIC,t,Account.Type.BASIC,r,i,s,Transaction.Flag.NONE,new Uint8Array(0),o.serialize(),a);this._signatureProof=o}static unserialize(e){const t=e.readUint8();Assert.that(t===Transaction.Format.BASIC);const r=PublicKey.unserialize(e),i=Address.unserialize(e),s=e.readUint64(),n=e.readUint64(),a=e.readUint32(),o=e.readUint8(),l=Signature.unserialize(e);return new BasicTransaction(r,i,s,n,a,l,o)}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).writeUint8(Transaction.Format.BASIC);this.senderPubKey.serialize(e);this._recipient.serialize(e);e.writeUint64(this._value);e.writeUint64(this._fee);e.writeUint32(this._validityStartHeight);e.writeUint8(this._networkId);this.signature.serialize(e);return e}get serializedSize(){return 1+this.senderPubKey.serializedSize+this._recipient.serializedSize+8+8+4+1+this.signature.serializedSize}get senderPubKey(){return this._signatureProof.publicKey}get signature(){return this._signatureProof.signature}set signature(e){this._signatureProof.signature=e;this._proof=this._signatureProof.serialize()}}Transaction.FORMAT_MAP.set(Transaction.Format.BASIC,BasicTransaction);Class.register(BasicTransaction);class ExtendedTransaction extends Transaction{constructor(e,t,r,i,s,n,a,o,l,c=new Uint8Array(0),u){super(Transaction.Format.EXTENDED,e,t,r,i,s,n,a,o,l,c,u)}static unserialize(e){const t=e.readUint8();Assert.that(t===Transaction.Format.EXTENDED);const r=e.readUint16(),i=e.read(r),s=Address.unserialize(e),n=e.readUint8(),a=Address.unserialize(e),o=e.readUint8(),l=e.readUint64(),c=e.readUint64(),u=e.readUint32(),h=e.readUint8(),d=e.readUint8(),f=e.readUint16(),g=e.read(f);return new ExtendedTransaction(s,n,a,o,l,c,u,d,i,g,h)}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).writeUint8(Transaction.Format.EXTENDED);this.serializeContent(e);e.writeUint16(this._proof.byteLength);e.write(this._proof);return e}get serializedSize(){return 1+this.serializedContentSize+2+this._proof.byteLength}}Transaction.FORMAT_MAP.set(Transaction.Format.EXTENDED,ExtendedTransaction);Class.register(ExtendedTransaction);class IWorker{static async createProxy(e,t,r){return new(IWorker.Proxy(e))(r,t)}static async startWorkerForProxy(e,t,r){if(IWorker._workersSupported){r||(r=`${Nimiq._path}worker.js`);return IWorker.createProxy(e,t,new Worker(window.URL.createObjectURL(new Blob([`Nimiq = {_path: '${Nimiq._path}'}; importScripts('${r.replace(/'/g,"")}');`]))))}await IWorker._workerImplementation[e.name].init(t);return IWorker._workerImplementation[e.name]}static async startWorkerPoolForProxy(e,t,r,i){return new(IWorker.Pool(e))(t=>IWorker.startWorkerForProxy(e,t,i),t,r).start()}static async stubBaseOnMessage(e){try{if("init"===e.data.command)if(IWorker._workerImplementation[e.data.args[0]]){const t=await IWorker._workerImplementation[e.data.args[0]].init(e.data.args[1]);self.postMessage({status:"OK",result:t,id:e.data.id})}else self.postMessage({status:"error",result:"Unknown worker!",id:e.data.id});else self.postMessage({status:"error",result:"Worker not yet initialized!",id:e.data.id})}catch(t){self.postMessage({status:"error",result:t,id:e.data.id})}}static get _workersSupported(){return"undefined"!=typeof Worker}static get areWorkersAsync(){return IWorker._workersSupported}static get _insideWebWorker(){return"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope}static get _global(){return"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:null}static prepareForWorkerUse(e,t){IWorker._insideWebWorker&&(self.onmessage=IWorker.stubBaseOnMessage);IWorker._workerImplementation=IWorker._workerImplementation||{};IWorker._workerImplementation[e.name]=t}static _loadBrowserScript(e,t){const r=document.getElementsByTagName("head")[0],i=document.createElement("script");i.type="text/javascript";i.src=e;const s=()=>window.setTimeout(t,100);i.onreadystatechange=s;i.onload=s;r.appendChild(i)}static Proxy(e){const t=class extends e{constructor(t,r){super();this._name=r;this._messageId=0;this._worker=t;this._worker.onmessage=this._receive.bind(this);this._waiting=new Map;return this._invoke("init",[e.name,r]).then(()=>this)}_receive(e){const t=this._waiting.get(e.data.id);if(t){this._waiting["delete"](e.data.id);"OK"===e.data.status?t.resolve(e.data.result):"error"===e.data.status&&t.error(e.data.result)}else Log.w(WorkerProxy,"Unknown reply",e)}_invoke(e,t=[]){return new Promise((r,i)=>{const s={command:e,args:t,id:this._messageId++};this._waiting.set(s.id,{resolve:r,error:i});this._worker.postMessage(s)})}destroy(){return this._invoke("destroy")}};for(const r of Object.getOwnPropertyNames(e.prototype))"function"==typeof e.prototype[r]&&"constructor"!==r&&(t.prototype[r]=function(...e){return this._invoke(r,e)});return t}static Stub(e){const t=class extends e{constructor(){super()}_result(e,t,r){self.postMessage({status:t,result:r,id:e.data.id})}_onmessage(e){try{const r=this._invoke(e.data.command,e.data.args);r instanceof Promise?r.then(t=>{this._result(e,"OK",t)}):this._result(e,"OK",r)}catch(t){this._result(e,"error",t.message||t)}}init(e){this._name=e;if(IWorker._insideWebWorker){self.name=e;self.onmessage=(e=>this._onmessage(e))}}_invoke(e,t){return this[e].apply(this,t)}destroy(){IWorker._insideWebWorker&&self.close()}};for(const r of Object.getOwnPropertyNames(e.prototype))"function"==typeof e.prototype[r]&&"constructor"!==r&&(t.prototype[r]=function(){throw`Not implemented in IWorker Stub: ${r}`});return t}static Pool(e){const t=class extends e{constructor(e,t="pool",r=1){super();this._proxyInitializer=e;this._name=t;this._poolSize=r;this._workers=[];this._freeWorkers=[];this._waitingCalls=[]}async start(){await this._updateToSize();return this}get poolSize(){return this._poolSize}set poolSize(e){this._poolSize=e;this._updateToSize()["catch"](Log.w.tag(IWorker))}destroy(){this._poolSize=0;return this._updateToSize()}_invoke(e,t){return IWorker._workersSupported?new Promise((r,i)=>{this._waitingCalls.push({name:e,args:t,resolve:r,error:i});const s=this._freeWorkers.shift();s&&this._step(s)["catch"](Log.w.tag(IWorker))}):this._workers[0][e].apply(this._workers[0],t)}async _step(e){let t=this._waitingCalls.shift();for(;t;){try{t.resolve(await e[t.name].apply(e,t.args))}catch(r){t.error(r)}if(-1===this._workers.indexOf(e)){e.destroy();return}t=this._waitingCalls.shift()}this._freeWorkers.push(e)}async _updateToSize(){if("undefined"==typeof Worker&&this._poolSize>1){Log.d(IWorker,"Pool of size larger than 1 requires WebWorker support.");this._poolSize=1}const e=[];for(;this._workers.length+e.length<this._poolSize;)e.push(this._proxyInitializer(`${this._name}#${this._workers.length+e.length}`));const t=await Promise.all(e);for(const r of t){this._workers.push(r);this._step(r)["catch"](Log.w.tag(IWorker))}for(;this._workers.length>this._poolSize;){const e=this._freeWorkers.shift()||this._workers.pop(),t=this._workers.indexOf(e);if(t>=0){this._workers.splice(t,1);e.destroy()}}return this}};for(const r of Object.getOwnPropertyNames(e.prototype))"function"==typeof e.prototype[r]&&"constructor"!==r&&(t.prototype[r]=function(...e){return this._invoke(r,e)});return t}}IWorker._moduleLoadedCallbacks={};IWorker._workerImplementation={};Class.register(IWorker);class WasmHelper{static async doImportBrowser(){if(!PlatformUtils.isNodeJs())if(WasmHelper._importStarted)Log.e(WasmHelper,"doImportBrowser invoked twice");else{WasmHelper._importStarted=!0;await WasmHelper.importWasmBrowser("worker-wasm.wasm")?await WasmHelper.importScriptBrowser("worker-wasm.js"):await WasmHelper.importScriptBrowser("worker-js.js");WasmHelper._importFinished=!0}}static doImportNodeJs(){PlatformUtils.isNodeJs()&&(WasmHelper.importWasmNodeJs("worker-wasm.wasm")?WasmHelper.importScriptNodeJs("worker-wasm.js"):WasmHelper.importScriptNodeJs("worker-js.js"))}static importWasmBrowser(e,t="Module"){e=WasmHelper._adjustWasmPath(e);if(!WasmHelper._global.WebAssembly){Log.w(WasmHelper,"No support for WebAssembly available.");return Promise.resolve(!1)}return new Promise(r=>{try{const s=new XMLHttpRequest;s.open("GET",e,!0);s.responseType="arraybuffer";s.onload=function(){WasmHelper._global[t]=WasmHelper._global[t]||{};WasmHelper._global[t].wasmBinary=s.response;r(!0)};s.onerror=function(){Log.w(WasmHelper,`Failed to access WebAssembly module ${e}`);r(!1)};s.send(null)}catch(i){Log.w(WasmHelper,`Failed to access WebAssembly module ${e}`);r(!1)}})}static importWasmNodeJs(e,t="Module"){e=WasmHelper._adjustWasmPath(e);if(!WasmHelper._global.WebAssembly){Log.w(WasmHelper,"No support for WebAssembly available.");return!1}const r=require("fs");try{const s=r.readFileSync(e);WasmHelper._global[t]=WasmHelper._global[t]||{};WasmHelper._global[t].wasmBinary=function(e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t[r]=e[r];return t}(s);return!0}catch(i){Log.w(WasmHelper,`Failed to access WebAssembly module ${e}: ${i}`);return!1}}static importScriptBrowser(e,t="Module"){if(t&&WasmHelper._global[t]&&WasmHelper._global[t].asm)return!1;e=WasmHelper._adjustScriptPath(e);const r=WasmHelper._global[t]||{};return new Promise(async(i,s)=>{t&&(r.onRuntimeInitialized=(()=>i(!0)));if("function"==typeof importScripts){await new Promise(r=>{WasmHelper._moduleLoadedCallbacks[t]=r;importScripts(e)});WasmHelper._global[t]=WasmHelper._global[t](r);t||i(!0)}else if("object"==typeof window){await new Promise(r=>{WasmHelper._moduleLoadedCallbacks[t]=r;WasmHelper._loadBrowserScript(e)});WasmHelper._global[t]=WasmHelper._global[t](r);t||i(!0)}else if("function"==typeof require){WasmHelper._global[t]=require(e)(r);t||i(!0)}else s("No way to load scripts.")})}static importScriptNodeJs(e,t="Module"){if(t&&WasmHelper._global[t]&&WasmHelper._global[t].asm)return!1;e=WasmHelper._adjustScriptPath(e);const r=WasmHelper._global[t]||{};if("function"==typeof require){WasmHelper._global[t]=require(e)(r);if(!t)return!0}return!1}static fireModuleLoaded(e="Module"){if("function"==typeof WasmHelper._moduleLoadedCallbacks[e]){WasmHelper._moduleLoadedCallbacks[e]();WasmHelper._moduleLoadedCallbacks[e]=null}}static _loadBrowserScript(e){const t=document.getElementsByTagName("head")[0],r=document.createElement("script");r.type="text/javascript";r.src=e;t.appendChild(r)}static _adjustWasmPath(e){"undefined"!=typeof Nimiq&&Nimiq._path&&(e=`${Nimiq._path}${e}`);"string"==typeof __dirname&&-1===e.indexOf("/")&&(e=`${__dirname}/${e}`);return e}static _adjustScriptPath(e){"undefined"!=typeof Nimiq&&Nimiq._path&&(e=`${Nimiq._path}${e}`);"string"==typeof __dirname&&-1===e.indexOf("/")&&(e=`${__dirname}/${e}`);return e}static get _global(){return"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:null}}WasmHelper._moduleLoadedCallbacks={};Class.register(WasmHelper);class CryptoWorker{static get lib(){return CryptoLib.instance}static async getInstanceAsync(){CryptoWorker._workerAsync||(CryptoWorker._workerAsync=await IWorker.startWorkerPoolForProxy(CryptoWorker,"crypto",4));return CryptoWorker._workerAsync}async computeArgon2d(e){}async computeArgon2dBatch(e){}async kdf(e,t,r){}async blockVerify(e,t,r,i,s){}}CryptoWorker._workerAsync=null;Class.register(CryptoWorker);class GenesisConfig{static main(){GenesisConfig.init(GenesisConfig.CONFIGS.main)}static test(){GenesisConfig.init(GenesisConfig.CONFIGS.test)}static dev(){GenesisConfig.init(GenesisConfig.CONFIGS.dev)}static bounty(){GenesisConfig.init(GenesisConfig.CONFIGS.bounty)}static init(e){if(GenesisConfig._config)throw new Error("GenesisConfig already initialized");if(!e.NETWORK_ID)throw new Error("Config is missing network id");if(!e.NETWORK_NAME)throw new Error("Config is missing database prefix");GenesisConfig._config=e}static get NETWORK_ID(){if(!GenesisConfig._config)throw new Error("GenesisConfig not initialized");return GenesisConfig._config.NETWORK_ID}static get NETWORK_NAME(){if(!GenesisConfig._config)throw new Error("GenesisConfig not initialized");return GenesisConfig._config.NETWORK_NAME}}Class.register(GenesisConfig);GenesisConfig.CONFIGS={test:{NETWORK_ID:1,NETWORK_NAME:"test"},dev:{NETWORK_ID:2,NETWORK_NAME:"dev"},bounty:{NETWORK_ID:3,NETWORK_NAME:"bounty"}};GenesisConfig.CONFIGS.main=GenesisConfig.CONFIGS.test;e._loaded=!0;"function"==typeof e._onload&&e._onload()}(Nimiq);
//# sourceMappingURL=web-offline.js.map
